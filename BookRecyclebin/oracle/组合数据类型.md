# 记录类型 record

- 一个记录即一组存储在若干字段中的相关联的数据，而记录中的每个字段都具有各自的名字和数据类型。记录包含一个或多个字段，可以是：标量、记录、index by表的数据类型。可以为记录赋初值或定义not null约束，没有初始化的默认值为null，可以声明和引用嵌套的记录。如果两个记录具有完全相同的数据类型，可以将一个记录直接赋值给另一个记录

```plsql
declare
  type 要定义的记录数据类型名称 is record(
    --字段声明
    变量1 数据类型 [约束],
    ... 
    --注意：没有分号 ;
  );
  变量名(记录名) 刚刚定义的数据类型名称 [赋初值];
  --创建变量
begin
  --访问字段
  记录名.字段名 --可以当成一个变量使用
end;
```

```plsql
declare 
 type person is record(
   name varchar2(20)
  ,age number(3)
  );

 type student is record(
   name varchar2(20)
  ,age number(3)
  );
  
 Jac person;
 Jac_copy person;
 Tom student;
 
begin
  Jac.name := 'Jac';
  Jac.age := 18;
  dbms_output.put_line(Jac.name || ' : ' || Jac.age);
  
  Jac_copy := Jac;
  --相同类型的（person）可直接赋值
  
  --Tom := Jac; 报错PLS-00382
  --student和person不是同一类型
end;
```

# index by表 （PL/SQL表）

- index by表就是一组关联的键值对。index by表是用户定义的一种组合（集合）数据类型，可以利用一个主键（下标）值作为索引的方式存储数据，而主键（下标）值不必是顺序的，既可以是正也可以是负。index by表没有界限，大小可以动态的。

- index by表由两个组件（两列）所组成：数据类型为binary\_integer或pls\_integer的主键，标量或记录（record）数据类型的列。index by表中的元素可以是任何标量类型/记录类型，而主键（下标）既可以是一个数字，也可以是一个字符串。index by表的大小是没有限制的，在index by表中，数据行（元素）的个数可以动态地增长。

```plsql
declare
 type 数据类型名 is table OF 列数据类型|变量%type|表%rowtype
     [index by pls_integer|binary_integer|varchar2(20)];

 变量名 数据类型名；
begin
  ...
end;
```

- 不能在声明index by表时将其初始化。可以在index by表上加not null约束，以防止将空值null赋于index by表中元素。

```plsql
declare
 type name_table_type is table OF employees.last_name%type
      index by pls_integer;
      
 type hire_date_table_type is table OF employees.hire_date%type
      index by binary_integer;
  
 name_table name_table_type;
 hire_date_table hire_date_table_type;
 
 v_count number(6) := &p_count;
 
begin
  for i IN 1..v_count loop
    name_table(i) := ConCAT(TO_char(i),'号');
    hire_date_table(i) := TO_DATE('1997-11-12','yyyy-mm-dd');
    dbms_output.put_line(name_table(i) || ': ' || hire_date_table(i));
  end loop;
end;
```

```
表名.方法
```

| 方法                                   | 描述                                                         |
| :------------------------------------- | :----------------------------------------------------------- |
| exists(n)                              | 如果第n个元素在PL/SQL表（数组）中存在，返回true              |
| count                                  | 返回一个PL/SQL表当前所包含的元素个数                         |
| first                                  | 返回在一个PL/SQL表中第一个（最小的）下标数字，如果PL/SQL表是空的，返回null |
| last                                   | 返回在一个PL/SQL表中最后一个（最大的）下标数字，如果PL/SQL表是空的返回null |
| prior(n)                               | 返回在一个PL/SQL表中当前元素的前n个元素的下标值              |
| next(n)                                | 返回在一个PL/SQL表中当前元素的后n个元素的下标值              |
| delete<br />delete(n)<br />delete(m,n) | 删除一个PL/SQL表中的全部元素<br />删除一个PL/SQL表中的第n个元素<br />删除数组中m\~n范围内的全部元素 |

```plsql
declare
 type emp_num_type is table OF number
      index by varchar(20);
 
 total_employees emp_num_type;
 i varchar2(20);

begin
 -- 往index by表total_employees中插入数据
 
 select count(*)
 into total_employees('10号部门')
 --total_employees添加下标为'10号部门',
 --total_employees('10号部门')内容为count(*)的结果(数字)
 from employees
 where department_id = 10;
 
 select count(*) 
 into total_employees('20号部门')
 from employees
 where department_id = 20;
 
 select count(*)
 into total_employees('30号部门')
 from employees
 where department_id = 30;
 
-- 为 i 赋值为total_employees的第一个下标(主键)
 i := total_employees.first;

 dbms_output.put_line('按升序列出各部门名称和员工数：');

 while i is not null loop
   dbms_output.put_line(i || '的员工总数：' || TO_char(total_employees(i)));
   dbms_output.put_line('i的值: ' || i);
    
-- 为 i 赋值为total_employees的当前下标的下一个下标  
   i:= total_employees.next(i);
 end loop;
 dbms_output.put_line('i的值: ' || i);
     
 dbms_output.put_line(CHR(10));

-- 为 i 赋值为total_employees的最后一个下标(主键)
 i := total_employees.last;
 dbms_output.put_line('按降序列出各部门名称和员工数：');
 
 while i is not null loop
   dbms_output.put_line(i || '的员工总数：' || TO_char(total_employees(i)));
   dbms_output.put_line('i的值: ' || i);

-- 为 i 赋值为total_employees的当前下标的上一个下标  
   i := total_employees.prior(i);
 end loop;
    dbms_output.put_line('i的值: ' || i);
end;


**********************
按升序列出各部门名称和员工数：
10号部门的员工总数：1
i的值: 10号部门
20号部门的员工总数：2
i的值: 20号部门
30号部门的员工总数：6
i的值: 30号部门
i的值: 


按降序列出各部门名称和员工数：
30号部门的员工总数：6
i的值: 30号部门
20号部门的员工总数：2
i的值: 20号部门
10号部门的员工总数：1
i的值: 10号部门
i的值: 
PL/SQL procedure successfully completed
```

```plsql
declare
 type dept_table_type is table OF departments%rowtype
      index by pls_integer;
 dept_table dept_table_type;
 v_count number := 5;
 j number;
begin
  for i IN 1..v_count loop
    select *
    into dept_table(i * 10)
    from departments
    where department_id = i * 10;
  end loop;
  
  j := dept_table.first;
  while j is not null loop
    dbms_output.put_line(dept_table(j).department_id || ' ' ||
                         dept_table(j).department_name
                         );
    j := dept_table.next(j);
  end loop;
end;

*********************
10 Administration
20 Marketing
30 Purchasing
40 Human Resources
50 Shipping
PL/SQL procedure successfully completed
```

