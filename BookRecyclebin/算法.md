# 算法基础

## 稀疏数组

- 一个数组中大部分元素为０，或同一个值时（大多数的数据是重复的、无意义的），应该转换为稀疏数组。

- 稀疏数组记录数组一共有几行几列，有多少个不同的值，并把具有不同值的元素的行、列、值记录在一个小规模的数组。

<img src="../pictures/Snipaste_2022-11-24_20-47-39.png" width="400"/>  

# 算法思想

## 穷举算法

- 穷举：在明确知道问题的答案范围时，从所有的可能中搜索正确的。

## 贪心算法

- 局部最优解，即：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的时候使用贪心算法。贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（某个状态以后的过程不会影响以前的状态，只与当前状态有关）。

1. 建立数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。

## 递归算法

- 递归是自己调用自己，可以被栈替代。（递归利用栈实现，可能导致栈溢出）
- 递归的重点在于对**子问题**的处理。不在意具体操作，只关心初始条件、结束条件、上下层的变化关系。

## 分治界限

- 分治算法将父问题分解为子问题同等方式求解，常以递归的方式实现。

| 过程            | 说明                                     |
| --------------- | ---------------------------------------- |
| 分（Divide）    | 递归解决子问题（终止层、或可解决时停下） |
| 治（Conquer）   | 递归求解，如果问题够小直接求解。         |
| 合并（Combine） | 用子问题的解构建父类问题。               |

1. 原问题规模通常比较大，不易直接解决，但问题缩小到一定程度就能较容易的解决。
2. 问题可以分解为若干规模较小、求解方式相同/相似的子问题，且子问题之间求解是独立的互不影响。
3. 合并问题分解的子问题可以得到问题的解。

# 概率算法

1. 将问题转化为相应的几何图形，其面积S，计算其占面积S的部分面积S1。
2. 向几何图形中随机散点，统计S和S1中的点数，从而得到结果。
3. 若未达到所需的精度，则继续执行步骤2的操作；到达则输出。

>1. 数值概率算法
>2. 蒙特卡罗算法
>3. 拉斯维加斯算法
>4. 舍伍德算法

## 蒙特卡罗Π算法

1. 均匀撒点：使用Math.random()获取`0~1`的伪随机数坐标[x,y]。
2. 区域判断：距离坐标原点的距离小于等于1，`x*x + y*y<=1`

```java
public static double getPI(int n) {
    double x, y; //坐标
    int sum = 0; //在区域内的次数
    for (int i = 0; i < n; i++) {
        x = Math.random();
        y = Math.random();
        //圆形公式：x^2 + y^2 = 1
        if (x * x + y * y <= 1) {
            sum++;
        }
    }
    //因为是1/4的扇形区域[0~1]，需要乘以4
    return 4.0 * sum / n;
}
```

# 动态规划

