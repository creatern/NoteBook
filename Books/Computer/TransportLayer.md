# 传输层提供的服务

## 传输层的功能

- 从通信和信息处理的角度看，传输层向它上面的应用层提供通信访问，属于面向通信部分的最高层，同时也是用户功能中的最底层。
- 传输层位于网络层的之上，为运行在<b>不同主机上的进程之间</b>提供了逻辑通信，而网络层提供主机之间的逻辑通信。
- 在通信子网中没有传输层，传输层只存在于通信子网以外的主机中。

<img src="../../pictures/20240227172314.png" width="600"/> 

<table>
    <tr>
        <th width="10%">功能</th>
        <th width="45%">传输层</th>
        <th width="45%">网络层</th>
    </tr>
    <tr>
        <td>逻辑通信</td>
        <td>提供应用进程之间的逻辑通信（端到端）</td>
        <td>提供的是主机之间的逻辑通信（点到点）</td>
    </tr>
    <tr>
        <td>复用分用</td>
        <td>传输层的复用是<b>发送方不同的应用进程</b>都可使用同一个传输层协议传送数据；分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程</td>
        <td>网络层的复用是指<b>发送方不同协议的数据</b>都可封装成IP数据报发送出去；分用是指接收方的网络层在剥去首部后把数据交付给相应的协议</td>
    </tr>
    <tr>
        <td>差错检测</td>
        <td>还要对收到的报文进行差错检测（首部和数据部分）</td>
        <td>只检查IP数据报的首部，不检验数据部分是否出错</td>
    </tr>
    <tr>
        <td>传输协议</td>
        <td>提供两种不同的传输协议，面向连接的TCP和无连接的UDP</td>
        <td>无法同时实现两种协议，要么只提供面向连接的服务（如虚电路等），要么只提供无连接的服务（如数据报）</td>
    </tr>
</table>

-  传输层向高层用户屏蔽了低层网络核心的细节。

## 传输层的寻址与端口

### 端口

- 端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层指定应当将其报文段中的数据向上通过端口交付给应用层相应的进程。
- 端口是传输层服务访问点（TSAP），而端口号标识的是主机中的应用进程。

> 数据链路层的SAP是MAC地址；网络层的SAP是IP地址；传输层的SAP是端口。

- 传输层使用的是软件端口。

<table>
    <tr>
        <td width="10%">软件端口</td>
        <td width="90%">在协议栈层间的抽象的协议端口，应用层的各种协议进程与传输实体进行层间交互的一种地址</td>
    </tr>
    <tr>
        <td>硬件端口</td>
        <td>不同硬件设备进行交换的接口</td>
    </tr>
</table>

### 端口号

- 应用进程通过端口号进行标识，端口号长度为16bit，能够表示65536（2<sup>16</sup>）个不同的端口号。端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程。
- 根据端口号范围可将端口分为两类：服务器端使用的端口号、客户端使用的端口号。

<table>
    <tr>
        <td width="20%" rowspan="2">服务器端使用的端口号</td>
        <td width="15%">熟知端口号</td>
        <td width="65%">数值为0~1023，IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，且所有用户都知晓</td>
    </tr>
    <tr>
    <td>登记端口号</td>
    <td>数值为1024~49151，供没有熟知端口号的应用程序使用，必须在IANA登记使用，避免重复</td>
    </tr>
    <tr>
        <td>客户端使用的端口号<br/>（短暂端口号、临时端口）</td>
        <td colspan="2">数值为49152~65535，仅在客户端进程运行时才动态地选择，通信结束后此类端口号就不复存在，以供其他客户进程使用</td>
    </tr>
</table>

- 常见的应用层协议使用的传输层协议及熟知端口号：

<table>
    <tr>
        <th width="24%">UDP</th>
        <th width="24%">端口号</th>
        <td rowspan="7" width="4%"></td>
        <th width="24%">TCP</th>
        <th width="24%">端口号</th>
    </tr>
    <tr><td>RPC</td><td>111</td><td>SMTP</td><td>25</td></tr>
    <tr><td>DNS</td><td>53</td><td>FTP</td><td>21（控制连接）<br/> 20（数据连接）</td></tr>
    <tr><td>TFTP</td><td>69</td><td>TELNET</td><td>23</td></tr>
    <tr><td>SNMP</td><td>161</td><td>HTTP</td><td>80</td></tr>
    <tr><td>SNMP（trap）</td><td>162</td><td>HTTPS</td><td>443</td></tr>
    <tr><td>SMTP</td><td>25</td><td>POP3</td><td>110</td></tr>
</table>

### 套接字 Socket

- 套接字（Socket）：端口号拼接到IP地址即构成套接字Socket，在网络中采用发送方和接收方的套接字来识别端点，即套接字实际上是一个通信端口。套接字唯一地标识网络中的一台主机和其上的一个应用（进程）。

Socket = (IP地址: 端口号)

## 无连接服务与面向连接服务

- UDP提供无连接服务；TCP提供面向连接服务。

# UDP协议

- UDP（User Datagram Protocol，无连接的用户数据报协议）是无连接的非可靠传输层协议，向上提供的是一条不可靠的逻辑信道，所有维护可靠性的工作可由用户在应用层来完成。

1. UDP无须建立连接，无连接状态。UDP在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出如何确认。UDP不会引入建立连接的时延，故也不需要维护包括接收和发送缓冲、拥塞控制参数和序号以及确认号的连接状态参数。
2. 应用层能更好地控制要发送的数据和发送时间。UDP没有拥塞控制，主机的发送效率不会被网络中的拥塞影响，适用要求时延低的多媒体通信。
3. UDP比较简单，执行速度比较快、实时性好。主要应用于TFTP（小文件传送协议）、DNS、SNMP、RTP（实时传输协议）
4. UDP支持一对一、一对多、多对一、多对多的交互通信。

- UDP是面向报文的，报文是UDP数据报处理的最小单位。发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，一次发送一个报文，既不合并，也不拆分，而是保留这些报文的边界；接收方UDP对IP层交上来UDP数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文，若报文太长，UDP把它交给IP层后，可能会导致分片；若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，两者都会降低IP层的效率。

- IP 数据报和UDP数据报的区别：

1. IP数据报在网络层要经过路由的存储转发；而UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时，UDP数据报的信息对路由是不可见的。
2. UDP仅在IP数据报服务之上增加了两个最基本的服务：复用分用和差错检测。
3. IP知道怎样把分组投递给一台主机，但不知道怎样把它们投递给主机上的具体应用。

## UDP数据报的首部

- UDP数据报包含两部分：UDP首部和用户数据。UDP首部固定为8B，由4个字段组成，每个字段的长度都是2B。

<img src="../../pictures/计算机网络-UDP首部.drawio.svg" width="400"/> 

<table>
    <tr>
        <td width="10%">源端口</td>
        <td width="90%">源端口号，在需要对方回信时选用，不需要时可用全0</td>
    </tr>
    <tr>
        <td>目的端口</td>
        <td>目的端口号，传输层从IP层收到UDP数据报时，根据首部中的目的端口，把UDP数据包通过相应的端口上交给应用进程。如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程），则丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方</td>
    </tr>
    <tr>
        <td>长度</td>
        <td>UDP数据报的长度（包括首部和数据），其最小值是8（仅有首部）</td>
    </tr>
    <tr>
        <td rowspan="2">校验和</td>
        <td>检测UDP数据报在传输中是否有错，有错就丢弃</td>
    </tr>
    <tr>
        <td>该字段是可选的，若源主机
不想计算校验和，则直接令该字段为全0。</td>
    </tr>
</table>


## UDP校验

- 伪首部：UDP在计算检验和时，要在UDP数据报之前临时增加12B的伪首部。伪首部只是用于计算检验和，既不向上传送也不向下递交。通过伪首部不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。

<img src="../../pictures/计算机网络-UDP的伪首部.drawio.svg" width="800"/> 



- IP数据报的校验和只检验IP数据报的首部；而UDP的校验和检验UDP用户数据报的首部和数据部分。

1. 发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16位的字串接起来。若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾填入一个全零字节（此填充字节不发送)。然后按二进制反码计算出这些16 位字的和，将此和的二进制反码写入校验和字段，并发送。
2. 接收方把收到的 UDP 数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节）后，按二进制反码求这些16位字的和。当无差错时其结果应为全1，否则就表明有差错出现，接收方可以选择丢弃这个UDP数据报，或交付给上层并附上错误报告。

<img src="../../pictures/20240228160843.png" width="600"/> 

# TCP协议

- TCP（Transmission Control Protocol，面向连接的传输控制协议）使得传输层向上提供的是一条全双工的可靠逻辑信道。提供面向连接的服务，在传输数据之前必须先建立连接，数据传送结束后要释放连接。TCP主要解决传输的可靠、有序、无丢失、不重复的问题。

1. TCP需要建立连接，维护连接状态。不可避免地增加了许多开销，使得协议数据单元的头部增大很多，还要占用许多的处理机资源。
2. TCP不提供广播或组播服务。每一条TCP连接只能有两个端点，即一对一。
3. TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，在发送两端都设有发送缓冲和接收缓冲，来临时存放双向通信的数据。

<table>
    <tr>
        <td width="10%" rowspan="2">发送缓存</td>
        <td width="90%">发送应用程序传送给发送方TCP准备发送的数据</td>
    </tr>
    <tr>
        <td>TCP已发送但尚未收到确认的数据</td>
    </tr>
    <tr>
        <td rowspan="2">接收缓存</td>
        <td>按序到达但尚未被接收应用程序读取的数据</td>
    </tr>
    <tr>
        <td>不按序到达的数据</td>
    </tr>
</table>

- TCP面向字节流。尽管应用程序与TCP的交互是一次一个大小不等的数据块，但TCP将其视为一连串的无结构的字节流。TCP传输时是逐个字节传送的。
- TCP和UDP在发送报文时所采用的方式完全不同。UDP报文的发送长度由发送应用进程决定，而TCP报文的长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。如果应用进程传送到TCP缓冲的数据块太长，TCP可以将其划分得短一些再传送；如果太短，则TCP也可以等待积累到足够多的字节后再构成报文段发送出去。

- TCP适合可靠性更重要的场合，如FTP（文件传输协议）、HTTP（超文本传输协议）、TELNET（远程登录）

- TCP 和网络层虚电路的区别：

1. TCP报文段在传输层抽象的逻辑信道中传输，对路由器不可见；虚电路所经过的交换结点都必须保存虚电路状态信息。
2. 在网络层若采用虚电路方式，则无法提供无连接服务；而传输层采用TCP不影响网络层提供无连接服务。即，TCP和UDP分别拥有自己的端口号，互不干扰，可共存。

## TCP报文段

- 报文段：TCP传送的数据单元被称为报文段。TCP报文段既可以用来运载数据，也可以用来建立连接、释放连接和应答。一个TCP报文分为首部和数据两部分，整个TCP报文段作为IP数据报的数据部分被封装在IP数据报中。
- TCP报文段的首部至少有20B，其首部的前20B是固定的，后面有4N字节是可根据需要而增加的选项；即，首部的长度为4B的整数倍，最大为60B。

<img src="../../pictures/计算机网络-TCP报文段.drawio.svg" width="600"/> 

<table>
    <tr>
        <th width="10%">字段</th>
        <th width="5%">长度</th>
        <th width="85%">意义</th>
    </tr>
    <tr>
        <td>源端口</td>
        <td>2B</td>
        <td rowspan="2">端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口来实现</td>
    </tr>
    <tr>
        <td>目的端口</td>
        <td>2B</td>
    </tr>
    <tr>
        <td><a herf="#TCP序号">序号</a></td>
        <td>4B</td>
        <td>范围为0~2<sup>32</sup>-1。TCP是面向字节流的，序号字段的值指的是本报文段所发送数据的第一个字节的序号</td>
    </tr>
    <tr>
        <td>确认号</td>
        <td>4B</td>
        <td>期望收到对方<b>下一个</b>报文段的第一个数据字节的序号。若确认号为N，则表示到序号N-1为止的所有数据都已正确收到</td>
    </tr>
    <tr>
        <td>数据偏移</td>
        <td>4bit</td>
        <td>表示首部长度，指出TCP报文段的数据部分起始处距离TCP报文段的起始处有多远。数据偏移的单位是4B，因此TCP首部的最大长度为60B</td>
    </tr>
    <tr>
        <td>保留</td>
        <td>6bit</td>
        <td>保留为今后使用，目前应置为0</td>
    </tr>
    <tr>
        <td>URG</td>
        <td>1bit</td>
        <td>紧急位，当URG=1时，表明紧急指针字段有效，表示此报文段有紧急数据（数据部分从第一个字节到紧急指针所指字节），需要尽快传送</td>
    </tr>
    <tr>
        <td>ACK</td>
        <td>1bit</td>
        <td>确认位，仅当ACK=1时，确认号字段才有效；当ACK=0时，确认号字段无效。TCP规定，在连接建立后，所有传送的报文段都必须把ACK置1</td>
    </tr>
    <tr>
        <td>PSH</td>
        <td>1bit</td>
        <td>推送位（Push），接收方TCP收到PSH=1的报文段时，就尽快地交付给接收应用进程，而不是等到整个接收缓存都满了才向上交付</td>
    </tr>
    <tr>
        <td>RST</td>
        <td>1bit</td>
        <td>复位位（Reset），当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</td>
    </tr>
    <tr>
        <td>SYN</td>
        <td>1bit</td>
        <td>同步位，当SYN=1时，表示这是一个连接请求报文。若对方同意建立连接，则对方应在响应报文中使用SYN=1，ACK=1</td>
    </tr>
    <tr>
        <td>FIN</td>
        <td>1bit</td>
        <td>终止位（Finish），用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接</td>
    </tr>
    <tr>
        <td>窗口</td>
        <td>2B</td>
        <td>范围为0~2<sup>16</sup>-1，指出了现在允许对方发送的数据量，单位是字节。若确认号字段为701，窗口字段是1000，则表明从701号算起，发送此报文段的一方还有接收1000字节数据（字节序号701~1700）的接收缓冲空间</td>
    </tr>
    <tr>
        <td>校验和</td>
        <td>2B</td>
        <td>校验和字段检验的范围包括首部和数据。计算校验和时也需要加上12B的伪首部（协议字段为6且TCP长度）</td>
    </tr>
    <tr>
        <td>紧急指针</td>
        <td>2B</td>
        <td>紧急指针仅在URG=1时，才有效，指出本报文段的紧急数据共有多少字节</td>
    </tr>
    <tr>
        <td>选项</td>
        <td>可变</td>
        <td>TCP最初只规定了一种选项，MSS（Maximum Segment Size，最大报文段长度）是TCP报文段中的数据字段的最大长度</td>
    </tr>
    <tr>
        <td>填充</td>
        <td>可变</td>
        <td>全0，使得整个首部长度是4B的整数倍</td>
    </tr>
</table>

## TCP连接管理

- TCP是面向连接的协议，每个TCP连接都有三个阶段：连接建立、数据传送、连接释放。
- TCP把链接作为最基本的抽象，每一条TCP连接有两个端点（Socket），且被这两个套接字唯一确定。
- TCP连接的建立采用客户/服务器模式（C/S）。主动发起连接建立的应用进程称为客户（Client），被动等待连接建立的应用程序称为服务器（Server）。

### 三次握手 TCP连接的建立

<img src="../../pictures/计算机网络-TCP三次握手.drawio.svg" width="580"/> 

0. 建立连接之前，服务器进程处于<b>LISTEN</b>（收听）状态，等待客户的连接请求。
1. <b>第一次握手</b>，客户机的TCP首先向服务器的TCP发送<b>连接请求报文段（SYN=1, seq=x）</b>。TCP规定SYN报文段不能携带数据，且要消耗一个序号。此时，TCP客户进程进入<b>SYN-SENT</b>（同步已发送）状态。
2. <b>第二次握手</b>，服务器的TCP收到连接请求报文后，若同意建立连接，则向客户机发回<b>确认报文段（ACK=1, SYN=1, seq=y, ack=x+1）</b>，并为该TCP连接分配缓存和变量（<b>服务器端的资源分配</b>）。该确认报文段不能携带数据，且要消耗一个序号。此时，TCP服务器进程进入<b>SYN-RCVD</b>（同步收到）状态。在该阶段，服务器容易受到SYN洪泛攻击。
3. <b>第三次握手</b>，当客户机收到确认报文段后，还要向服务器给出<b>确认报文段（ACK=1, seq=x+1, ack=y+1）</b>，并为该TCP分配缓存和变量（<b>客户器端的资源分配</b>）。该报文段可以携带数据，若不携带数据则不消耗序号。此时，TCP客户进程进入<b>ESTABLISHED</b>（已建立连接）状态。
4. 以上步骤成功之后，就建立了TCP连接，可以进行全双工通信，传送应用层数据。

### 四次挥手 TCP连接的释放

<img src="../../pictures/计算机网络-TCP四次挥手.drawio.svg" width="650"/> 

- 参与TCP连接的两个进程中的任何一个都能终止该连接。

1. <b>第一次挥手</b>。客户机打算关闭连接时，向其TCP发送<b>连接释放报文段（FIN=1, seq=u）</b>，并通知发送数据，主动关闭TCP连接。FIN报文段即使不携带数据也要消耗一个序号。此时，TCP客户进程进入<b>FIN-WAIT-1</b>（终止等待1）状态。即，TCP客户进程停止发送数据，但TCP服务进程仍然可以发送数据。（序号u为TCP客户进程之前已传送的数据的最后一个字节的序号加1）
2. <b>第二次挥手</b>。服务器收到连接释放报文段后即发出<b>确认报文段（ACK=1, ack=u+1, seq=v）</b>，之后服务器进入<b>CLOSE-WAIT</b>（关闭等待）状态。此时，<b>TCP连接处于半关闭状态</b>，只释放了从客户机到服务器方向的连接，客户机仍然要接收服务器发送的数据。（序号v为TCP服务器进程之前已传送的数据的最后一个字节的序号加1）
3. <b>第三次挥手</b>。若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时发出<b>连接释放报文段（ACK=1, FIN=1, seq=w, ack=u+1）</b>。此时，TCP服务器进入<b>LAST-ACK</b>（最后确认）阶段。（序号w为TCP服务器进程在半关闭状态可能又已传送的数据的最后一个字节的序号加1）
4. <b>第四次挥手</b>。客户机收到连接释放报文段后，必须发出<b>确认报文段（ACK=1, seq=u+1, ack=w+1）</b>。此时，TCP连接还未释放，必须经过时间等待计时器设置的时间<b>2MSL</b>（最长报文段寿命）后，客户机才进入<b>CLOSED</b>（连接关闭）状态。此时，完成TCP连接释放。

## TCP可靠传输

- TCP提供的可靠数据传输服务保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一致。

### 序号

- TCP首部的<span name="TCP序号">序号</span>字段用来保证数据的能有序提交给应用层，TCP建立在传送的字节流之上，而不建立在报文段上。
- TCP连接传送的数据中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。

### 确认

- TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。
- TCP默认使用累积确认，即TCP只确认数据流中至第一个丢失字节为止的字节。

### 重传

- 有两种事件会导致TCP对报文段进行重传：超时和冗余ACK。

#### 超时

- 超时：TCP每发送一个报文段就对该报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认时，需要重传该报文段。
- 报文段的往返时间（Round-Trip Time，RTT）为了计算超时计数器的存储时间，TCP采用一种自适应算法，其记录一个报文段发出的时间，以及收到相应确认的时间，将这两个时间制成称为报文段的往返时间。TCP保留了RTT的一个加权平均往返时间RTT<sub>s</sub>，RTT<sub>s</sub>会随着RTT样本量的变化而变化。
- 超时计时器设置的超时重传时间（Retransmissioon Time-Out，RTO）应略大于RTT<sub>s</sub>。

#### 冗余ACK

- 冗余ACK：再次确认某个报文段的ACK，而发送方之前已经收到过该报文段的确认。TCP规定每当比期望大的失序报文段到达时，就发送一个冗余ACK，指明下一个期待字节的序号。
- <a href="#快速重传">快速重传</a>：TCP规定当发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。

## TCP流量控制

- TCP提供一种基于[滑动窗口协议](./Books/Computer/DataLinkLayer.md#滑动窗口)的流量控制机制。

<table>
    <tr>
        <td width="15%" rowspan="2">接收窗口 rwnd</td>
        <td width="85%">在通信过程中，<b>接收方</b>根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即 接收窗口 rwnd；也就是调整TCP报文段中的“窗口”字段值，来限制发送方向网络注入报文段的速率</td>
    </tr>
    <tr>
        <td>rwnd即接收方允许连续接收的最大能力，单位是字节。发送方总是根据最新收到的rwnd值来限制自己发送窗口的大小（min(rwnd,cwnd)），从而将未确认的数据量控制在rwnd大小之内，确保不会使接收方的接收缓存溢出</td>
    </tr>
    <tr>
        <td>拥塞窗口 cwnd</td>
        <td><b>发送方</b>根据其对当前网络拥塞程度的估计而确定的窗口值，其大小与网络的带宽和时延密切相关，反应网络的当前容量。只要网络出现拥塞，就需要减小一些拥塞窗口</td>
    </tr>
</table>

- 发送窗口的上限值 = min\[rwnd, cwnd\]。

<img src="../../pictures/20240229191917.png" width="560"/> 

- 传输层与数据链路层的流量控制的区别：传输层定义端到端用户之间的流量控制；数据链路层定义两个中间的相邻结点的流量控制，且数据链路层的滑动窗口协议的窗口大小是不能动态变化的。

## TCP拥塞控制

- 拥塞控制是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载。出现拥塞时，端点并不了解拥塞发生的细节，对通信控制的端点而言，拥塞往往表现为通信时延的增加。
- 拥塞控制与流量控制的区别：

1. 拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有主机、路由器以及降低网络性能有关的所有因素；流量控制往往是指点对点的通信量的控制，是个端到端的问题，仅仅需要抑制发送端发送数据的速率，使得接收端来得及接收。
2. 在流量控制中，发送方发送数据的量由接收方决定；而在拥塞控制中，则由发送方自己通过检测网络状况来决定。
3. 二者都通过控制发送方发送数据的速率来达到控制效果。

- 因特网建议标准定义了进行拥塞控制的4种算法：慢开始、拥塞避免、快重传、快恢复。在TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法；当发送方接收到冗余ACK时，采用快重传和快恢复算法。

### 慢开始和拥塞避免

#### 慢开始算法

- 慢开始算法：在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd=1（“慢”，目的是试探网络的拥塞情况），即一个最大报文段长度MSS。<b>每收到一个对新报文段的确认后，将cwnd加1</b>，即增大一个最大报文段长度MSS。每经过一个传输轮次（往返时延RTT），cwnd就会加倍，即cwnd的值随传输轮次指数增长。
- 慢开始算法一直把cwnd增大到一个规定的慢开始门限ssthresh（阈值），然后改用拥塞避免算法。

#### 拥塞避免算法

- 拥塞避免算法：让拥塞窗口cwnd缓慢增大。<b>每经过一个往返时延RTT就把发送方的拥塞窗口cwnd加1</b>，而不是加倍，使拥塞窗口cwnd按线性归零缓慢增大（加法增大）。

- 按照cwnd的大小执行不同的算法：

<table>
    <tr>
        <td width="30%">cwnd &le; ssthresh</td>
        <td width="70%">慢开始算法</td>
    </tr>
    <tr>
        <td>cwnd &ge; ssthresh</td>
        <td>停止使用慢开始算法，而改用拥塞避免算法</td>
    </tr>
</table>

#### 网络拥塞的处理

- 无论是在慢开始算法阶段还是拥塞避免算法阶段，只要发送方判断网络出现拥塞（未按时收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的cwnd值的一半（不小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。

<img src="../../pictures/20200429142015139.png" width="660"/>  

1. 初始时，拥塞窗口置为1，即cwnd=1，慢开始门限置为16，即ssthresh=16。
2. 慢开始阶段，cwnd的初值为1，以后发送方每收到一个确认ACK，cwnd值加1，也即经过每个传输轮次（RTT)，cwnd呈指数规律增长。当拥塞窗口cwnd增长到慢开始门限ssthresh时（即当cwnd=16时），就改用拥塞避免算法，cwnd按线性规律增长。
2. （TCP Tahoe版本）假定cwnd=24时网络出现超时，更新ssthresh值为12（即变为超时时cwnd值的一半），cwnd重置为1，并执行慢开始算法，当cwnd=12时，改为执行拥塞避免算法。

- 在慢开始（指数级增长）阶段，若2cwnd&gt;ssthresh，则下一个RTT后的cwnd等于ssthresh，而不等于2cwnd，即 cwnd 不能跃过ssthresh 值。
- 在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法：

<table>
    <tr>
        <td width="10%">乘法减小</td>
        <td width="90%">不论是在慢开始阶段还是在拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口的一半（并执行慢开始算法)。当网络频繁出现拥塞时,ssthresh值就下降得很快，以大大减少注入网络的分组数</td>
    </tr>
    <tr>
        <td>加法增大</td>
        <td>执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个RTT)，就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞</td>
    </tr>
</table>

### 快重传和快恢复

- 快重传和快恢复算法是对慢开始和拥塞避免算法的改进。

#### 快重传算法

- 快重传技术使用了冗余ACK来检测丢包的发生。同样，冗余ACK也用于网络拥塞的检测(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。

#### 快恢复算法

- 快恢复算法：当发送方连续收到三个冗余ACK(即重复确)时，执行“乘法减小”算法，把慢开始门限ssthresh设置为此时发送方cwnd的一半，以预防网络发生拥塞。把cwnd值设置为慢开始门限ssthresh改变后的数值（而不是1），然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。跳过了拥塞窗口cwnd从1起始的慢开始过程。

<img src="../../pictures/20200429142015139.png" width="660"/> 
