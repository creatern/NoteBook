# 操作系统的概念

## 操作系统的定义

- 计算机系统自下而上分为4个部分：硬件、操作系统、应用程序、用户。
- 操作系统（Operating System，OS）控制硬件，并协调各个用户应用程序的硬件使用。具体来说，操作系统是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。
- 一种公认的操作系统的定义是：操作系统是一直运行在计算机上的程序（内核，kernel）。（程序主要分为：内核、系统程序、应用程序）
- 分层次结构的现代操作系统，各项功能分别被设置在不同的层次。与硬件关联密切的模块（时钟管理、中断处理、设备驱动等），其次是运行频率较高的程序（进程管理、存储器管理、设备管理等），这两个部分共同组成了操作系统的内核。
- 内核是计算机上配置的底层软件，管理系统的各种资源，相当于应用程序与硬件的桥梁。大多数操作系统的内核包括4方面的内容：时钟管理、中断机制、原语、系统控制的数据结构及处理。

## 计算机系统的组成

### 计算机系统的运行

- 现代通用计算机系统包括一个或多个CPU和若干设备控制器，通过公用总线（提供了共享内存的访问）相连而成。每个设备控制器负责一类特定的设备。CPU和设备控制器可以并发执行，并且竞争访问内存。

1. 引导程序（bootstrap program）：计算机电源打开或重启以开始运行时，需要运行一个初始程序（引导程序）。引导程序一般位于计算机的固件（firmware）（如，ROM、EEPROM），初始化系统的各个组件，从CPU寄存器、设备控制器到内存内容。引导程序必须知道如何加载操作系统并且开始执行系统，也就是说，引导程序必须定位到操作系统内核并且加到内存中。
2. 一旦内核加到内存并执行，内核就开始为系统与用户提供服务。
3. 系统程序的生命周期和内核一样，其在启动时加到内存而成为系统进程（system process）或系统后台程序（system daemon），以提供一些服务。对于UNIX，首个系统进程“init”启动许多其他系统的后台程序。
4. 该阶段完成后，系统就完全启动了，并且等待事件发生。
5. 事件发生通常通过硬件或软件的中断（interrupt）来通知。硬件可以随时通过系统总线发送信号到CPU，以触发中断。软件可以通过执行系统调用（system call）（也称，监督程序调用 monitor call），以触发中断。
6. 当CPU被中断时，其停止当前正在做的事，并立即转到固定位置（通常包含中断服务程序的开始地址）再继续执行。
7. 中断服务程序开始执行，在执行完后，CPU重新执行被中断的计算。

### 存储结构

### I/O结构

## 操作系统的基本特征

- 操作系统的基本特征包括：并发（Concurrence）、共享（Sharing）、虚拟（Virtual）、异步（Asychronism）。其中，并发和共享是操作系统的两个最基本的特征，二者互为存在的条件。

<table>
    <tr>
        <td width="20%" rowspan="2">并发（Concurrence）</td>
        <td width="80%" colspan="2">并发是指两个或多个事件在<b>同一时间间隔</b>内发生</td>
    </tr>
    <tr>
        <td colspan="2">并行性是指系统具有同时进行运算或操作的特性，在<b>同一时刻</b>能完成两种或两种以上的工作；需要硬件的支持</td>
    </tr>
    <tr>
        <td width="20%" rowspan="3">共享（Sharing）</td>
        <td width="20%" colspan="2">共享（资源共享）是指系统中的资源可供内存中多个并发执行的进程共同使用。共享分为：互斥共享方式、同时访问方式</td>
    </tr>
    <tr>
        <td>互斥共享方式</td>
        <td>临界资源是指在一段时间内只允许一个进程访问的资源</td>
    </tr>
    <tr>
        <td>同时访问方式</td>
        <td>此处的“同时”是宏观的；而在微观上，可能是通过“分时共享”等方式实现的</td>
    </tr>
    <tr>
        <td width="20%" rowspan="2">虚拟（Virtual）</td>
        <td rowspan="2">虚拟技术</td>
        <td>时分复用技术</td>
    </tr>
    <tr>
        <td>空分复用技术</td>
    </tr>
    <tr>
        <td width="20%">异步（Asychronism）</td>
        <td width="80%" colspan="2">进程的异步性使得操作系统运行在一种随机的环境下；但只要运行环境相同，操作系统就须保证多次运行的结果也相同</td>
    </tr>
</table>

## 操作系统的目标与功能

- 操作系统的目标与功能：

1. 操作系统作为计算机资源的管理者，包括处理机管理、存储器管理、设备管理、文件管理。
2. 操作系统作为用户与计算机硬件系统之间的接口。

<table>
    <tr>
        <td width="10%" rowspan="3">命令接口</td>
        <td width="90%" colspan="2">命令接口的作用控制的主要方式分为联机控制方式和脱机控制方式。用户利用这些操作命令来组织和控制作业的执行</td>
    </tr>
    <tr>
        <td>联机命令接口（交互式命令接口）</td>
        <td>适用于分时或实时系统，由一组键盘操作命令组成</td>
    </tr>
    <tr>
        <td>脱机命令接口（批处理命令接口）</td>
        <td>适用于批处理系统，由一组作业控制命令组成</td>
    </tr>
    <tr>
        <td>程序接口</td>
        <td colspan="2">程序接口由一组系统调用（广义指令）组成，是为编程人员提供的接口。用户通过在程序中使用这些系统调用来请求操作系统（内核）服务</td>
    </tr>
</table>

3. 操作系统实现了对计算机资源的扩充。（扩充机器、虚拟机）

## 操作系统的发展历程

<table>
    <tr>
        <td width="15%">手工操作阶段</td>
        <td colspan="2">无操作系统。（1）用户独占主机；（2）CPU等待手工操作</td>
    </tr>
    <tr>
        <td rowspan="3">批处理阶段</td>
        <td colspan="2">作业自动控制，不能人机交互</td>
    </tr>
    <tr>
        <td width="15%">单道批处理系统</td>
        <td width="70%">（1）自动性；（2）顺序性；（3）单道性</td>
    </tr>
    <tr>
        <td>多道批处理系统</td>
        <td>（1）多道；（2）宏观上并行，微观上串行（轮占CPU）</td>
    </tr>
    <tr>
        <td>分时操作系统</td>
        <td colspan="2">分时技术（时间片）；实现了人机交互；多个用户通过终端同时共享一台主机。（1）同时性、多路性；（2）交互性；（3）独立性；（4）及时性</td>
    </tr>
    <tr>
        <td rowspan="3">实时操作系统</td>
        <td colspan="2">适合处理紧急任务（1）及时性；（2）可靠性</td>
    </tr>
    <tr>
        <td>硬实时操作系统</td>
        <td>某个地址必须绝对地在规定的时刻（或时间范围）发生</td>
    </tr>
    <tr>
        <td>软实时操作系统</td>
        <td>能够接受偶尔违反时间规定且不会引起任何永久性的损害</td>
    </tr>
    <tr>
        <td>网络操作系统</td>
        <td colspan="2">网络中各种资源的共享及各台计算机之间的通信</td>
    </tr>
    <tr>
        <td>分布式操作系统</td>
        <td colspan="2">分布式操作系统中的若干计算机相互协同完成同一任务，主要特点是分布性和并行性</td>
    </tr>
</table>

### 多道程序设计

- 多道程序设计（multiprogramming）通过安排作业（编码与数据）使得CPU总有一个执行作业，从而提高CPU利用率。
- 作业池（job pool）：操作系统在内存中同时保存多个任务，而由于主存大小不能容纳所有作业，于是将这些作业首先保存在磁盘的作业池上。该作业池包括磁盘上的、等待分配内存的所有进程。
- 内存的作业集是作业池的作业集的一个子集。从内存的作业集中，操作系统可以选择执行一个作业。该作业可能需要等待某个任务，此时，CPU会切换到另一个作业，最终该作业会完成等待并重新获得CPU。只要有一个任务可以执行，CPU就不会空闲。

### 分时操作系统

- 分时系统（time sharing）（多任务 multitasking）是多道程序设计的自然延伸。

1. 分时系统要求计算机系统是可交互的（interactive），以便用户与系统直接通信。由于分时系统的CPU切换作业的切换频率很高，用户可以在程序运行时与其交互。
2. 分时操作系统允许许多用户同时共享一台计算机。由于分时系统的每个动作或命令往往较短，因而每个用户只需要少量的CPU时间（时间片）。
3. 分时操作系统采用CPU调度和多道程序设计，为每个用户提供一小部分的分时计算机资源。每个用户至少有一个程序在内存中。当进程（process，加载到内存并执行的程序）执行时，其通常在执行较短一段时间后，要么完成，要么需要进行I/O操作（可交互）。在用户进行交互输入时，操作系统为了不让CPU空闲，会将CPU切换到其他用户程序。

### 实时操作系统

### 网络操作系统

### 分布式操作系统

- 分布式操作系统是由多台计算机组成并满足下列条件的系统：

1. 系统中任意两台计算机通过通信方式交换信息；
2. 系统中的每条计算机都具有同等的地位；
3. 每台计算机上的资源为所有用户共享；
4. 系统中的任意台计算机都可以构成一个子系统，并且还能重构；
5. 任何工作都可以分布在多台计算机上，由它们并行工作、协同完成。

## 操作系统的执行

### 双重模式与多重模式的执行

#### 用户模式和内核模式的切换（双重模式）

- 为了确保操作系统的正确运行，必须区分操作系统代码和用户代码的执行。大多数计算机系统采用硬件支持，以便区分各种执行模式。至少需要两种单独运行模式（双重模式）：用户模式（user mode）、内核模式（kernel model）（监视模式 superisor mode）（系统模式 system mode）（特权模式 privileged mode）。
- 模式位（mode bit）计算机可以通过一个模式位来表示当前模式\[内核模式（0）和用户模式（1）\]，通过模式位可区分为操作系统执行的任务和为用户执行的任务。
- 当计算机系统执行用户应用时，系统处于用户模式。当用户应用通过系统调用，请求操作系统服务时，系统必须从用户模式切换到内核模式，以满足请求。

<img src="../../pictures/操作系统-模式位.drawio.svg" width="600"/> 

- 当系统引导时，硬件从内核模式开始。操作系统接着加载，然后开始在用户模式下执行用户程序。一旦有陷阱或中断，硬件会从用户模式切换到内核模式（模式位 = 0）。因此，每当操作系统能能够控制计算机时，就处于内核模式。在将控制权交给用户程序前，系统会切换到用户模式（模式位 = 1）。

#### 特权指令

- 双重模式执行提供保护手段，以便防止操作系统和用户程序受到错误用户程序的影响。实现为：将可能引起损害的机器指令作为特权指令（privileged instruction），并且只有在内核模式下才允许执行特权指令。如果在用户模式下试图执行特权指令，那么硬件并不执行该指令，而是认为该指令非法，并将其以<b>陷阱</b>形式通知操作系统。

> 在操作系统中，CPU执行两种不同性质的程序：（1）操作系统内核程序；（2）用户自编程序（应用程序）。内核程序是应用程序的管理者，只有作为管理者的内核程序可以执行特权指令，而应用程序作为被管理者出于安全问题而不可以执行

<table>
    <tr>
        <td rowspan="2" width="15%">特权指令</td>
        <td width="85%">不允许用户直接使用的指令</td>
    </tr>
    <tr>
        <td>特权指令包括：切换到用户模式的指令、I/O控制、定时器管理、中断管理等</td>
    </tr>
    <tr>
        <td>非特权指令</td>
        <td>允许用户直接使用的指令，不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间</td>
    </tr>
</table>

- CPU的运行模式分为用户态和核心态。应用程序运行在用户态，内核程序运行在核心态。应用程序向操作系统请求服务时，通过使用访管指令，从而产生一个中断事件将操作系统切换至核心态。由用户态进入核心态，不仅状态切换，而且所用的堆栈可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈仍然是属于该进程的。

<img src="../../pictures/操作系统-处理器运行模式.drawio.svg" width="650"/> 

#### 多重模式

- 模式概念可以扩展，从而超过两个，这样CPU在设置和检测模式时，就会用到多个位。


### 中断

- 中断（interrupt）应将控制转移到合适的中断服务程序。处理该转移的直接方法是，调用一个通用程序以检查中断信息，接着，该程序回调用特定的中断处理程序。
- 中断处理程序的指针表：由于只有少量预先定义的中断，所以可以通过中断处理程序的指针表来提高处理中断的速度。通过指针表可以间接调用中断处理程序，而无需通过其他中介程序。指针表通常位于低地址内存（前100左右的位置），这些位置包含各种设备的中断处理程序的地址。这种地址的数组或中断向量（interrupt vector），对于给定的中断请求，可通过唯一的设备号来索引，进而提供设备的中断处理程序的地址。
- 中断体系结构也应保持中断指令的地址。以前的大部分设计只是简单地将中断地址保持在某个固定位置或可用设备号来索引的位置。而现代体系结构将返回地址保存在系统堆栈上。如果中断程序需要修改处理器状态，则应明确保存当前状态，并在返回之前恢复该状态。在处理完中断之后，保存的返回地址会加载到程序计数器，被中断的计算可以重新开始（就像未被中断一样）。

- 现代操作系统是靠中断驱动的软件。中断机制只有一小部分属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序，以此减少中断的处理时间。

<img src="../../pictures/操作系统-中断.drawio.svg" width="330"/> 

<table>
    <tr>
        <td width="15%" rowspan="3">中断（外中断）<br/>Interruption</td>
        <td colspan="2">来自CPU执行指令外部的事件，通常用于信息输入/输出</td>
    </tr>
    <tr>
        <td width="15%">可屏蔽中断</td>
        <td width="70%">通过INTR线发出的中断请求，通过改变屏蔽字可实现多重中断</td>
    </tr>
    <tr>
        <td>不可屏蔽中断</td>
        <td>通过NMI线发出的中断请求，通常是紧急的硬件故障</td>
    </tr>
    <tr>
        <td rowspan="4">异常（内中断）<br/>Exception</td>
        <td colspan="2">来自CPU执行指令内部的事件。异常也不能被屏蔽，一旦发生就该立即处理</td>
    </tr>
    <tr>
        <td>故障 fault</td>
        <td>通常是由指令执行引起的异常</td>
    </tr>
    <tr>
        <td>自陷 trap</td>
        <td>“事先安排”的异常事件，用于在用户态下调用操作系统内核程序</td>
    </tr>
    <tr>
        <td>终止 abort</td>
        <td>出现了使得CPU无法继续执行的硬件故障</td>
    </tr>
</table>

- 发生中断或异常时，运行用户态的CPU会立即进入核心态，该方式通过硬件实现。中断实现了在程序未使用某种资源的情况下，将程序对该种资源的占有权释放。通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成：

1. CPU在执行用户程序的第i条指令时检查到一个异常事件、或在执行第i条指令后发现一个中断请求信号，则CPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。
2. 若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第i条指令或第i+1条指令继续执行。
3. 若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。

<img src="../../pictures/操作系统-中断与异常处理.drawio.svg" width="800"/> 

### 系统调用

- <span name="系统调用1"><a href="#系统调用2">系统调用</a></span>（system call）为用户程序提供手段，以便请求操作系统完成某些特权任务。系统调用可以有多种方式，取决于底层处理器提供的功能。系统调用通常会陷入中断向量的某个指定位置，一般可由trap指令完成，有的系统由专用syscall指令来完成系统调用。
- 当要执行系统调用时，硬件通常将它作为软件中断。

1. 控制通过中断向量转到操作系统的中断服务程序，并且模式位也设为内核模式。
2. 系统调用服务程序是操作系统的一部分。内核检查中断指令，判断发生了什么系统调用；参数表示用户程序请求何种服务。请求所需的其他信息可以通过寄存器、堆栈或内存（内存指针也可通过寄存器传递）来传递。
3. 内核首先验证参数是否正确和合法，然后执行请求，最后控制返回到系统调用之后的指令。

- 系统调用按功能分为设备管理、文件管理、进程控制、进程通信、内存管理。
- 系统调用的处理需要由操作系统内核程序负责完成，运行在核心态。用户程序可通过陷入指令（访管指令，trap指令）来发起系统调用，请求操作系统提供服务。即通过访管指令来实现CPU状态从用户态切换到核心态；并在处理完成后，操作系统内核程序将CPU的使用权还给用户程序，即CPU状态从核心态切换到用户态。目的是，用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以保证系统的稳定性和安全性。

<img src="../../pictures/操作系统-系统调用.drawio.svg" width="470"/>

### 定时器

- 在计算机的各种部件中，时钟是最关键的设备。

1. 时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。
2. 操作系统通过时钟中断的管理，实现进程间的切换。

- 定时器（timer）：操作系统应该维持控制CPU，防止用户陷入死循环，或不调用系统服务并且不将控制返给操作系统。定时器可设置为在指定周期后中断计算机。指定周期可以是固定的或可变的。
- 可变定时器（variable timer）一般通过一个固定速率的时钟和计数器来实现。操作系统设置计数器，每次时钟滴答，计数器都要递减。当计数器的值为0时，就会产生中断。

1. 在将控制交给用户之前，操作系统确保定时器已设置好以便产生中断。当定时器中断时，控制自动转到操作系统，而操作系统可以将中断作为致命错误来处理，也可以给用户程序更多时间。（修改定时器的指令是特权的）
2. 定时器可以防止用户程序运行过长。一种简单的方法是，采用程序允许执行的时间来初始化计数器，定时器每隔一段时间（`允许执行的时间/计数器的值`）产生一次中断，计数器相应减1。只要计数器的值为正，控制就返回到用户程序。当计数器的值为负时（超时），操作系统就会中止程序执行。

## 进程管理

1. 进程（process）是执行的程序，但程序本身不是进程。程序是个被动实体（passive entity），而进程是个主动实体（active entity）。
2. 单线程进程只有一个程序计数器（PC，program counter），其指定了下一个所要执行的指令，这样一个进程的执行应该是顺序的。CPU只能一个接着一个执行进程的指令，直至进程完成。而多线程进程有多个程序计数器，每一个程序计数器指向下一个给定线程需要指向的指令。
3. 在任何时候，每个进程最多只能执行一条指令。
4. 尽管两个进程可能与同一个程序相关联，但这两个进程都有各种的执行顺序。
5. 进程是系统系统的工作单元，系统由多个进程组成（操作系统进程、用户进程）。所有这些进程都会并发执行。

- 操作系统负责进程管理的以下活动：

1. 在CPU上调度进程和线程
2. 创建和删除用户进程和系统进程
3. 挂起和重启进程
4. 提供进程同步机制
5. 提供进程通信机制

## 内存管理

1. 内存是现代计算机系统的核心。内存是个大的字节数组，每个字节都有地址。
2. 内存是个快速访问的数据仓库，并为CPU和I/O设备所共享。
3. 内存一般是CPU所能直接寻址和访问的、唯一的、大容量的存储器。如果CPU需要处理磁盘数据，那么这些数据必须首先通过CPU产生的I/O调用传到内存；如果CPU需要处理执行指令，那么这些指令必须在内存中。冯·诺依曼架构的中央处理器在获取指令周期时，从内存读取指令；而在获取数据周期时，对内存数据进行读写。

- 如果一个程序需要执行，那么它必须映射到绝对地址，并且加载到内存。随着程序执行，进程可以通过产生绝对地址来访问内存的程序指令和数据。最后，程序终止，它的内存空间得以释放，使得后面的程序可以加载并得以执行。

- 为改善CPU利用率和用户的计算机响应速度，通用计算机应在内存中保留多个程序，也就需要内存管理。内存管理的方案众多，主要需要考虑系统的硬件设计。操作系统负责内存管理的以下活动：

1. 记录内存的哪部分在被使用以及被谁使用。
2. 决定哪些进程（或其部分）会调入或调出内存。
3. 根据需要分配和释放内存空间。

## 存储管理

### 文件系统管理

- 文件（file）：操作系统提供信息存储的统一逻辑视图——文件，文件可组织成目录。存储系统对存储设备的物理属性进行了抽象，并定义了逻辑存储单元（文件）。操作系统映射文件到物理媒介，并通过存储设备来访问文件。
- 操作系统负责文件管理的以下活动：

1. 创建和删除文件
2. 创建和删除目录，以便组织文件
3. 提供文件和目录的操作界面
4. 映射文件到外存
5. 备份文件到稳定的（非易失的）存储介质

### 大容量存储器管理

- 由于内存太小而不能容纳所有的数据和程序，且为易失性存储介质，所以，计算机系统应该提供外存（辅存）以备份内存。
- 大多数现代计算机系统采用硬盘作为主要在线存储介质，来存储程序和数据。大多数程序（编译程序、汇编程序、字处理器、编辑器、格式化程序等）都存储在硬盘，执行时才调入内存，这些程序在执行时将硬盘作为处理的起源和终点。
- 操作系统负责硬盘管理的以下活动：

1. 空闲空间管理
2. 存储空间分配
3. 硬盘调度

- 操作系统的功能可以包括：

1. 安装和卸载设备媒介
2. 为进程互斥使用而分配和释放设备
3. 将数据从二级存储移动到三级存储（teriary storage），三级存储包括磁盘驱动器及其磁带、CD/DVD驱动器及其光盘等

### 高速缓存

- 高速缓存（caching，缓存）的[工作原理](./Memory.md#Cache)。
- 此外，可编程的内存寄存器（如，索引寄存器）为内存提供高速缓存。程序员（或编译程序）通过寄存器分配与寄存器替换的算法，决定哪些信息应存在寄存器中而哪些应存在内存中。
- 有的高速缓存完全通过硬件实现，大多数系统在存储层次结构中有一个或多个高速缓冲。但是，完全使用硬件实现的高速缓冲不受操作系统控制。
- 存储层次之间的信息移动可以是显式的，也可以是隐式的，具体取决于硬件设计和操作系统的控制软件。例如，高速缓存到CPU或寄存器的数据传递通常通过硬件完成，无需操作系统干预；而磁盘到内存的数据传递通常通过操作系统控制。
- 永久驻留在外层上的文件系统的数据，会位于存储层次的多个层次上。并且，在层次存储结构中，同一数据可能出现在存储系统的不同层次上。对于正在读写的数据，只有数据的新值从最后修改的部件（如，硬件寄存器）写到外存（如，磁盘）时，数据的值才会保存一致。
- 高速缓存一致性（cache coherence）：对于多处理器环境，由于多个CPU可以并行执行，应确保位于一个高速缓存的数据值的更新立刻反应到所有其他该数据所在高速缓存。通常这是通过硬件处理的。

### I/O系统

- 操作系统的目的之一是为用户隐藏具体硬件设备的特性。I/O子系统（I/O subsystem）为操作系统本身隐藏了I/O设备的特性，其包括以下组件：

1. 包括缓冲、高速缓存、假脱机的内存管理组件
2. 设备驱动器的通用接口
3. 特定硬件设备的驱动程序，只有驱动程序才能知道控制设备的特性

## 保护和安全

<table>
    <tr>
        <td width="20%">保护（protection）</td>
        <td width="80%">保护是一种用于控制进程或用户访问计算机系统的资源的机制，必须提供手段，以便指定控制和实施控制</td>
    </tr>
    <tr>
        <td>安全（security）</td>
        <td>防止系统不受外部或内部的攻击是安全的工作</td>
    </tr>
</table>

<table>
    <tr>
        <td rowspan="2" width="15%">用户标识<br/>User ID，UID</td>
        <td width="85%">（安全ID、SID，Secure ID）保护和安全要求系统能够区分用户，大多数的操作系统采用一个列表，以便维护用户名称机器关联用户标识。当该UID需要为用户可读时，就会通过用户名称列表而转换为用户名称</td>
    </tr>
    <tr>
        <td>UID对每个用户是唯一的，当一个用户登录到系统时，认证阶段确定用户的合适UID。之后，该UID与所有该用户的进程和线程相关联</td>
    </tr>
    <tr>
        <td rowspan="3">组标识<br/>Group ID，GID</td>
        <td>有些环境希望区分用户集合而非单个用户，于是需要定义一个组名称以及属于该组的用户集。组功能的实现可以采用一个系统级的列表，以维护组名称和组标识</td>
    </tr>
    <tr>
        <td>一个用户可以属于一个或多个组，取决于操作系统的设计</td>
    </tr>
    <tr>
        <td>用户的组ID也包含在每个相关的进程和线程中</td>
    </tr>
    <tr>
        <td>升级特权<br/>escalate privilege</td>
        <td>用户有时需要升级特权来获得某个活动的额外许可。操作系统提供多种方法来允许升级特权，如Unix系统的有效UID（effective UID）</td>
    </tr>
</table>

## 内核数据结构

## 计算环境

### <span name="云计算">云计算</span>

- 云计算（cloud computing）指通过计算机网络（多指因特网）形成的计算能力极强的系统，可存储、集合相关资源并可按需配置，向用户提供个性化服务。云计算（网络计算）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。（“云”实质上就是一个网络）
- 云计算（Cloud Computing）是一种商业计算模型，通过集中所有的计算机资源，采用硬件虚拟化技术，为使用者提供资源，将计算任务分布在大量计算机构成的资源池中，使各种应用系统能够根据需要获取计算力、存储空间和信息服务。

<img src="../../pictures/操作系统-云计算.drawio.svg" width="500"/> 

<table>
    <tr>
        <th width="15%">类型</th>
        <th width="85%">描述</th>
    </tr>
    <tr>
        <td>公云</td>
        <td>（public cloud），只要为服务付费就能使用的云</td>
    </tr>
    <tr>
        <td>私云</td>
        <td>（private cloud），公司自己使用自己的云</td>
    </tr>
    <tr>
        <td>混合云</td>
        <td>（hybrid cloud），公云和私云混合的云</td>
    </tr>
    <tr>
        <td>软件即服务</td>
        <td>（Software as a Service，SaaS），可通过Internet使用的应用程序（如，文字处理程序或电子表格程序）</td>
    </tr>
    <tr>
        <td>平台即服务</td>
        <td>（Platform as a Service，PaaS），可通过Internet而为应用程序（如，数据库服务器）使用的软件堆栈</td>
    </tr>
    <tr>
        <td>基础设施即服务</td>
        <td>（Infrastructure as a Service，IaaS），可通过Internet使用的服务器或存储（如，用于生产数据备份的存储）</td>
    </tr>
</table>

# 操作系统结构

## 操作系统的服务

<img src="../../pictures/操作系统-操作系统的服务.drawio.svg" width="650"/> 

-  操作系统有一组服务，用于提供用户功能：

<table>
    <tr>
        <td rowspan="4" width="15%"><span name="用户界面1"><a href="#用户界面2">用户界面</a></span></td>
        <td colspan="2">几乎所有操作系统都有用户界面（User Interface，UI），有的系统提供了以下三种界面或其中几个</td>
    </tr>
    <tr>
        <td width="15%">命令行界面 CLI</td>
        <td width="70%">命令行界面（Command-Line Interface，CLI）采用文本命令，并用某一方法输入</td>
    </tr>
    <tr>
        <td>批处理界面</td>
        <td>在批处理界面（batch interface）中命令及控制这些命令的指令可以编成文件以便执行</td>
    </tr>
    <tr>
        <td>图形用户界面 GUI</td>
        <td>图形用户界面（Graphical User Interface，GUI）是一种视窗系统，具有定位设备控制I/O、通过菜单选择、通过键盘输入文本和选择等。</td>
    </tr>
    <tr>
        <td>程序执行</td>
        <td colspan="2">系统应能加载到内存，并加以运行。程序应能结束执行，包括正常或不正常（并给出错误）</td>
    </tr>
    <tr>
        <td>I/O操作</td>
        <td colspan="2">程序运行可能需要I/O，这些I/O可能涉及文件或设备。对于特定设备，可能需要特殊功能。为了效率和保护，用户通常不应直接控制I/O设备。因此，操作系统必须提供手段以便执行I/O</td>
    </tr>
    <tr>
        <td>文件系统操作</td>
        <td colspan="2">程序需要读写文件和目录，也需要根据文件名称来创建和删除文件，搜索某个给定文件，列出文件信息等。有些操作系统具有权限管理，根据文件所有者允许或拒绝对文件和目录的访问。许多操作系统提供多种文件系统，有的允许个人选择，有的提供特殊功能或性能</td>
    </tr>
    <tr>
        <td rowspan="2">通信</td>
        <td colspan="2">在许多情况下，一个进程需要与另一个进程交换信息。这种通信可能发生在运行于同一台计算机的两个进程之间，也可能发生在运行于通过网络连接的不同计算机的进程之间</td>
    </tr>
    <tr>
        <td colspan="2">通信实现可以通过共享内存（shared memory）（两个或多个进程读写共享内存区域)，也可以通过消息交换（message passing）（符合预先定义格式的信息分组可以通过操作系统在进程之间移动）</td>
    </tr>
    <tr>
        <td rowspan="3">错误检测</td>
        <td colspan="2">操作系统需要不断检测错误和更正错误。错误可能源于：CPU或内存硬件（如内存错误或电源故障）、I/O设备（如磁盘奇偶检验出错、网络连接故障、打印机缺纸）、用户程序（如算术溢出、企图非法访问内存地址、占用CPU时间太长）等。</td>
    </tr>
    <tr>
        <td colspan="2">对于每类错误，操作系统必须采取适当动作，确保计算的正确和一致。有时，操作只能停机；也有时，操作系统可以终结出错进程，或者将出错码返给进程以便进程检测或纠正</td>
    </tr>
    <tr>
        <td colspan="2">另外，还有一组操作系统服务，不是为了帮助用户而是为了确保系统本身运行高效。多用户系统通过共享计算机资源可以提高效率</td>
    </tr>
    <tr>
        <td>资源分配</td>
        <td colspan="2">当多个用户或多个作业同时运行时，每个都应分配资源，而操作系统管理许多不同类型的资源；有的资源（如CPU周期、内存和文件存储）可能要有特殊的分配代码，而其他资源（如I/O设备）可能只需通用的请求和释放代码。例如，为了更好地使用CPU，操作系统需要采用CPU调度算法，以便考虑CPU的速度、要执行的作业、可用寄存器的数量和其他因素。还有一些其他程序可以分配打印机、USB存储器和其他外设</td>
    </tr>
    <tr>
        <td>记账</td>
        <td colspan="2">我们需要记录用户使用资源的类型和数量。这种记录可以用于记账（以便向用户收费），或统计使用量。统计使用量对研究人员很有用，可用于重新配置系统以提高计算服务</td>
    </tr>
    <tr>
        <td rowspan="3">保护与安全</td>
        <td colspan="2">对于保存在多用户或联网的计算机系统的信息，用户可能需要控制信息使用。当多个独立进程并发执行时，一个进程不应干预其他进程或操作系统本身。保护应该确保可以控制系统资源的所有访问</td>
    </tr>
    <tr>
        <td colspan="2">系统安全而不受外界侵犯，则要求用户向系统认证自己（利用密码)，以获取系统资源的访问权限。安全还包括保护外部I/O设备（如网络适配器）不受非法访问，并记录所有非法的闯入企图</td>
    </tr>
    <tr>
        <td colspan="2">如果一个系统需要保护和安全，那么系统的所有部分都要预防。一条链的强度与其最弱的环节一样</td>
    </tr>
</table>

## 用户与操作系统的界面

- <span name="用户界面2"><a href="#用户界面1">用户界面</a></span>可随系统的不同甚至系统用户的不同而不同，其通常不属于系统内核。设计友好并有用的用户界面<b>并不是</b>操作系统的直接功能。

### 命令解释程序

- 有的操作系统内核包括命令解释程序，有的操作系统（UNIX、Windows）将命令解释程序当作一个特殊程序（shell，外壳），当一个任务开始或（交互系统）用户首次登录时，该程序就会运行。

- 命令解释程序的主要功能是获取并执行用户指定的下一条命令，其提供了许多命令来操作文件（创建、删除、列出、打印、复制、执行等）。这些命令的实现通常有以下两种方法：

1. 命令解释程序本身包含代码以执行命令。对此方法，所能提供命令的数量决定命令解释程序的大小，因为每个命令都要有实现代码。例如，让命令解释程序跳转到相应的代码段，以设置相应的参数并执行相应系统调用。
2. 通过系统程序实现大多数的命令。对此方法，命令解释程序不必理解命令，而只要通过命令确定一个文件，以加载到内存并执行。程序员可以通过创建合适名称的新文件，轻松地向系统增加新命令。例如，Unix系统就采用这种方法。

### 图形用户界面

- 图形用户界面（GUI）利用桌面（desktop）概念，即采用基于鼠标的视窗和菜单系统。用户移动鼠标，定位指针到桌面上的图标（icon），这些图标代表程序、文件、目录和系统功能。

## 系统调用

### 系统调用概述

- <span name="系统调用2"><a href="#系统调用1">系统调用</a></span>（system call）提供操作系统服务接口，通常以C或C++编写这些系统调用命令，对于某些底层任务，可能应以汇编语言指令编写。

1. 通常，系统每秒执行成千上万的系统调用。
2. 系统调用因所用计算机的不同而不同，每个操作系统对于每个系统调用都有自己的名称。通常，除了所需的系统调用外，还要提供其他信息，这些信息的具体类型和数量根据特定操作系统和调用而有所不同。

- API（应用编程接口，Application Programming Interface）：应用程序开发人员通常根据API来设计程序。以下为三组常用的API：Windows API、POSIX API（包括几乎所有版本的UNIX、Linux和Mac OS X）、Java API（JVM）。

1. API为方便应用程序员规定了一组函数，包括每个函数的输入参数和返回值。
2. 编程人员通过操作系统提供的函数库来调用API。例如，对于运行在UNIX和Linux上的C语言编写的程序需要用到<code>libc</code>库。
3. 在后台，API函数通常为应用程序员调用实际的系统调用。

- 系统调用接口（system-call interface）：对大多数的程序设计语言，运行时支持系统（由编译器直接提供的函数库）提供了系统调用接口，以链接到操作系统的系统调用。系统调用接口截取 API函数的调用，并调用操作系统中的所需系统调用。通常，每个系统调用都有一个相关数字，而系统调用接口会根据这些数字来建立一个索引列表。系统调用接口就可调用操作系统内核中的所需系统调用，并返回系统调用状态与任何返回值。
- 调用者无需知道如何实现系统调用，而只需遵循API，并知道在调用系统调用后操作系统做了什么。因此，通过API，操作系统接口的大多数细节可隐藏起来，且可由运行时库来管理。

<img src="../../pictures/操作系统-API-系统调用接口和操作系统之间的关系.drawio.svg" width="500"/> 

<table>
    <caption>向操作系统传递参数的三种常用方法</caption>
    <tr>
        <td width="20%">通过寄存器来传递参数</td>
        <td width="80%">最简单，但参数的数量和长度受到寄存器的限制</td>
    </tr>
    <tr>
        <td>将参数存在内存的块或表中</td>
        <td>通常将需要的一些参数存在内存的块或表中，而块或表的地质通过寄存器来传递（Linux和Solaris采用）。不限制传递参数的数量或长度。</td>
    </tr>
    <tr>
        <td>通过程序将参数存到堆栈中</td>
        <td>参数也可通过程序放在或压入（pushed）到堆栈（stack)，并通过操作系统弹出（popped）。不限制传递参数的数量或长度。</td>
    </tr>
</table>

<img src="../../pictures/操作系统-通过表来传递参数.drawio.svg" width="640"/> 

### 系统调用的类型

<table>
    <caption>系统调用的六大类型</caption>
    <tr>
        <th width="30%" rowspan="6">进程控制<br/>process control</th>
        <td width="70%">结束、中止</td>
    </tr>
    <tr>
        <td>创建进程、终止进程</td>
    </tr>
    <tr>
        <td>获取进程属性、设置进程属性</td>
    </tr>
    <tr>
        <td>等待时间</td>
    </tr>
    <tr>
        <td>等待事件、信号事件</td>
    </tr>
    <tr>
        <td>分配和释放内存</td>
    </tr>
    <tr>
        <th rowspan="4">文件管理<br/>file manipulation</th>
        <td>创建文件、删除文件</td>
    </tr>
    <tr>
        <td>打开、关闭</td>
    </tr>
    <tr>
        <td>读、写、重新定位</td>
    </tr>
    <tr>
        <td>获取文件属性、设置文件属性</td>
    </tr>
    <tr>
        <th rowspan="4">设备管理<br/>device manipulation</th>
        <td>请求设备、释放设备</td>
    </tr>
    <tr>
        <td>读、写、重新定位</td>
    </tr>
    <tr>
        <td>获取设备属性、设置设备属性</td>
    </tr>
    <tr>
        <td>逻辑附加或分离设备</td>
    </tr>
    <tr>
        <th rowspan="4">信息维护<br/>information maintenance</th>
        <td>获取时间或日期、设置时间或日期</td>
    </tr>
    <tr>
        <td>获取系统数据、设置系统数据</td>
    </tr>
    <tr>
        <td>获取进程、文件或设备属性</td>
    </tr>
    <tr>
        <td>设置进程、文件或设备属性</td>
    </tr>
    <tr>
        <th rowspan="4">通信<br/>communication</th>
        <td>创建、删除通信连接</td>
    </tr>
    <tr>
        <td>发送、接收消息</td>
    </tr>
    <tr>
        <td>传送状态信息</td>
    </tr>
    <tr>
        <td>附加或分离远程设备</td>
    </tr>
    <tr>
        <th>保护<br/>protection</th>
        <td></td>
    </tr>
</table>
#### 进程控制

- 执行程序应能正常（<code>end()</code>）或异常（<code>abort()</code>）停止执行。

1. 如果一个系统调用异常停止当前执行的程序，或者程序运行遇到问题并引起错误陷阱，那么有时会转储内存到磁盘，并生成错误信息。
2. 内存信息转储到磁盘后，可用调试器（debugger）（调试器是系统程序）来确定问题原因。
3. 无论是正常情况下还是异常情况，操作系统都应该将控制转到调用命令解释程序。命令解释程序接着读入下一个命令。
   - 对于交互系统，命令解释程序只是简单读入下一个命令，而假定用户会采取合适命令以处理错误。
   - 对于GUI系统，弹出窗口可用于提醒用户出错，并请求指引。
   - 对于批处理系统，命令解释程序通常会终止整个作业，并继续下一个作业。 

- 错误级别：当出现错误时，有的系统可能运行特殊的恢复操作。如果程序发现输入有错并且想要异常终止，那么可能需要定义错误级别。错误越严重，错误参数的级别也越高。通过将正常终止的错误级别定义为0，可以把正常和异常终止放在一起处理。命令解释程序或之后的程序可以根据错误级别来自动确定下一个动作。
- 执行一个程序的进程或作业可能需要加载（<code>load()</code>）和执行（<code>execute()</code>）另一个程序，也就是允许命令解释程序来执行一个程序。
- <code>create_process()</code>或<code>submit_job()</code>如果新程序终止时返回到现有程序，那么必须保存现有程序的内存映像。实际上创建了一个机制，以便一个程序调用来一个程序。如果两个程序并发执行，那么也就创建了一个新作业或进程，以便多道执行。
- <code>get_process_attributes()</code>和<code>set_procesc_attributes()</code>如果创建了一个新的作业或进程、一组作业或进程，那么应该能够控制他们的执行。且这种控制要能判定和重置进程或作业的属性，包括作业的优先级、最大运行执行时间等。
- <code>terminate_process()</code>如果发现创建的进程或作业不正确或不再需要，那么也要能终止它。
- 创建新的作业或进程后，可能要等待其执行完成，也可能要等待一段时间（<code>wait_time()</code>），或者可能要等待某个事件的出现（<code>wait_event()</code>）。当事件出现时，作业或进程就会响应（<code>signal_event()</code>）。
- 通常，两个或多个进程会共享数据。为了确保共享数据的完整性，操作系统通常提供系统调用（<code>acquire_lock()</code>和<code>release_lock()</code>），以允许一个进程锁定（lock）共享数据。在解锁之前，其他进程不能访问该数据。

#### 文件管理

## 操作系统的结构

### 简单结构

-  MS-DOS系统利用最小空间而提供最多功能，但并没有被仔细地划分成模块，并没有很好地区分功能的接口和层次。MS-DOS易受错误（恶意）程序的伤害，应用程序出错会导致整个系统崩溃。

<img src="../../pictures/操作系统-MS-DOS层次结构.drawio.svg" width="350"/> 

- 最初的UNIX操作系统采用有限结构（单片结构），由两个独立的部分组成：内核和系统程序。这种单片结构使得UNIX难以实现和设计，但系统调用和内核通信的开销非常小，因此，UNIX、Linux、Windows操作系统仍然采用这种简单的单片结构。

<img src="../../pictures/操作系统-传统的UNIX系统结构.drawio.svg" width="600"/> 

### 分层法

- 分层法（layered approach）将操作系统分为若干层，最底层（层 0）为硬件，最高层（层 N）为用户接口。

<img src="../../pictures/操作系统-操作系统结构-分层法.drawio.svg" width="220"/> 

1. 操作系统层采用抽象对象，以包括数据和操纵这些数据的操作。例如，层M包括数据结构和一组可为更高层所调研的程序集，而层M可调用更低层的操作。
2. 分层法简化了构造和调试，每层只能调用其底下一层的功能和服务（<b>单向依赖</b>）。第一层（层0）可先调试而无需考虑系统其他部分（因为在定义上只使用了基本硬件），一旦第一层调试后，就认为它能正确运行，之后依次调试第二层……如果在调试某层时发现错误，那么错误应该在这一层，而不是其低层（已经调试好）。
3. 每层的实现都只是利用更低层所提供的操作，且只需知道这些操作做了什么，而并不需要知道这些操作是如何实现的。因此，每层要为更高层隐藏一定的数据结构、操作和硬件。

- 分层法的难点与缺陷：

1. 分层法的主要难点在于合理定义各层。由于每层只能利用更低层的功能，因此有必要仔细规划。
2. 每层都为系统调用增加额外开销，与其他方法相比效率稍差。在每一层，参数可能会被修改，数据可能需要传递等。

### 微内核

- 微内核（microkernel）技术对内核进行模块化，从内核中删除所有不必要的部件，而将这些部件当作系统级和用户级的程序来实现，从而使得内核较小。

> Mach操作系统最早使用微内核

- 通常，微内核会提供最小的进程与内存管理以及通信功能，如何选择并非定论。

<img src="../../pictures/操作系统- 典型的微内核架构.drawio.svg" width="500"/> 

1. 微内核的主要功能是，为客户端和运行在用户空间中的各种服务提供通信。通信是通过<b>消息传递（message passing）</b>来提供的。客户程序和服务器不会直接交互，而是通过微内核的消息传递来间接通信。
2. 微内核便于扩展操作系统。所有新服务可在用户空间内增加，因而并不需要修改内核；当内核确实需要修改时，所做修改也会很小。很容易从一种硬件平台移植到另一种硬件平台
3. 微内核也提供了更好的安全性和可靠性。大多数服务是作为用户进程而不是作为内核进程来运行的。如果一个服务出错，那么操作系统的其他部分并不受影响。
4. 但是由于增加的系统功能的开销，微内核的性能会受损。

### 模块

- 可加载的内核模块（loadable kernel module）：内核有一组核心组件，无论在启动或运行时，内核都可通过模块链入额外服务。

> 这种类型的设计常见于现代UNIX（Solaris、Linux和Mac OSX）以及Windows的实现。

1. 内核提供核心服务，而其他服务可在内核运行时动态实现。<b>动态链接服务</b>优于直接添加新功能到内核。
2. 每个内核部分都有已定义的、受保护的接口。比分层系统更加灵活，任何模块都可以调用任何其他模块。
3. 主模块只有核心功能，并知道如何加载模块以及如何让模块进行通信。但比微内核更为有效，因为模块无需调用消息传递来进行通信。

### 混合系统

## 操作系统的调试

- 广义而言，调试（debugging）是查找和更正系统（包括硬件和软件）错误，也包括性能优化（performance turning）。

### 性能优化

- 性能优化是通常解决处理瓶颈（bottleneck）而改善性能。
- 跟踪列表（trace list）：有些操作系统通过生成系统行为跟踪列表来实现计算和显示系统行为的度量。所有相关事件及其时间和其他重要参数，都记录并写入到文件。之后，可通过分析程序来处理日志文件，以确定系统性能并识别瓶颈与低效处。

## 操作系统的生成

- 系统生成（SYStem GENeration，SYSGEN）：对于某个特定的计算机场所，配置和生成对应的操作系统。
- 操作系统的发行通常采用磁盘、CD-ROM、DVD-ROM或“ISO”镜像（采用CD-ROM或DVD\_ROM格式的文件）。SYSGEN程序从给定文件读取或询问系统操作员有关硬件系统的特定配置，或直接检测硬件以决定有什么部件。需要的信息如下：

1. 使用什么CPU？什么安装选项（扩展指令集、浮点运算等）？对于多CPU系统，可能需要描述每个CPU。
2. 启动盘如何格式化？分成多少个分区？每个分区的内容是什么？
3. 有多少可用内存？有些系统可以求出这个值：通过对内存位置一个个地引用，直到出现非法地址，这个过程可得到最后的合法地址及可用内存的数量。
4. 有什么可用设备？系统要知道如何访问每个设备（设备号）、设备中断号、设备类型与型号及任何特殊设备的特性。
5. 需要什么操作系统的选项，或者使用什么参数值？这些选项或参数包括：应使用多大的缓冲区、所需CPU调度算法的类型、所支持进程的最大数量等。

- 在获取以上信息后，可以有多种使用方法，这些方法的主要差别是：生成系统的大小和通用性、因硬件配置改变所需修改的方便性。

<table>
    <tr>
        <td width="15%">完全定制</td>
        <td width="85%">系统管理员可以修改操作系统源代码的副本，接着重新编译操作系统。数据声明、初始化、常量和条件编译，可以生成专门用于所述系统的操作系统的目标代码的输出</td>
    </tr>
    <tr>
        <td>定制稍微少些</td>
        <td>系统描述可用来创建表，并从预先已编译的库中选择模块，这些模块链接起来，可以生成操作系统。虽然允许库包括所有支持I/O设备的驱动程序，但是只有所需的才能链到操作系统。由于没有重新编译，所以系统生成较快，但是生成的系统可能过于通用</td>
    </tr>
    <tr>
        <td>几乎无定制</td>
        <td>可以构造完全由表驱动的系统。所有代码都是系统的组成部分，选择发生在执行而非编译或链接时。系统的生成只是创建适当的表，以描述系统。</td>
    </tr>
</table>

## 系统引导

- 系统引导（booting）：大多数计算机系统都有一小块代码，称之为引导程序（bootstrap program）或引导加载程序（bootstrap loader），这段代码能够定位内核，并加载到内存以开始执行。有的计算机系统（如PC）采用两个步骤：一个简单引导程序从磁盘上调入一个更复杂的引导程序，而后者再加载内核。
- 引导程序可以完成一系列任务。通常会有一个任务需要运行诊断程序来确定机器状态。如果通过诊断，则程序可以继续启动步骤，引导程序也能初始化系统的所有方面（从CPU寄存器到设备控制器以及内存内容）。最终，启动操作系统。
- 对于小型操作系统（如，手机、平板电脑和游戏控制器）、简单的支持硬件和耐用的操作，将整个操作系统存储在ROM中是适合的。而为了解决ROM不可写的问题，有些系统采用EPRM来代替。
- 所有形式的ROM都是固件（firmware)，因为它的特性介于硬件与软件之间。在固件中执行代码比在RAM中慢。因此，有些系统将操作系统保存在固件中，而在要执行时将其复制到RAM中，以便执行更快。
- 对大型操作系统（包括大多数的通用操作系统，如Windows、Mac OS X和UNIX）或经常改变的系统，引导程序存放在固件上，而操作系统存放在磁盘上。

1. 在这种情况下，引导程序会先进行诊断，然后从磁盘固定位置（如第0块）读取整块信息到内存，最后执行引导块（boot block）的代码。
2. 存储在引导块的程序可能足以加载整个操作系统到内存，并开始执行。
3. 更典型的情况是，存储在引导块的程序只是简单的代码（因为它要存放在单一的磁盘块上)，并且只知道磁盘的地址以及引导程序其余部分的长度。（GRUB是一个开源的例子，用于引导Linux系统）

- 引导盘（boot disk）或系统盘（system disk）是具有引导分区的磁盘。所有磁盘的引导程序和操作系统本身，通过向磁盘写入新的版本，就可以很容易地改变。
- 整个引导程序在加载后，就可遍历文件系统以寻找操作系统内核，将其加载到内存中，并开始执行。此时，系统才真正是在运行。