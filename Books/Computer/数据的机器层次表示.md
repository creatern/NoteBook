# 无符号数、有符号数

- 无符号数：寄存器的位数反映表示范围。
- 有符号数：分为数值和符号两部分，最高位表示符号。

# 机器数

- 真值：带符号（+、-）的数。
- 机器数：符号数字化（用0、1表示符号）的数，按机器的字长补足位数（补0）。

$$
2^{4} = 10000 \\
2^{-4} = 0.0001
$$

## 原码

- 最高位为符号位：0正数、1负数。

$$
[X]_原 = 
\begin{cases}
X & 0 \le X < 1 \\
1-X = 1+|x| & -1 < X \le 0
\end{cases} 
\tag{纯小数}
$$

$$
[X]_原 = 
\begin{cases}
X & 0 \le X < 2^n \\
2^n - X = 2^n + |X| & -2^n < X \le 0
\end{cases} 
\tag{纯整数}
$$

- 真值0有两种表示：（5位寄存器）

$$
[+0]_原 = 00000\\
[-0]_原 = 10000
$$

## 反码

- 符号：最高位，不进行取反。
- 数值：
  - 正数：与原码相同
  - 负数：对原码的数值取反。

$$
[X]_反 = 
\begin{cases}
X & 0 \le X < 1 \\
(2 - 2^{-n}) + X & -1 < X \le 0
\end{cases}
\space (mod \space 2-2^{-n})
\tag{纯小数}
$$

$$
[X]_反 = 
\begin{cases}
X & 0 \le X < 2^n \\
(2^{n+1} - 1) + X & -2^n < X \le 0
\end{cases}
\space (mod \space 2{n+1} - 1)
\tag{纯整数}
$$

- 真值0的两种表示：（5位）

$$
\begin{matrix}
[+0]_反 = 00000 \\
[-0]_反 = 11111
\end{matrix}
$$

## 补码

**补数** 补码的原理：使负数通过与其同余的整数来表示。

- 模 M：计算器的容量。
- 同余：整数A和B在以M为模时相等：A = B (mod M).。
  - 5 = 17 (mode 12)、-2 = 10 (mod 12)。
- 同余的两个数具有互补关系：通过与负数等价的正数来表示。
  - 9 - 5 = 9 + (-5) = 9 + (12 - 5) = 4 (mod 12)。

$$
[X]_补 = 
\begin{cases}
X & 0 \le X < 1 \\
2 + X = 2 - |X| & -1 \le X < 0
\end{cases} 
\space (mod \space 2)
\tag{纯小数}
$$

$$
[X]_补 = 
\begin{cases}
X & 0 \le X < 2^n \\
2^{n+1} + X = 2^{n+1} - |X| & -2^n \le X < 0
\end{cases}
\space (mod \space 2^{n+1})
\tag{纯整数}
$$

- 真值0只有一种表示：（5位）

$$
[+0]_补 = [-0]_补 = 00000
$$

**补码**

- 符号：最高位，不进行取反。
- 数值：
  - 正数：与原码相同
  - 负数：对原码的数值取反，且在最低位+1。（在反码的基础上+1）

**补码的优点**

1. 简化计算机中的加减运算：无需讨论符号，只需将它们的补码相加，然后将和的补码转换为原码即可。
2. 避免原码和反码中存在的数值范围不连续的问题：在补码中，正数和负数的范围是相连续的。
3. 有效地使用计算机内存，并且在处理负数时，与其他进制相比，可以省略接口符、标志位等特征，从而减少硬件开销。

## 移码

- 偏置值

$$
[X_移] = 偏置值 + X
$$

**移码的特点**

1. 最高位（符号位）：0负数、1正数。
2. 直观反应真值大小：
   - 移码全0：最小负数
   - 移码全1：最大正数
3. $[+0]_移 = [-0]_移 = 10000000$
4. 无符号数：移码将真值映射到正数域。
5. 同一数值的移码和补码：只有符号位相反。

## 三种机器数的转换、比较

$$
\tag{5位寄存器}
\begin{align}
&[-1101]_原 = 11101 \\
&[-1101]_补 = 10011 \\
&[-1101]_反 = 10010
\end{align}
$$

1. 对于正数，等于真值本身；对于负数不同表示。

2. 最高位都是符号位：

   - 原码：符号位和数值位分开处理。

   - 补码和反码：符号位和数值位一起参与运算。

3. 对于真值0的表示：

   - 原码、反码：两种表示。

   - 补码只有一种表示。

4. 正负数表示范围：

   - 原码、反码：正负数表示的范围相对0对称。
   - 补码：负数表示范围较正数的大，能多表示一个绝对值最大的负数： $ -2^n 或 -1 $ 。

# 定点表示、浮点表示

## 定点表示法

- 所有数据的小数点位置固定不变：
  - 定点小数（纯小数）：小数点隐含在最高有效数位之前、符号位之后。
  - 定点整数（纯整数）：小数点隐含在最低有效数位之后。
- 参加运算的数和结果都必须保证落在该定点数所能表示的数值范围，否则溢出。

### 定点小数

### 定点整数

## 浮点表示法

$$
N = M \times r^E
$$

- r：浮点数阶码的底，通常r=2，在浮点数中隐含。
- E：阶码 Exponent，纯整数（移码/补码）。浮点数的指数部分，数量级、小数点的位置。
- M：尾数 Mantissa，纯小数（原码/补码）。浮点数的小数部分，精度。

<img src="../../pictures/Snipaste_2023-05-02_17-54-49.png" width="400"/> 

## 尾数基数 r

**对浮点数的影响**

- r增大：

1. 可表示数的范围增大
2. 可表示数的个数增加
3. 数在数轴上的分布密度越稀疏
4. 可表示数的精度下降
5. 降低因尾数右移导致的运算精度损失
6. 使运算中移位的次数减少，提高运算速度

## 浮点数规格化

- 规格化：规定尾数的最高数位必须是一个有效值。
- 浮点数的表示形式不唯一：需要找到规格化浮点数。

**规格化浮点数 M的绝对值范围**

$$
\frac{1}{r} \le |M| < 1
$$

## IEEE 754 标准浮点数
