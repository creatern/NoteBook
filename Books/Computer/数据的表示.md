# 数制与编码

## 定点数的乘除运算

### 定点数的乘法运算

- 乘法运算由累加和右移操作实现，分为原码一位乘法和补码一位乘法。

#### 原码一位乘法

- 原码一位乘法的符号位和数值为分开求，乘积的符号位由两个操作数的符号位‘’异或“得到，乘积的数值位是两个数的绝对值乘积。

- 设\[X\]<sub>原</sub>=x<sub>s</sub>\.x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>、\[Y\]<sub>原</sub>=y<sub>s</sub>\.y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>，则运算规则为：

1. 被乘数和乘数均取绝对值（数值位）运算；符号位单独运算x<sub>s</sub>&oplus;y<sub>s</sub>
2. <span name="部分积">部分积</span>是乘法过程的中间结果，初始值为0。乘数的每一位y<sub>i</sub>乘以被乘数得到X\*y<sub>i</sub>，并将该结果和之前的部分积相加，得到当前的部分积。（部分积由高位部分积和低位部分积拼接而成）
3. 从乘数的最低位y<sub>n</sub>开始判断，若y<sub>n</sub>=1，则部分积加上被乘数\|x\|，然后部分积都右移一位；若y<sub>n</sub>=0，则部分积加上0，然后部分积都右移一位。
4. 重复步骤3，判断n次（右移n次，n为字长-1）。

<img src="../../pictures/计算机组成原理-原码一位乘法.drawio.svg" width="500"/> 

##### 无符号数乘法运算电路

#### 补码一位乘法（Booth算法）

- 补码一位乘法是有符号数的乘法，利用相加和相减计算补码数据的乘积。
- 设\[X\]<sub>补</sub>=x<sub>s</sub>\.x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>、\[Y\]<sub>补</sub>=y<sub>s</sub>\.y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>，则运算规则为：

1. 符号位参与运算，运算的数均为补码表示。
2. 被乘数一般取双符号位参与运算；<a href="#部分积">部分积</a>取双符号位，初始值为0；乘数取单符号位。
3. 乘数末位增设附加位y<sub>n+1</sub>，初始值为0。
4. 根据（y<sub>n</sub>, y<sub>n+1</sub>）的取值来确定操作，按补码移位规则移位。

| y<sub>n</sub>（高位） | y<sub>n+1</sub>（低位） | 操作                                  |
| --------------------- | ----------------------- | ------------------------------------- |
| 0                     | 0                       | 部分积右移一位                        |
| 0                     | 1                       | 部分积加\[x\]<sub>补</sub>，右移一位  |
| 1                     | 0                       | 部分积加\[-x\]<sub>补</sub>，右移一位 |
| 1                     | 1                       | 部分积右移一位                        |

5. 重复以上步骤n+1次，第n\+1步不再移位（共n\+1次累加、n次右移），仅根据y<sub>n</sub>和y<sub>n+1</sub>的比较结果做相应运算。

<img src="../../pictures/计算机组成原理-补码一位乘法.drawio.svg" width="550"/> 

##### 补码乘法运算电路

### 定点数的除法运算

- 除法运算可转换为“累加\-左移”（逻辑左移），分为原码除法和补码除法。

- 符号扩展将带符号的定点数转换成不同位数的表示。

1. 正数的符号扩展，符号位不变，扩展位使用0填充。
2. 原码负数的符号扩展，与正数相同。
3. 补码负数的符号扩展，原有的符号位移动至新符号位，附加位整数使用1填补，小数使用0填补。

#### 原码除法运算（不恢复余数法）

- 原码不恢复余数法（原码加减交替除法），商符和商值是分开进行的。
- 设被除数\[X\]<sub>原</sub>=x<sub>s</sub>\.x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>、\[Y\]<sub>原</sub>=y<sub>s</sub>\.y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>

1. 商符：Q<sub>s</sub>=x<sub>s</sub>&oplus;y<sub>s</sub>
2. 商值：\|Q\|=\|X\|/\|Y\|

- 求\|Q\|的不恢复余数法运算

1. 先用被除数减去除数（\|X\|-\|Y\|=\|X\|+(\-\|Y\|)=\[X\]+\[\-\|Y\|\]<sub>补</sub>），当余数为正时，商末位加上1，余数和商左移一位，再减去余数；当余数为负时，商末位加上0，余数和商左移一位，再加上余数。（包括符号位移动）
2. 第n+1步余数为负时，需要加上\|Y\|以得到第n\+1步正确的余数（余数与被除数同号）。

<img src="../../pictures/计算机组成原理-原码一位除法.drawio.svg" width="550"/> 

#### 补码除法运算（加减交替法）

- 补码一位除法，符号位和数值位一起参与运算，商符自然形成。除法第一步根据被除数和除数的符号决定加法或减法。上商的原则根据余数和除数和符号位决定。

1. 符号位参与运算，除数、被除数、商、余数使用补码表示。
2. 若被除数与除数同号，则被除数减去除数；若被除数和除数异号，则被除数加上除数。
3. 若余数与除数同号，则商上1，余数左移一位减去除数；若余数与除数异号，则商上0，余数左移一位加上除数。
4. 重复第3步n次。
5. 若对商的精度没有特殊要求，则一般采用“末位恒置1”。

<img src="../../pictures/计算机组成原理-补码一位除法.drawio.svg" width="650"/> 

##### 除法运算电路

# 浮点数

## 浮点数的表示

- 浮点数以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动，即扩大了数的范围，又保持了数的有效精度。

$$
N= (-1)^S \times M \times r^E
$$

<img src="../../pictures/Snipaste_2023-05-02_17-54-49.png" width="400"/> 

- 阶码的值反映浮点数的小数点的实际位置；阶码的位数反映浮点数的表示范围；尾数的位数反映浮点数的精度。

1. r（基数，浮点数阶码的底），通常r=2，在浮点数中隐含。r增大，可表示数的范围增大、可表示数的个数增加、数在数轴上的分布密度越稀疏、可表示数的精度下降、降低因尾数右移导致的运算精度损失、使运算中移位的次数减少，提高运算速度

2. E（阶码，Exponent），定点整数（移码/补码）。浮点数的指数部分，数量级、小数点的位置。

3. M（尾数，Mantissa），定点小数（原码/补码）。浮点数的小数部分，精度。尾数位数决定浮点数的有效数位，有效数位越多，数据的精度越高。

### 浮点数的表示范围

- 浮点数的表示范围是关于原点对称的。

1. 上溢，运算结果大于最大正数时为正上溢，小于绝对值最大负数时为负上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。
2. 下溢，运算结果在0\~最小正数之间时为正下溢，在0\~绝对值最小负数之间时为负下溢。数据下溢时，浮点数值趋于零，计算机仅将其动作机器零处理。

<img src="../../pictures/计算机组成原理-float-format.drawio.svg" width="430"/> 

## 浮点数规格化

- <span name="规格化">浮点数规格化</span>，调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。浮点数的表示形式不唯一，需要找到规格化浮点数。

1. 左规，运算结果的尾数的最高数位不是有效位时，可能需要多次左规，尾数每左移一位、阶码减1（基数为2）。
2. 右规，运算结果的尾数的有效位进到小数点前时，需要且只需一次右规，尾数右移一位、阶码加1（基数为2）。

- 规格化浮点数的尾数M的绝对值应满足 1/r &le;\|M\| &le; 1。当浮点数尾数的基数为2时，原码规格化的尾数最高位一定是1；当基数为4时，原码规格化形式的尾数最高两位不全为0。

## IEEE 754 标准

<img src="../../pictures/计算机组成原理-IEEE754标准浮点数的格式.drawio.svg" width="450"/> 

- IEE754标准规定常用的浮点数格式有短浮点数（单精度、float型）、长浮点数（双精度、double型）、临时浮点数，其基数隐含为2。IEEE754标准的浮点数（除临时浮点数之外）是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。
- 对于规格化的二进制浮点数，数值的最高位总是1，为了使得尾数多表示一位有效数值，隐藏该最高位的1。故23位的尾数实际表示24位有效数字。

<table>
    <tr>
        <th rowspan="2">类型</th>
        <th rowspan="2">数符</th>
        <th rowspan="2">阶码</th>
        <th rowspan="2">尾数</th>
        <th rowspan="2">总位数</th>
        <th colspan="2">偏置值</th>
        <th rowspan="2">真值</th>
        <th rowspan="2">最小值</th>
        <th rowspan="2">最大值</th>
    </tr>
    <tr>
        <td>HEX</td>
        <td>DEC</td>
    </tr>
    <tr>
        <td>短浮点数<br/>（单精度）</td>
        <td>1</td>
        <td>8</td>
        <td>23</td>
        <td>32</td>
        <td>7FH</td>
        <td>127</td>
        <td>(-1)<sup>S</sup>x1.Mx2<sup>E-127</sup></td>
        <td>E=1，M=0<br/>2<sup>-126</sup></td>
        <td>E=254，M=2<sup>127</sup><br/>2<sup>127</sup>x(2-2<sup>-23</sup>)</td>
    </tr>
    <tr>
        <td>长浮点数<br/>（双精度）</td>
        <td>1</td>
        <td>11</td>
        <td>52</td>
        <td>64</td>
        <td>3FFH</td>
        <td>1023</td>
        <td>(-1)<sup>S</sup>x1.Mx2<sup>E-1023</sup></td>
        <td>E=1，M=0<br/>2<sup>-1022</sup></td>
        <td>E=2046，M=2<sup>1023</sup><br/>2<sup>1023</sup>x(2-2<sup>-52</sup>)</td>
    </tr>
    <tr>
        <td>临时浮点数</td>
        <td>1</td>
        <td>15</td>
        <td>64</td>
        <td>80</td>
        <td>3FFFH</td>
        <td>16383</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>

<table>
    <tr>
        <th rowspan="2">值的类型</th>
        <th colspan="4">单精度</th>
        <th colspan="4">双精度</th>
    </tr>
    <tr>
        <th>符号</th>
        <th>阶码</th>
        <th>尾数</th>
        <th>值</th>
        <th>符号</th>
        <th>阶码</th>
        <th>尾数</th>
        <th>值</th>
    </tr>
    <tr>
        <td>正零</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>负零</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>-0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>-0</td>
    </tr>
    <tr>
        <td>正无穷大</td>
        <td>0</td>
        <td>255（全1）</td>
        <td>0</td>
        <td>&infin;</td>
        <td>0</td>
        <td>2047（全1）</td>
        <td>0</td>
        <td>&infin;</td>
    </tr>
    <tr>
        <td>负无穷大</td>
        <td>1</td>
        <td>255（全1）</td>
        <td>0</td>
        <td>-&infin;</td>
        <td>1</td>
        <td>2047（全1）</td>
        <td>0</td>
        <td>-&infin;</td>
    </tr>
</table>
- 浮点数运算结果超过尾数并不一定溢出，只有规格化后阶码超出所能表示的范围后，才发生溢出。

## 浮点数的加减运算

- 浮点数运算的阶码和尾数分开进行。

1. 对阶，使两个操作数的小数点位置对齐（阶码相等）。以小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为2），阶加1，直到两个数的阶码相等为止。尾数右移时，若舍弃有效位，则会产生误差，影响精度。
2. 尾数求和，将对阶后的尾数按定点数规则运算。运算后的尾数不一定是规格化的，需要再次[规格化](#规格化)。
3. 舍入，对阶和尾数右规时，可能会对尾数右移，一般将低位移出的两位保留，参加中间过程的运算，最后将运算结果进行舍入，还原为IEE754标准浮点数。（1）0舍1入法，若运算结果保留位的最高位为0，则舍去；若保留位的最高位为1，则尾数末位加1，可能导致尾数溢出，若溢出，则再次右规。（2）恒置1法，将右移后的尾数末位恒置1。（3）截断法，直接截断所需的位数，丢弃后面的所有位。
4. 溢出判断，（1）右规和尾数舍入时，需要判断是否发生了指数上溢；（2）左规时，需要判断是否发生了指数下溢。
