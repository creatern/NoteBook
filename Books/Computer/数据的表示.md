# 数制与编码

## 进位计数法

- 进位计数法，基数是每个数位所用到的不同数码的个数（十进制的基数为10，逢十进一），位权是与数码本身相关的参数，一个进位数所表示的数值是其各位数码按权相加。一个r进制数（K<sub>n</sub>K<sub>n-1</sub>...K<sub>0</sub>K<sub>-1</sub>...K<sub>-m</sub>）的数值可表示为K<sub>n</sub>r<sup>n</sup>+K<sub>n-1</sub>r<sup>n-1</sup>+...+K<sub>0</sub>r<sup>0</sup>+K<sub>-1</sub>r<sup>-1</sup>+...+K<sub>-m</sub>r<sup>-m</sup>，其中r是基数，r<sup>i</sup>是第i位的位权（整数位最低位规定为第0位），K<sub>i</sub>的取指可以是0,1,...,r-1共r个数码中的任意一个。

1. 二进制只有0和1两种数字符号，逢二进一，基数r=2，位权为2<sup>i</sup>。
2. 八进制只有0\~7的数字符号，逢八进一，基数r=8=2<sup>3</sup>，只要将二进制的3位数码编为一组就是一个八进制数码。
3. 十六进制只有0\~9、A、B、C、D、E、F的符号，逢十六进一，基数r=16=2<sup>4</sup>，只要将二进制的4位数码编为一组就是一个十六进制数码。

- BCD码（Binary\-Coded Decimal）通常采用4位二进制来表示一位十进制数中的0\~9，使得二进制数和十进制数之间的转换得以快速进行。但4位二进制数可组合出16种代码，故必有6种状态为冗余状态。

1. 8421码，设其各位的数值为b<sub>3</sub>、b<sub>2</sub>、b<sub>1</sub>、b<sub>0</sub>，位权从高到低依次为8、4、2、1，表示的十进制数D=8b<sub>3</sub>+4b<sub>2</sub>+2b<sub>1</sub>+1b<sub>0</sub>。若两个8421码相加之和小于等于(1001)<sub>2</sub>即(9)<sub>10</sub>，则不需要修正；若两个相加之和大于等于(1010)<sub>2</sub>即(10)<sub>10</sub>，则加6修正（从1010\~1111这6个为无效码），并向高位进位。
2. 余3码，在8421码的基础上加(0011)<sub>2</sub>形成，每个数都多余3。
3. 2421码，权值由高到低分别为2、4、2、1，大于等于5的4位二进制码中的最高位为1，小于5的最高位为0。

## 进制转换

### 二进制转换八进制/十六进制

- 对于一个二进制混合数（包含整数和小数部分），转换时以小数点为界。

1. 整数部分，从小数点开始往左数，将一串二进制数分为3位一组（八进制）、4位一组（十六进制），根据情况在最左边补0。
2. 小数部分，从小数点开始往右数，将一串二进制数分为3位一组（八进制）、4位一组（十六进制），根据情况在最右边补0。

- 八进制/十六进制\-\>二进制同理，每组分解为3位（八进制）、4位（十六进制）。

### 十进制\-\>任意进制

- 十进制数转换为任意进制数，采用基数乘除法，对整数部分使用除基取余法，对小数部分使用乘基取整法。

1. 除基取余法（整数部分），整数部分除基取余，最先取得的余数为数的最低位，商为0时结束。

2. 乘基取整法（小数部分），小数部分乘基取整，最先取得的整数为数的最高位，乘积为1.0时结束，或满足精度要求即可。

> 并非所有十进制小数都可以准确地用二进制小数表示。

<img src="../../pictures/计算机组成原理-transation-binary-ten.drawio.svg" width="400"/> 

# 基本运算部件

## 一位全加器

- 全加器（FA）是最基本的加法单元，有加数A<sub>i</sub>、加数B<sub>i</sub>、低位传来的进位C<sub>i-1</sub>共3个输入，有本位和S<sub>i</sub>、向高位的进位C<sub>i</sub>共2个输出。
- 全加器的逻辑表达式

1. 和表达式：S<sub>i</sub>=A<sub>i</sub>&oplus;B<sub>i</sub>&oplus;C<sub>i-1</sub>
2. 进位表达式：C<sub>i</sub>=A<sub>i</sub>B<sub>i</sub> \+ (A<sub>i</sub>&oplus;B<sub>i</sub>)C<sub>i-1</sub>

<img src="../../pictures/计算机组成原理-FA-locagic.drawio.svg" width="500"/> 

## 串行进位全加器

- 串行进位全加器，把n个全加器相连可得到n位加法器。串行进位（行波进位）的每级进位直接依赖于前一级的进位，即进位信号是逐级形成的。

<img src="../../pictures/计算机组成原理-FA串行进位加法器.drawio.svg" width="600"/> 

-  串行进位加法器实现了两个二进制数A=A<sub>n</sub>A<sub>n-1</sub>...A<sub>1</sub>、B=B<sub>n</sub>B<sub>n-1></sub>...B<sub>1</sub>逐相加的功能，得到的二进制和S=S<sub>n</sub>S<sub>n-1</sub>...S<sub>1</sub>，进位输出C<sub>n</sub>。由于位数有限，高位自动丢失，本质上是模2<sup>n</sup>的加法运算。
-  串行进位加法器的最长运算时间主要由进位信号的传递时间决定，位数越多，延迟越高，低位运算产生进位所需的时间影响高位运算的时间。

## 并行进位加法器

- 令G<sub>i</sub>=A<sub>i</sub>B<sub>i</sub>，P<sub>i</sub>=A<sub>i</sub>&oplus;B<sub>i</sub>，全先行进位加法器的进位表达式C<sub>i</sub>=G<sub>i</sub>\+P<sub>i</sub>C<sub>i-1</sub>，通过CLA部件（先行进位部件、超前进位部件）实现，各个进位都是并行产生的。C<sub>i</sub>仅与A<sub>i</sub>、B<sub>i</sub>、最低进位C<sub>0</sub>有关，相互之间的进位没有依赖关系（与位数无关）。只要A<sub>i</sub>、B<sub>i</sub>、最低进位C<sub>0</sub>都到达即可几乎同时形成C<sub>1</sub>\~C<sub>4</sub>，并同时生成各位的和。

1. G<sub>i</sub>=A<sub>i</sub>B<sub>i</sub>为进位产生函数（本地进位），A<sub>i</sub>与B<sub>i</sub>均为1时，C<sub>i</sub>=1，有进位信号产生。
2. P<sub>i</sub>=A<sub>i</sub>&oplus;B<sub>i</sub>为进位传递函数（进位传递条件），

C<sub>1</sub>=G<sub>1</sub>+P<sub>1</sub>C<sub>0</sub>

C<sub>2</sub>=G<sub>2</sub>+P<sub>2</sub>C<sub>1</sub>=G<sub>2</sub>+P<sub>2</sub>G<sub>1</sub>+P<sub>2</sub>P<sub>1</sub>C<sub>0</sub>

C<sub>3</sub>=G<sub>3</sub>+P<sub>3</sub>C<sub>2</sub>=G<sub>3</sub>+P<sub>3</sub>G<sub>2</sub>+P<sub>3</sub>P<sub>2</sub>G<sub>1</sub>+P<sub>3</sub>P<sub>2</sub>P<sub>1</sub>C<sub>0</sub>

C<sub>4</sub>=G<sub>4</sub>+P<sub>4</sub>C<sub>3</sub>=G<sub>4</sub>+P<sub>4</sub>G<sub>3</sub>+P<sub>4</sub>P<sub>3</sub>G<sub>2</sub>+P<sub>4</sub>P<sub>3</sub>P<sub>2</sub>G<sub>1</sub>+P<sub>4</sub>P<sub>3</sub>P<sub>2</sub>P<sub>1</sub>C<sub>0</sub>

<img src="../../pictures/计算机组成原理-并行进位加法器.drawio.svg" width="600"/> 

<img src="../../pictures/计算机组成原理-并行进位加法器2.drawio.svg" width="600"/> 

## 带标志加法器

1. 溢出标志的逻辑表达式为OF=C<sub>n</sub>&oplus;C<sub>n-1</sub>
2. 符号标志就是和的符号SF=F<sub>n-1</sub>
3. 零标志ZF=1，当且仅当F=0
4. 进位/借位标志CF=C<sub>out</sub>&oplus;C<sub>in</sub>，即C<sub>in</sub>=0时，CF为进位C<sub>out</sub>；C<sub>in</sub>=1时，CF为进位C<sub>out</sub>取反

<img src="../../pictures/计算机组成原理-带标志加法器.drawio.svg" width="800"/> 

## ALU 算术逻辑单元

- [ALU](./组成原理概述.md)能进行多种算术运算和逻辑运算（包括移位操作），核心是带标志加法器（所有加减乘除运算都能最终归结为加法运算）。

1. A、B是两个n位操作数输入端
2. C<sub>in</sub>是进位输入端
3. ALUop是操作控制端，决定ALU执行的处理功能，其位数决定了操作的种类数量。

<img src="../../pictures/计算机组成原理-ALU基本结构.drawio.svg" width="700"/> 

# 定点数

## 定点数的编码表示

- 由小数点的位置是否固定，分为定点表示和浮点表示。现代计算机通常使用定点补码整数表示整数，定点原码小数表示浮点数的尾数部分，移码表示浮点数的阶码部分。

### 机器数的定点表示

- 真值：带符号（+、-）的数。
- 机器数：符号数字化（用0、1表示符号）的数，按机器的字长补足位数（补0）。

1. 定点小数是纯小数，约定小数点位置在符号位之后、有效值部分最高位之前。

<img src="../../pictures/计算机组成原理-定点小数表示.drawio.svg" width="280"/> 

2. 定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。

<img src="../../pictures/计算机组成原理-定点整数表示.drawio.svg" width="300"/> 

### 原码、补码、反码、移码

#### 原码

- 原码表示法用机器数的最高位表示数的符号（0正数、1负数），其余各位表示数的绝对值。

1. 纯小数，若字长为n+1，则原码小数的表示范围为 \- (1\-2<sup>-n</sup>) &le; x &le; 1 - 2<sup>-n</sup>（关于原点对称）。

<img src="../../pictures/20231115194935.png" width="400"/> 

2. 纯整数，若字长为n+1，则原码小数的表示范围为 \- (2<sup>n</sup>-1) &le; x &le; 2<sup>n</sup>-1（关于原点对称）。

<img src="../../pictures/20231115195020.png" width="400"/> 

3. 真值0的原码表示有正0和负0两种，\[\+0\]<sub>原</sub>=00000、\[\-0\]<sub>原</sub>=10000。

#### 补码

- 补码表示法中的加减运算统一采用加法操作实现，使负数通过与其同余的整数来表示。

> - 同余：整数A和B在以M为模时相等：A = B (mod M).。
>   - 5 = 17 (mode 12)、-2 = 10 (mod 12)。
> - 同余的两个数具有互补关系：通过与负数等价的正数来表示。
>   - 9 - 5 = 9 + (-5) = 9 + (12 - 5) = 4 (mod 12)。

1. 纯小数，若字长为n+1，则补码小数的表示范围为 \-1 &le; x &le; 1\-2<sup>-n</sup>（比原码多表示\-1）。

<img src="../../pictures/20231115195710.png" width="400"/> 

2.  纯整数，若字长为n+1，则补码整数的表示范围为 -2<sup>n</sup> &le; x &le; 2<sup>n</sup>-1（比原码多表示-2<sup>n</sup>）。

<img src="../../pictures/20231115195807.png" width="500"/> 

3. 真值0的补码表示只有一种，\[\+0\]<sub>补</sub> = \[\-0\]<sub>补</sub> = 0\.0000。

- 将\[X\]<sub>补</sub>的符号位与数值位一起右移并保持符号位不变，可实现除法。
- 补码转换为真值，若为正数，则去除符号位即可；若为负数，真值的数值部分各位可由原码“各位取反，末位加1”得到。

##### 模4补码

- <a href="#mod4">模4补码</a>，双符号位的补码小数，双符号位00表示正，11表示负，更容易检查加减算法的溢出，用于完成算术运算的ALU部件。每个模4补码存储时只需要1个符号位。

<img src="../../pictures/20231115195711.png" width="400"/> 

#### 反码

1. 纯小数

<img src="../../pictures/20231115201133.png" width="450"/> 

2. 纯整数，表示范围比补码少一个2<sup>-n</sup>

<img src="../../pictures/20231115201210.png" width="450"/> 

- 真值0的反码表示不唯一，\[\+0\]<sub>反</sub>=00000、\[\-0\]<sub>反</sub>=11111。

#### 移码

- 移码只能表示整数，常用作浮点数的阶码。补码在真值X上加上一个偏置值，通常为2<sup>n</sup>，相等于X在数轴上偏移了若干个单位。

\[X\]<sub>移</sub> = 2<sup>n</sup> + x       (-2<sup>n</sup> &le; x &le; 2<sup>n</sup>，字长为n+1)

1. 真值0的补码表示只有一种，\[\+0\]<sub>补</sub> = \[\-0\]<sub>补</sub> = 2<sup>n</sup>+0 = 10000。
2. 移码和补码只相差一个符号位，补码的符号位取反即为移码。
3. 移码全0时，对应真值的最小值-2<sup>n</sup>；移码全1时，对应真值的最大值2<sup>n</sup>-1。
4. 移码保持了真值原有的大小顺序。

### 无符号数、有符号数

- 无符号数由寄存器的位数反映表示范围。
- 有符号数分为数值和符号两部分，最高位表示符号。在计算机中，带符号整数都是补码表示。

## 定点数的移位运算

### 算术移位

- 算术移位的对象是有符号数，在移位过程中符号位保持不变。

1. 对于正数，左移时，若高位丢1，则结果出错；右移时，若低位丢1，则影响精度。
2. 对于负数原码，左移时，若高位丢1，则结果出错；右移时，若低位丢1，则影响精度。
3. 对于负数补码，左移时，若高位丢0，则结果出错；右移时，若低位丢1，则影响精度。
4. 对于负数反码，左移时，若高位丢0，则结果出错；右移时，若低位丢0，则影响精度。

<table>
    <tr>
        <th></th>
        <th>码制</th>
        <th>填补代码</th>
    </tr>
    <tr>
        <td>正数</td>
        <td>原码、补码、反码</td>
        <td>0</td>
    </tr>
    <tr>
        <td rowspan="4">负数</td>
        <td>原码</td>
        <td>0</td>
    </tr>
    <tr>
        <td rowspan="2">补码</td>
        <td>左移补0</td>
    </tr>
    <tr>
        <td>右移补1</td>
    </tr>
    <tr>
        <td>反码</td>
        <td>1</td>
    </tr>
</table>

### 逻辑移位

- 逻辑移位将操作数视为无符号数。

1. 逻辑左移时，高位移丢，低位补0。
2. 逻辑右移时，低位移丢，高位补0。

### 循环移位

- 循环移位分为带进位标志CF的循环移位（大循环）和不带进位标志的循环移位（小循环），移出的数位又被移入数据中。

1. 若带进位循环左移，则将数据位连同进位标志一起移动，数据的最高位移入进位标志位CF，进位位则依次进入数据的最低位。
2. 若不带进位循环左移，则将数据位连同进位标志一起移动，数据的最高位分别移入进位标志位CF和数据的最低位。

> 适合将低字节的数据和高字节的交换。

<img src="../../pictures/计算机组成原理-循环移位.drawio.svg" width="600"/> 

<details>

</details>

## 定点数的加减运算

> 在机器中，小数点并不存在，只是人为约定的小数点位置。

### 补码加减运算

- 补码加减运算的公式（字长为n\+1），减法运算可视为与被减数（负数）的补码相加。

\[A\+B\]<sub>补</sub> = \[A\]<sub>补</sub> \+ \[B\]<sub>补</sub>  （mod 2<sup>n+1</sup>）

\[A\-B\]<sub>补</sub> = \[A\]<sub>补</sub> \+ \[\-B\]<sub>补</sub>  （mod 2<sup>n+1</sup>）

- 按二进制运算，逢二进一；符号位和数值位一起参与运算；最终运算结果的高位丢弃，保留n\+1位，运算结果仍然为补码。

### 补码加减运算电路

- 已知一个数的补码表示为Y，则这个数的负数的补码为$\overline{Y}$+1。只要在原加法器的Y输入端加n个反向器以实现各位取反的功能，之后加一个2选1多路选择器，用一个控制端Sub来控制，以选择是将Y输入加法器还是将y̅输入加法器，并把控制端Sub同时作为低位进位送到加法器。（可通过标志信息来区分带符号整数运算结果和无返回整数运算结果）

<img src="../../pictures/计算机组成原理-补码加减运算部件.drawio.svg" width="400"/> 

1. 零标志ZF=1，表示结果F为0。对无符号数和带符号数运算都有意义。
2. 溢出标志OF=1，表示带符号整数运算时发生溢出。对无符号数运算无意义。
3. 符号标志SF，表示结果的符号，即F的最高位。对无符号数运算无意义。
4. 进/借位标志CF=Sub&oplus;C<sub>out</sub>，表示无符号整数运算时的进位/借位，判断是否发生溢出。加法时，若CF=1，则结果溢出，此时CF=C<sub>out</sub>；减法时，若CF=1，则表示有借位（不够减），此时CF=C<sub>out</sub>取反。对带符号数运算无意义。

### 补码溢出判别

- 仅当两个符号相同的数相加、两个符号相异的数相减才可能发生溢出。

#### 一位符号位

- 只要参加操作的两个操作数符号相同，而结果的符号与原操作数的符号不同，就判断结果溢出。

- 设A的符号为A<sub>s</sub>、B的符号为B<sub>s</sub>、运算结果的符号为S<sub>s</sub>，则溢出逻辑表达式为<img src="../../pictures/20231116113354.png" width="200"/>。若V=0，则表示无溢出；若V=1，则表示结果溢出。

#### 双符号位（mod 4）

- <span name="mod4">双符号位（模4补码）</span>的溢出逻辑表达式为 V=S<sub>s1</sub>&oplus;S<sub>s2</sub> 。若V=0，则表示无溢出；若V=1，则表示结果溢出。

| 符号位 S<sub>s1</sub>S<sub>s2</sub> | 溢出判断   |
| ----------------------------------- | ---------- |
| 00                                  | 正数无溢出 |
| 01                                  | 正溢出     |
| 10                                  | 负溢出     |
| 11                                  | 负数无溢出 |

#### 进位判断

- 溢出逻辑表达式为 V=C<sub>s</sub>&oplus;C<sub>1</sub> 。若V=0，符号位的进位C<sub>s</sub>与最高数位的进位C<sub>1</sub>相同，则表示无溢出；否则V=1，表示发生溢出。

## 定点数的乘除运算

### 定点数的乘法运算

- 乘法运算由累加和右移操作实现，分为原码一位乘法和补码一位乘法。

#### 原码一位乘法

- 原码一位乘法的符号位和数值为分开求，乘积的符号位由两个操作数的符号位‘’异或“得到，乘积的数值位是两个数的绝对值乘积。

- 设\[X\]<sub>原</sub>=x<sub>s</sub>\.x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>、\[Y\]<sub>原</sub>=y<sub>s</sub>\.y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>，则运算规则为：

1. 被乘数和乘数均取绝对值（数值位）运算；符号位单独运算x<sub>s</sub>&oplus;y<sub>s</sub>
2. <span name="部分积">部分积</span>是乘法过程的中间结果，初始值为0。乘数的每一位y<sub>i</sub>乘以被乘数得到X\*y<sub>i</sub>，并将该结果和之前的部分积相加，得到当前的部分积。（部分积由高位部分积和低位部分积拼接而成）
3. 从乘数的最低位y<sub>n</sub>开始判断，若y<sub>n</sub>=1，则部分积加上被乘数\|x\|，然后部分积都右移一位；若y<sub>n</sub>=0，则部分积加上0，然后部分积都右移一位。
4. 重复步骤3，判断n次（右移n次，n为字长-1）。

<img src="../../pictures/计算机组成原理-原码一位乘法.drawio.svg" width="500"/> 

##### 无符号数乘法运算电路

#### 补码一位乘法（Booth算法）

- 补码一位乘法是有符号数的乘法，利用相加和相减计算补码数据的乘积。
- 设\[X\]<sub>补</sub>=x<sub>s</sub>\.x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>、\[Y\]<sub>补</sub>=y<sub>s</sub>\.y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>，则运算规则为：

1. 符号位参与运算，运算的数均为补码表示。
2. 被乘数一般取双符号位参与运算；<a href="#部分积">部分积</a>取双符号位，初始值为0；乘数取单符号位。
3. 乘数末位增设附加位y<sub>n+1</sub>，初始值为0。
4. 根据（y<sub>n</sub>, y<sub>n+1</sub>）的取值来确定操作，按补码移位规则移位。

| y<sub>n</sub>（高位） | y<sub>n+1</sub>（低位） | 操作                                  |
| --------------------- | ----------------------- | ------------------------------------- |
| 0                     | 0                       | 部分积右移一位                        |
| 0                     | 1                       | 部分积加\[x\]<sub>补</sub>，右移一位  |
| 1                     | 0                       | 部分积加\[-x\]<sub>补</sub>，右移一位 |
| 1                     | 1                       | 部分积右移一位                        |

5. 重复以上步骤n+1次，第n\+1步不再移位（共n\+1次累加、n次右移），仅根据y<sub>n</sub>和y<sub>n+1</sub>的比较结果做相应运算。

<img src="../../pictures/计算机组成原理-补码一位乘法.drawio.svg" width="550"/> 

##### 补码乘法运算电路

### 定点数的除法运算

- 除法运算可转换为“累加\-左移”（逻辑左移），分为原码除法和补码除法。

- 符号扩展将带符号的定点数转换成不同位数的表示。

1. 正数的符号扩展，符号位不变，扩展位使用0填充。
2. 原码负数的符号扩展，与正数相同。
3. 补码负数的符号扩展，原有的符号位移动至新符号位，附加位整数使用1填补，小数使用0填补。

#### 原码除法运算（不恢复余数法）

- 原码不恢复余数法（原码加减交替除法），商符和商值是分开进行的。
- 设被除数\[X\]<sub>原</sub>=x<sub>s</sub>\.x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>、\[Y\]<sub>原</sub>=y<sub>s</sub>\.y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>

1. 商符：Q<sub>s</sub>=x<sub>s</sub>&oplus;y<sub>s</sub>
2. 商值：\|Q\|=\|X\|/\|Y\|

- 求\|Q\|的不恢复余数法运算

1. 先用被除数减去除数（\|X\|-\|Y\|=\|X\|+(\-\|Y\|)=\[X\]+\[\-\|Y\|\]<sub>补</sub>），当余数为正时，商末位加上1，余数和商左移一位，再减去余数；当余数为负时，商末位加上0，余数和商左移一位，再加上余数。（包括符号位移动）
2. 第n+1步余数为负时，需要加上\|Y\|以得到第n\+1步正确的余数（余数与被除数同号）。

<img src="../../pictures/计算机组成原理-原码一位除法.drawio.svg" width="550"/> 

#### 补码除法运算（加减交替法）

- 补码一位除法，符号位和数值位一起参与运算，商符自然形成。除法第一步根据被除数和除数的符号决定加法或减法。上商的原则根据余数和除数和符号位决定。

1. 符号位参与运算，除数、被除数、商、余数使用补码表示。
2. 若被除数与除数同号，则被除数减去除数；若被除数和除数异号，则被除数加上除数。
3. 若余数与除数同号，则商上1，余数左移一位减去除数；若余数与除数异号，则商上0，余数左移一位加上除数。
4. 重复第3步n次。
5. 若对商的精度没有特殊要求，则一般采用“末位恒置1”。

<img src="../../pictures/计算机组成原理-补码一位除法.drawio.svg" width="650"/> 

##### 除法运算电路

# 浮点数

## 浮点数的表示

- 浮点数以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动，即扩大了数的范围，又保持了数的有效精度。

$$
N= (-1)^S \times M \times r^E
$$

<img src="../../pictures/Snipaste_2023-05-02_17-54-49.png" width="400"/> 

- 阶码的值反映浮点数的小数点的实际位置；阶码的位数反映浮点数的表示范围；尾数的位数反映浮点数的精度。

1. r（基数，浮点数阶码的底），通常r=2，在浮点数中隐含。r增大，可表示数的范围增大、可表示数的个数增加、数在数轴上的分布密度越稀疏、可表示数的精度下降、降低因尾数右移导致的运算精度损失、使运算中移位的次数减少，提高运算速度

2. E（阶码，Exponent），定点整数（移码/补码）。浮点数的指数部分，数量级、小数点的位置。

3. M（尾数，Mantissa），定点小数（原码/补码）。浮点数的小数部分，精度。尾数位数决定浮点数的有效数位，有效数位越多，数据的精度越高。

### 浮点数的表示范围

- 浮点数的表示范围是关于原点对称的。

1. 上溢，运算结果大于最大正数时为正上溢，小于绝对值最大负数时为负上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。
2. 下溢，运算结果在0\~最小正数之间时为正下溢，在0\~绝对值最小负数之间时为负下溢。数据下溢时，浮点数值趋于零，计算机仅将其动作机器零处理。

<img src="../../pictures/计算机组成原理-float-format.drawio.svg" width="430"/> 

## 浮点数规格化

- <span name="规格化">浮点数规格化</span>，调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。浮点数的表示形式不唯一，需要找到规格化浮点数。

1. 左规，运算结果的尾数的最高数位不是有效位时，可能需要多次左规，尾数每左移一位、阶码减1（基数为2）。
2. 右规，运算结果的尾数的有效位进到小数点前时，需要且只需一次右规，尾数右移一位、阶码加1（基数为2）。

- 规格化浮点数的尾数M的绝对值应满足 1/r &le;\|M\| &le; 1。当浮点数尾数的基数为2时，原码规格化的尾数最高位一定是1；当基数为4时，原码规格化形式的尾数最高两位不全为0。

## IEEE 754 标准

<img src="../../pictures/计算机组成原理-IEEE754标准浮点数的格式.drawio.svg" width="450"/> 

- IEE754标准规定常用的浮点数格式有短浮点数（单精度、float型）、长浮点数（双精度、double型）、临时浮点数，其基数隐含为2。IEEE754标准的浮点数（除临时浮点数之外）是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。
- 对于规格化的二进制浮点数，数值的最高位总是1，为了使得尾数多表示一位有效数值，隐藏该最高位的1。故23位的尾数实际表示24位有效数字。

<table>
    <tr>
        <th rowspan="2">类型</th>
        <th rowspan="2">数符</th>
        <th rowspan="2">阶码</th>
        <th rowspan="2">尾数</th>
        <th rowspan="2">总位数</th>
        <th colspan="2">偏置值</th>
        <th rowspan="2">真值</th>
        <th rowspan="2">最小值</th>
        <th rowspan="2">最大值</th>
    </tr>
    <tr>
        <td>HEX</td>
        <td>DEC</td>
    </tr>
    <tr>
        <td>短浮点数<br/>（单精度）</td>
        <td>1</td>
        <td>8</td>
        <td>23</td>
        <td>32</td>
        <td>7FH</td>
        <td>127</td>
        <td>(-1)<sup>S</sup>x1.Mx2<sup>E-127</sup></td>
        <td>E=1，M=0<br/>2<sup>-126</sup></td>
        <td>E=254，M=2<sup>127</sup><br/>2<sup>127</sup>x(2-2<sup>-23</sup>)</td>
    </tr>
    <tr>
        <td>长浮点数<br/>（双精度）</td>
        <td>1</td>
        <td>11</td>
        <td>52</td>
        <td>64</td>
        <td>3FFH</td>
        <td>1023</td>
        <td>(-1)<sup>S</sup>x1.Mx2<sup>E-1023</sup></td>
        <td>E=1，M=0<br/>2<sup>-1022</sup></td>
        <td>E=2046，M=2<sup>1023</sup><br/>2<sup>1023</sup>x(2-2<sup>-52</sup>)</td>
    </tr>
    <tr>
        <td>临时浮点数</td>
        <td>1</td>
        <td>15</td>
        <td>64</td>
        <td>80</td>
        <td>3FFFH</td>
        <td>16383</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>


<table>
    <tr>
        <th rowspan="2">值的类型</th>
        <th colspan="4">单精度</th>
        <th colspan="4">双精度</th>
    </tr>
    <tr>
        <th>符号</th>
        <th>阶码</th>
        <th>尾数</th>
        <th>值</th>
        <th>符号</th>
        <th>阶码</th>
        <th>尾数</th>
        <th>值</th>
    </tr>
    <tr>
        <td>正零</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>负零</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>-0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>-0</td>
    </tr>
    <tr>
        <td>正无穷大</td>
        <td>0</td>
        <td>255（全1）</td>
        <td>0</td>
        <td>&infin;</td>
        <td>0</td>
        <td>2047（全1）</td>
        <td>0</td>
        <td>&infin;</td>
    </tr>
    <tr>
        <td>负无穷大</td>
        <td>1</td>
        <td>255（全1）</td>
        <td>0</td>
        <td>-&infin;</td>
        <td>1</td>
        <td>2047（全1）</td>
        <td>0</td>
        <td>-&infin;</td>
    </tr>
</table>
- 浮点数运算结果超过尾数并不一定溢出，只有规格化后阶码超出所能表示的范围后，才发生溢出。

## 浮点数的加减运算

- 浮点数运算的阶码和尾数分开进行。

1. 对阶，使两个操作数的小数点位置对齐（阶码相等）。以小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为2），阶加1，直到两个数的阶码相等为止。尾数右移时，若舍弃有效位，则会产生误差，影响精度。
2. 尾数求和，将对阶后的尾数按定点数规则运算。运算后的尾数不一定是规格化的，需要再次[规格化](#规格化)。
3. 舍入，对阶和尾数右规时，可能会对尾数右移，一般将低位移出的两位保留，参加中间过程的运算，最后将运算结果进行舍入，还原为IEE754标准浮点数。（1）0舍1入法，若运算结果保留位的最高位为0，则舍去；若保留位的最高位为1，则尾数末位加1，可能导致尾数溢出，若溢出，则再次右规。（2）恒置1法，将右移后的尾数末位恒置1。（3）截断法，直接截断所需的位数，丢弃后面的所有位。
4. 溢出判断，（1）右规和尾数舍入时，需要判断是否发生了指数上溢；（2）左规时，需要判断是否发生了指数下溢。
