# 数制与编码



# 浮点数

## 浮点数的表示

- 浮点数以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动，即扩大了数的范围，又保持了数的有效精度。

$$
N= (-1)^S \times M \times r^E
$$

<img src="../../pictures/Snipaste_2023-05-02_17-54-49.png" width="400"/> 

- 阶码的值反映浮点数的小数点的实际位置；阶码的位数反映浮点数的表示范围；尾数的位数反映浮点数的精度。

1. r（基数，浮点数阶码的底），通常r=2，在浮点数中隐含。r增大，可表示数的范围增大、可表示数的个数增加、数在数轴上的分布密度越稀疏、可表示数的精度下降、降低因尾数右移导致的运算精度损失、使运算中移位的次数减少，提高运算速度

2. E（阶码，Exponent），定点整数（移码/补码）。浮点数的指数部分，数量级、小数点的位置。

3. M（尾数，Mantissa），定点小数（原码/补码）。浮点数的小数部分，精度。尾数位数决定浮点数的有效数位，有效数位越多，数据的精度越高。

### 浮点数的表示范围

- 浮点数的表示范围是关于原点对称的。

1. 上溢，运算结果大于最大正数时为正上溢，小于绝对值最大负数时为负上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。
2. 下溢，运算结果在0\~最小正数之间时为正下溢，在0\~绝对值最小负数之间时为负下溢。数据下溢时，浮点数值趋于零，计算机仅将其动作机器零处理。

<img src="../../pictures/计算机组成原理-float-format.drawio.svg" width="430"/> 

## 浮点数规格化

- <span name="规格化">浮点数规格化</span>，调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。浮点数的表示形式不唯一，需要找到规格化浮点数。

1. 左规，运算结果的尾数的最高数位不是有效位时，可能需要多次左规，尾数每左移一位、阶码减1（基数为2）。
2. 右规，运算结果的尾数的有效位进到小数点前时，需要且只需一次右规，尾数右移一位、阶码加1（基数为2）。

- 规格化浮点数的尾数M的绝对值应满足 1/r &le;\|M\| &le; 1。当浮点数尾数的基数为2时，原码规格化的尾数最高位一定是1；当基数为4时，原码规格化形式的尾数最高两位不全为0。

## IEEE 754 标准

<img src="../../pictures/计算机组成原理-IEEE754标准浮点数的格式.drawio.svg" width="450"/> 

- IEE754标准规定常用的浮点数格式有短浮点数（单精度、float型）、长浮点数（双精度、double型）、临时浮点数，其基数隐含为2。IEEE754标准的浮点数（除临时浮点数之外）是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。
- 对于规格化的二进制浮点数，数值的最高位总是1，为了使得尾数多表示一位有效数值，隐藏该最高位的1。故23位的尾数实际表示24位有效数字。

<table>
    <tr>
        <th rowspan="2">类型</th>
        <th rowspan="2">数符</th>
        <th rowspan="2">阶码</th>
        <th rowspan="2">尾数</th>
        <th rowspan="2">总位数</th>
        <th colspan="2">偏置值</th>
        <th rowspan="2">真值</th>
        <th rowspan="2">最小值</th>
        <th rowspan="2">最大值</th>
    </tr>
    <tr>
        <td>HEX</td>
        <td>DEC</td>
    </tr>
    <tr>
        <td>短浮点数<br/>（单精度）</td>
        <td>1</td>
        <td>8</td>
        <td>23</td>
        <td>32</td>
        <td>7FH</td>
        <td>127</td>
        <td>(-1)<sup>S</sup>x1.Mx2<sup>E-127</sup></td>
        <td>E=1，M=0<br/>2<sup>-126</sup></td>
        <td>E=254，M=2<sup>127</sup><br/>2<sup>127</sup>x(2-2<sup>-23</sup>)</td>
    </tr>
    <tr>
        <td>长浮点数<br/>（双精度）</td>
        <td>1</td>
        <td>11</td>
        <td>52</td>
        <td>64</td>
        <td>3FFH</td>
        <td>1023</td>
        <td>(-1)<sup>S</sup>x1.Mx2<sup>E-1023</sup></td>
        <td>E=1，M=0<br/>2<sup>-1022</sup></td>
        <td>E=2046，M=2<sup>1023</sup><br/>2<sup>1023</sup>x(2-2<sup>-52</sup>)</td>
    </tr>
    <tr>
        <td>临时浮点数</td>
        <td>1</td>
        <td>15</td>
        <td>64</td>
        <td>80</td>
        <td>3FFFH</td>
        <td>16383</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>

<table>
    <tr>
        <th rowspan="2">值的类型</th>
        <th colspan="4">单精度</th>
        <th colspan="4">双精度</th>
    </tr>
    <tr>
        <th>符号</th>
        <th>阶码</th>
        <th>尾数</th>
        <th>值</th>
        <th>符号</th>
        <th>阶码</th>
        <th>尾数</th>
        <th>值</th>
    </tr>
    <tr>
        <td>正零</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>负零</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>-0</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>-0</td>
    </tr>
    <tr>
        <td>正无穷大</td>
        <td>0</td>
        <td>255（全1）</td>
        <td>0</td>
        <td>&infin;</td>
        <td>0</td>
        <td>2047（全1）</td>
        <td>0</td>
        <td>&infin;</td>
    </tr>
    <tr>
        <td>负无穷大</td>
        <td>1</td>
        <td>255（全1）</td>
        <td>0</td>
        <td>-&infin;</td>
        <td>1</td>
        <td>2047（全1）</td>
        <td>0</td>
        <td>-&infin;</td>
    </tr>
</table>
- 浮点数运算结果超过尾数并不一定溢出，只有规格化后阶码超出所能表示的范围后，才发生溢出。

## 浮点数的加减运算

- 浮点数运算的阶码和尾数分开进行。

1. 对阶，使两个操作数的小数点位置对齐（阶码相等）。以小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为2），阶加1，直到两个数的阶码相等为止。尾数右移时，若舍弃有效位，则会产生误差，影响精度。
2. 尾数求和，将对阶后的尾数按定点数规则运算。运算后的尾数不一定是规格化的，需要再次[规格化](#规格化)。
3. 舍入，对阶和尾数右规时，可能会对尾数右移，一般将低位移出的两位保留，参加中间过程的运算，最后将运算结果进行舍入，还原为IEE754标准浮点数。（1）0舍1入法，若运算结果保留位的最高位为0，则舍去；若保留位的最高位为1，则尾数末位加1，可能导致尾数溢出，若溢出，则再次右规。（2）恒置1法，将右移后的尾数末位恒置1。（3）截断法，直接截断所需的位数，丢弃后面的所有位。
4. 溢出判断，（1）右规和尾数舍入时，需要判断是否发生了指数上溢；（2）左规时，需要判断是否发生了指数下溢。
