# 数制与编码

## 进位计数法与其转换

### 进位计数法

#### 进位计数法（进制）

- 进位计数法，基数是每个数位所用到的不同数码的个数（十进制的基数为10，逢十进一），位权是与数码本身相关的参数，一个进位数所表示的数值是其各位数码按权相加。一个r进制数（K<sub>n</sub>K<sub>n-1</sub>...K<sub>0</sub>K<sub>-1</sub>...K<sub>-m</sub>）的数值可表示为K<sub>n</sub>r<sup>n</sup>+K<sub>n-1</sub>r<sup>n-1</sup>+...+K<sub>0</sub>r<sup>0</sup>+K<sub>-1</sub>r<sup>-1</sup>+...+K<sub>-m</sub>r<sup>-m</sup>，其中r是基数，r<sup>i</sup>是第i位的位权（整数位最低位规定为第0位），K<sub>i</sub>的取指可以是0,1,...,r-1共r个数码中的任意一个。

<table>
    <tr>
        <th>进制</th>
        <th>后缀</th>
        <th>描述</th>
    </tr>
    <tr>
        <td width="15%">二进制 binary</td>
        <td width="5%">B</td>
        <td width="80%">二进制只有0和1两种数字符号，逢二进一，基数r=2，位权为2<sup>i</sup>。</td>
    </tr>
    <tr>
        <td>八进制 Oct</td>
        <td>O</td>
        <td>八进制只有0~7的数字符号，逢八进一，基数r=8=2<sup>3</sup>，只要将二进制的3位数码编为一组就是一个八进制数码。</td>
    </tr>
    <tr>
        <td>十六进制 HEX</td>
        <td>H</td>
        <td>十六进制只有0~9、A、B、C、D、E、F的符号，逢十六进一，基数r=16=2<sup>4</sup>，只要将二进制的4位数码编为一组就是一个十六进制数码。</td>
    </tr>
</table>

#### 二进制的优势

- 在计算机系统内部，所有信息都是用用二进制进行编码：

1. 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低，例如高低电平、电荷的正负极性可以表示0和1。
2. 二进制位1和0正好和逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。
3. 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。

#### BCD码

- BCD码（Binary\-Coded Decimal）通常采用4位二进制来表示一位十进制数中的0\~9，使得二进制数和十进制数之间的转换得以快速进行。但4位二进制数可组合出16种代码，故必有6种状态为冗余状态。

<table>
    <tr>
        <td width="10%" rowspan="3">8421码</td>
        <td width="90">8421码设其各位的数值为b<sub>3</sub>、b<sub>2</sub>、b<sub>1</sub>、b<sub>0</sub>，位权从高到低依次为8、4、2、1，表示的十进制数D=8b<sub>3</sub>+4b<sub>2</sub>+2b<sub>1</sub>+1b<sub>0</sub>。</td>
    </tr>
    <tr>
        <td>若两个8421码相加之和小于等于(1001)<sub>2</sub>即(9)<sub>10</sub>，则不需要修正。</td>
    </tr>
    <tr>
        <td>若两个相加之和大于等于(1010)<sub>2</sub>即(10)<sub>10</sub>，则加6修正（从1010~1111这6个为无效码），并向高位进位。</td>
    </tr>
    <tr>
        <td>余3码</td>
        <td>在8421码的基础上加(0011)<sub>2</sub>形成，每个数都多余3。</td>
    </tr>
    <tr>
        <td>2421码</td>
        <td>权值由高到低分别为2、4、2、1。大于等于5的4位二进制码中的最高位为1，小于5的最高位为0。</td>
    </tr>
</table>

### 不同进制间的转换

#### 二进制&rarr;八进制/十六进制

- 对于一个二进制混合数（包含整数和小数部分），转换时以小数点为界。

1. 整数部分，从小数点开始往左数，将一串二进制数分为3位一组（八进制）、4位一组（十六进制），根据情况在最左边补0。
2. 小数部分，从小数点开始往右数，将一串二进制数分为3位一组（八进制）、4位一组（十六进制），根据情况在最右边补0。

- 八进制/十六进制&rarr;二进制同理，每组分解为3位（八进制）、4位（十六进制）。

#### 十进制&rarr;任意进制

- 十进制数转换为任意进制数，采用<b>基数乘除法</b>，对整数部分使用除基取余法，对小数部分使用乘基取整法。但并非所有十进制小数都可以准确地用二进制小数表示。

<table>
    <tr>
        <td width="25%">除基取余法（整数部分）</td>
        <td width="75%">整数部分除基取余，最先取得的余数为数的最低位，商为0时结束。</td>
    </tr>
    <tr>
        <td>乘基取整法（小数部分）</td>
        <td>小数部分乘基取整，最先取得的整数为数的最高位，乘积为1.0时结束，或满足精度要求即可。</td>
    </tr>
</table>
<img src="../../pictures/计算机组成原理-transation-binary-ten.drawio.svg" width="400"/> 

## 定点数

### 真值和机器数

<table>
    <tr>
        <td width="10%">真值</td>
        <td width="90%">带符号（+、-）的数（可以是二进制数、十进制数等进制，为方便和机器数的计算，通常使用二进制）</td>
    </tr>
    <tr>
        <td rowspan="2">机器数</td>
        <td>符号数字化（用0、1表示符号）的数，按机器的字长补足位数（补0）</td>
    </tr>
    <tr>
        <td>常用的有原码、补码、反码表示法等</td>
    </tr>
</table>


### 机器数的定点表示（定点小数与定点整数）

- 由小数点的位置是否固定，分为定点表示和浮点表示。现代计算机通常使用如下方式表示：

1. 定点补码整数表示整数。
2. 定点原码小数表示浮点数的尾数部分，移码表示浮点数的阶码部分。

<table>
    <tr>
        <td width="12%"  rowspan="2">定点小数<br/>（纯小数）</td>
        <td width="88%">定点小数是纯小数，约定小数点位置在符号位之后、有效值部分最高位之前。</td>
    </tr>
    <tr>
        <td><img src="../../pictures/计算机组成原理-定点小数表示.drawio.svg" width="280"/></td>
    </tr>
    <tr>
        <td rowspan="2">定点整数<br/>（纯整数）</td>
        <td>定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。</td>
    </tr>
    <tr>
        <td><img src="../../pictures/计算机组成原理-定点整数表示.drawio.svg" width="300"/></td>
    </tr> 
</table>

- 机器内部实际上并不存在小数点，只是人为约定了小数点的位置。因此，在定点数的编码和运算中，只需要考虑符号位和数值位即可。

### 原码、补码、反码、移码

#### 原码

##### 原码表示法

- 原码表示法用机器数的最高位表示数的符号（0正数、1负数），其余各位表示数的绝对值。

1. 纯小数，若字长为n+1，则原码小数的表示范围为 \- (1\-2<sup>-n</sup>) &le; x &le; 1 - 2<sup>-n</sup>（关于原点对称）。

<img src="../../pictures/20231115194935.png" width="400"/> 

2. 纯整数，若字长为n+1，则原码小数的表示范围为 \- (2<sup>n</sup>-1) &le; x &le; 2<sup>n</sup>-1（关于原点对称）。

<img src="../../pictures/20231115195020.png" width="400"/> 

##### 原码表示的特点

- 原码表示的优点：

1. 与真值的对应关系简单、直观，与真值的转换简单。
2. 用原码实现乘除运算比较简便。

- 原码表示的缺点：

1. 0的表示不唯一，真值0的原码表示有正0和负0两种编码，\[\+0\]<sub>原</sub>=00000、\[\-0\]<sub>原</sub>=10000。
2. 原码加减运算复杂。在原码加减运算中，对于两个不同符号数的加法（或同符号数的减法），先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后为结果选择合适的符号。

#### 补码

##### 补码表示法

1. 纯小数，若字长为n+1，则补码小数的表示范围为 \-1 &le; x &le; 1\-2<sup>-n</sup>（比原码多表示\-1）。

<img src="../../pictures/20231115195710.png" width="400"/> 

2.  纯整数，若字长为n+1，则补码整数的表示范围为 -2<sup>n</sup> &le; x &le; 2<sup>n</sup>-1（比原码多表示-2<sup>n</sup>）。

<img src="../../pictures/20231115195807.png" width="500"/> 

##### 补码的特点

1. 真值0的补码表示只有一种编码，\[\+0\]<sub>补</sub> = \[\-0\]<sub>补</sub> = 0\.0000。
2. 将\[X\]<sub>补</sub>的符号位与数值位一起右移并保持符号位不变，可实现除法。
3. 补码转换为真值，若为正数，则去除符号位即可；若为负数，真值的数值部分各位可由原码“各位取反，末位加1”得到。

##### 补码与真值的转换

- 真值&rarr;补码 （补码表示法的应用）

1. 对于正数，与原码的方式一样。
2. 对于负数，符号位取1，其余各位由真值 “各位取反，末位加1”得到。

- 补码&rarr;真值

1. 若符号位为0，则与原码的方式一样。
2. 若符号位为1，则真值的符号为负，数值部分由补码“各位取反，末位加1”得到。

##### 模运算

- 补码表示法中的加减运算统一采用加法操作实现，使负数通过与其同余的整数来表示。


1. 同余：整数A和B在以M为模时相等，<code>A = B (mod M)</code>。例如 5 = 17 (mode 12)、-2 = 10 (mod 12)。
2. 同余的两个数具有互补关系，通过与负数等价的正数来表示，也就是可以通过加法来表示减法 <code>[A]<sub>补</sub>-[B]<sub>补</sub> = [A]<sub>补</sub>+M-[B]<sub>补</sub> = [A]<sub>补</sub>+[-B]<sub>补</sub></code>。例如 9 - 5 = 9 + (-5) = 9 + (12 - 5) = 4 (mod 12)。

##### 模4补码

- <a href="#mod4">模4补码</a>，双符号位的补码小数，双符号位00表示正，11表示负，更容易检查加减算法的溢出，用于完成算术运算的ALU部件。每个模4补码存储时只需要1个符号位。

<img src="../../pictures/20231115195711.png" width="400"/> 

#### 反码

##### 反码表示法

1. 纯小数

<img src="../../pictures/20231115201133.png" width="450"/> 

2. 纯整数，表示范围比补码少一个2<sup>-n</sup>

<img src="../../pictures/20231115201210.png" width="450"/> 

##### 反码的特点

1. 真值&rarr;反码表示，可采用符号位取1，并对真值的“各位取反”来得到。因此，负数反码的定义就是在相应的补码表示中再末位减1。
2. 正数反码的定义和相应的补码（或原码）表示相同。

- 反码表示的缺点：

1. 真值0的反码表示不唯一，\[\+0\]<sub>反</sub>=00000、\[\-0\]<sub>反</sub>=11111。
2. 表示范围比补码少一个最小负数。
3. 反码在计算机中很少使用，通常用作数码变换的中间表示形式。

#### 移码

##### 移码表示法

1. 移码只能表示整数，常用作浮点数的阶码。
2. 补码在真值X上加上一个偏置值，通常为2<sup>n</sup>，相等于X在数轴上偏移了若干个单位。

<img src="../../pictures/2024-03-29_21-14.png" width="360"/> 

##### 移码的特点

1. 真值0的移码表示只有一种，\[\+0\]<sub>移</sub> =  2<sup>n</sup>+0  = \[\-0\]<sub>移</sub> =  2<sup>n</sup>-0 = 10000。（n个0，机器字长为n+1）
2. 一个真值的移码和补码只相差一个符号位，补码的符号位取反即为移码。
3. 移码全0时，对应真值的最小值-2<sup>n</sup>；移码全1时，对应真值的最大值2<sup>n</sup>-1。
4. 移码保持了真值原有的大小顺序，移码的大小对应了真值的大小。

#### <span>[x]<sub>原</sub> [x]<sub>补</sub> [x]<sub>反</sub> [x]<sub>移</sub> 的对比</span>

1. 原码、补码、反码的符号位相同，正数的机器码相同。
2. 原码、反码的表示在数轴上对称，二者都存在+0和-0两种编码。
3. 补码、移码的表示在数轴上不对称，零的表示唯一，比原码、反码多表示一个数。
4. 整数的补码、移码的符号位相反，数值位相同。
5. 负数的补码、反码末位差1。
6. 原码很容易判断大小；而负数的补码、反码很难直接判断大小。因此，补码和反码对于负数，数值位部分越小，其绝对值越大，就越小。

## 整数的表示

### 无符号(整)数

- 当一个编码的全部二进制位均为数值位，而没有符号位时，该编码表示就是<b>无符号数</b>。

1. 无符号数默认数的符号为正，不能表示负数。
2. 无符号数省略了一个符号位，在字长相同的情况下，可以比有符号数多一个数值位。也就是字长相同的无符号数比有符号数表示的最大值要大。
3. 无符号数由寄存器的位数反映表示范围。
4. 无符号数通常用于地址运算或表示指针。

### 有符号(整)数

- 将符号数值化，并将符号位放在有效数字的前面，就是<b>有符号数</b>。也就是说，有符号数分为数值和符号两部分，最高位表示符号。
- 在计算机中，带符号整数都是补码表示，表示范围为<code>-2<sup>n-1</sup>~2<sup>n-1</sup>-1</code>。优势如下：

1. 与原码和反码相比，0的补码表示唯一。
2. 与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参加运算。
3. 与原码和反码相比，补码比原码和反码多表示一个最小负数。

### [C语言的整数类型与类型转换](../C/基础配置与语法.md)

# 基本运算部件

## 一位全加器

- 全加器（FA）是最基本的加法单元，有加数A<sub>i</sub>、加数B<sub>i</sub>、低位传来的进位C<sub>i-1</sub>共3个输入，有本位和S<sub>i</sub>、向高位的进位C<sub>i</sub>共2个输出。
- 全加器的逻辑表达式

1. 和表达式：S<sub>i</sub>=A<sub>i</sub>&oplus;B<sub>i</sub>&oplus;C<sub>i-1</sub>
2. 进位表达式：C<sub>i</sub>=A<sub>i</sub>B<sub>i</sub> \+ (A<sub>i</sub>&oplus;B<sub>i</sub>)C<sub>i-1</sub>

<img src="../../pictures/计算机组成原理-FA-locagic.drawio.svg" width="500"/> 

## 串行进位全加器

- 串行进位全加器，把n个全加器相连可得到n位加法器。串行进位（行波进位）的每级进位直接依赖于前一级的进位，即进位信号是逐级形成的。

<img src="../../pictures/计算机组成原理-FA串行进位加法器.drawio.svg" width="600"/> 

-  串行进位加法器实现了两个二进制数A=A<sub>n</sub>A<sub>n-1</sub>...A<sub>1</sub>、B=B<sub>n</sub>B<sub>n-1></sub>...B<sub>1</sub>逐相加的功能，得到的二进制和S=S<sub>n</sub>S<sub>n-1</sub>...S<sub>1</sub>，进位输出C<sub>n</sub>。由于位数有限，高位自动丢失，本质上是模2<sup>n</sup>的加法运算。
-  串行进位加法器的最长运算时间主要由进位信号的传递时间决定，位数越多，延迟越高，低位运算产生进位所需的时间影响高位运算的时间。

## 并行进位加法器

- 令G<sub>i</sub>=A<sub>i</sub>B<sub>i</sub>，P<sub>i</sub>=A<sub>i</sub>&oplus;B<sub>i</sub>，全先行进位加法器的进位表达式C<sub>i</sub>=G<sub>i</sub>\+P<sub>i</sub>C<sub>i-1</sub>，通过CLA部件（先行进位部件、超前进位部件）实现，各个进位都是并行产生的。C<sub>i</sub>仅与A<sub>i</sub>、B<sub>i</sub>、最低进位C<sub>0</sub>有关，相互之间的进位没有依赖关系（与位数无关）。只要A<sub>i</sub>、B<sub>i</sub>、最低进位C<sub>0</sub>都到达即可几乎同时形成C<sub>1</sub>\~C<sub>4</sub>，并同时生成各位的和。

1. G<sub>i</sub>=A<sub>i</sub>B<sub>i</sub>为进位产生函数（本地进位），A<sub>i</sub>与B<sub>i</sub>均为1时，C<sub>i</sub>=1，有进位信号产生。
2. P<sub>i</sub>=A<sub>i</sub>&oplus;B<sub>i</sub>为进位传递函数（进位传递条件），

C<sub>1</sub>=G<sub>1</sub>+P<sub>1</sub>C<sub>0</sub>

C<sub>2</sub>=G<sub>2</sub>+P<sub>2</sub>C<sub>1</sub>=G<sub>2</sub>+P<sub>2</sub>G<sub>1</sub>+P<sub>2</sub>P<sub>1</sub>C<sub>0</sub>

C<sub>3</sub>=G<sub>3</sub>+P<sub>3</sub>C<sub>2</sub>=G<sub>3</sub>+P<sub>3</sub>G<sub>2</sub>+P<sub>3</sub>P<sub>2</sub>G<sub>1</sub>+P<sub>3</sub>P<sub>2</sub>P<sub>1</sub>C<sub>0</sub>

C<sub>4</sub>=G<sub>4</sub>+P<sub>4</sub>C<sub>3</sub>=G<sub>4</sub>+P<sub>4</sub>G<sub>3</sub>+P<sub>4</sub>P<sub>3</sub>G<sub>2</sub>+P<sub>4</sub>P<sub>3</sub>P<sub>2</sub>G<sub>1</sub>+P<sub>4</sub>P<sub>3</sub>P<sub>2</sub>P<sub>1</sub>C<sub>0</sub>

<img src="../../pictures/计算机组成原理-并行进位加法器.drawio.svg" width="600"/> 

<img src="../../pictures/计算机组成原理-并行进位加法器2.drawio.svg" width="600"/> 

## 带标志加法器

1. 溢出标志的逻辑表达式为OF=C<sub>n</sub>&oplus;C<sub>n-1</sub>
2. 符号标志就是和的符号SF=F<sub>n-1</sub>
3. 零标志ZF=1，当且仅当F=0
4. 进位/借位标志CF=C<sub>out</sub>&oplus;C<sub>in</sub>，即C<sub>in</sub>=0时，CF为进位C<sub>out</sub>；C<sub>in</sub>=1时，CF为进位C<sub>out</sub>取反

<img src="../../pictures/计算机组成原理-带标志加法器.drawio.svg" width="800"/> 

## ALU 算术逻辑单元

- [ALU](./组成原理概述.md)能进行多种算术运算和逻辑运算（包括移位操作），核心是带标志加法器（所有加减乘除运算都能最终归结为加法运算）。

1. A、B是两个n位操作数输入端
2. C<sub>in</sub>是进位输入端
3. ALU<sub>op</sub>是操作控制端，决定ALU执行的处理功能，其位数决定了操作的种类数量。

<img src="../../pictures/计算机组成原理-ALU基本结构.drawio.svg" width="700"/> 