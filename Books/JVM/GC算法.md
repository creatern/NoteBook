# 标记阶段

- 垃圾标记阶段：对象存活判断。
- 死亡对象：一个对象不再被任何的存活对象引用。

## 引用计数算法

> Java未采用引用计数算法。
>
> Python采用引用计数算法，解决：手动解除、弱引用（weakref）。

- 引用计数算法（Reference Counting）：对对象保存一个整型的引用计数器属性，记录对象被引用的情况。对一个对象，只要有任何一个对象引用了该对象，则该对象的引用计数器+1；当引用失效，引用计数器-1。当该对象的引用计数器=0，表示该对象不可能再被使用，可进行回收。

| 分析 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 优点 | 1. 实现简单，垃圾对象便于辨识。<br />2. 判定效率高，回收没有延迟性。 |
| 缺点 | 1. 存储空间开销：单独的字段存储计数器。<br />2. 时间开销：每次赋值都需要更新计数器。<br />3. 无法处理循环引用。 |

- 循环引用问题：相互引用，导致内存泄漏。

<img src="../../pictures/JVM-循环引用导致内存泄漏.svg" width="600"/> 

## 可达性分析算法 GC Roots

- 可达性分析算法（根搜索算法、追踪性垃圾收集）（Tracing Garbage Collection ），必须在一个能保障一致性的快照中进行，导致GC进行时必须“Stop The World“。

> 即使是CMS收集器也必须在枚举根节点时停顿。

- 根对象集合（GC Roots）：一组必须活跃的引用。

1. 以根对象集合为起始点，从上到下搜索被根对象集合所连接的目标对象是否可达。
2. 引用链：搜索所经过的路径，可达性分析之后，内存中的存活对象都被根对象集合直接/间接连接。
3. 如果对象没有任何的引用链（不可达），则对象死亡，标记为垃圾对象。

<img src="../../pictures/JVM-GCRoots.svg" width="500"/> 

- 固定的GC Roots集合包括：
  - 虚拟机栈中引用的对象。
  - 本地方法栈内JNI引用的对象。
  - 方法区中类属性引用的对象。
  - 方法区中常量引用的对象。
  - 所有被同步锁sychronized持有的对象。
  - JVM内部的引用：基本数据类型对应的Class对象、一些常驻的异常对象、系统类加载器。
  - 反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
- 临时性加入的GC Roots：根据用户所选用的垃圾收集器以及当前回收的内存区域的不同，可以有其他对象临时性的加入GC Roots集合。（分代收集、局部回收Partial GC）

> 如果只针对Java堆中的某一块区域进行垃圾回收，必须考虑到内存区域是JVM自身的实现细节，更不是独立封闭的，该区域的对象完全有可能被其他区域的对象所引用（如：新生代的对象被老年代的对象引用），此时，需要一并将关联的区域对象也加入到GC Roots中考虑。

## 对象终止机制 finalization

- 对象终止机制（finalization）：对象被销毁之前的自定义处理逻辑。
- Object\#finalize()：垃圾回收时，由垃圾回收器在对象上调用，只会被调用一次。

1. 可能导致对象的复活。
2. 执行时间没有保障，完全由GC线程决定，低优先级的Finalizer线程。

```java
protected void finalize() throws Throwable { }
```

- JVM中的对象一般处于3种可能的状态：只有在不可触及状态下才可以被回收。

| 状态     | 说明                                                       |
| -------- | ---------------------------------------------------------- |
| 可触及   | 从根节点开始，可以到达该对象。                             |
| 可复活   | 对象的所有引用都被释放，但该对象可能在finalize()复活。     |
| 不可触及 | 对象的finalize()被调用，且该对象没有复活。（不可能被复活） |

- 判断一个对象是否可回收，至少经过两次标记过程：

1. 如果该对象到GC Roots没有引用链，则进行第一次标记。
2. 筛选，判断该对象是否有必要执行finalize()：
   1. 如果该对象没有重写finalize()、finalize()已经被JVM调用过：没有必要执行，该对象被判断为不可触及。
   2. 如果该对象重写了finalize()、且还未被JVM调用过：将该对象插入到F-Queue队列，由一个JVM自动创建的、低优先级的Finalizer线程触发执行。
   3. finalize()是对象逃脱死亡的最后机会，之后GC会对F-Queue中的对象进行第二次标记。如果该对象在finalize()中与引用链上的任何一个对象建立了联系，则第二次标记时，该对象被移出“即将回收”集合。否则被判断为不可触及。
   4. 之后，如果该对象再次出现没有引用存在的情况，finalize()不会被调用，直接判断为不可触及。

<img src="../../pictures/JVM-finalize执行判断.svg" width="600"/> 

# 清除阶段

## 标记-清除算法 Mark-Sweep

- 标记-清除算法：当堆中的有效内存空间（available memory）被耗尽，Stop The World，然后进行以下：

1. 标记：Collector从引用根节点开始遍历，标记所有被引用的对象（对象Header中记录为可达对象的）。
2. 清除：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象的Header没有标记为可达对象，则将其回收。并非置空，而是将需要清除的对象地址保存在空闲列表中，当有新对象需要加载时，判断垃圾的位置空间是否足够，如果足够，则覆盖。

- 缺陷：效率不算高、STW、清理的空间内存是不连续的，产生内存碎片，需要维护一个空闲列表。

## 复制算法

- 复制算法：将活着的内存空间分为两块，每次只使用其中一块。在垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
- 复制算法理想情况：垃圾对象多，而复制的存活对象应尽量少。

> Survivor0、Survivor1使用的是复制算法。

<img src="../../pictures/JVM-复制算法survivor.svg" width="500"/> 

| 比较 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 优点 | 1. 没有标记-清除，运行高效。<br />2. 空间连续性，避免碎片问题。 |
| 缺点 | 1. 2倍的内存空间。 <br />2. 对于G1（分拆为大量region的GC），复制-移动的过程地址改变，GC需要维护region之间的对象引用关系，开销大。 |

## 标记-压缩（整理）算法  Mark-Compact

- Mark-Compact（ Mark-Sweep-Compact）：

1. 标记：从引用根节点开始遍历，标记所有被引用的对象。
2. 压缩：将所有的存活对象压缩到内存的一端，按顺序存放，之后清除边界外的所有空间。

| 比较 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 优点 | 对标记-清除算法、复制算法的优化。<br />1. 标记清除算法：内存区域分散的缺点。标记-压缩算法分配新对象时，JVM只需持有一个内存的起始地址。<br />2. 复制算法中：内存减半的代价。 |
| 缺点 | 1. 效率低于复制算法。 <br />2. 移动对象的同时，如果对象被其他对象引用，则需要调整引用的地址。<br />3. STW。 |

| 比较     | 标记-清除        | 标记-压缩          | 复制算法                              |
| -------- | ---------------- | ------------------ | ------------------------------------- |
| 速度     | 中               | 慢                 | 快                                    |
| 移动对象 | 否               | 是                 | 是                                    |
| 空间开销 | 少<br />堆积碎片 | 少<br />不堆积碎片 | 需要存活对象的2倍空间<br />不堆积碎片 |

## 分代收集算法

- 分代收集算法：不同生命周期的对象采取不同的收集方式。
- 年轻代（Young Gen）：区域较小、对象生命周期短、存活率低、回收频繁。
  - 复制算法：survivor1、survivor2。
- 老年代（Tenured Gen）：区域较大、对象生命周期长、存活率高、回收不如年轻代频繁。
  - 标记-清除、标记-整理的混合实现：
    - Mark：开销和存活对象数量成正比。
    - Sweep：开销和所管理区域大小成正比。
    - Compact：开销和存活对象数量成正比。

> Hotspot的CMS回收器：CMS基于Mark-Sweep实现，对象的回收率高。
>
> - 碎片问题：CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿。当内存回收不佳时（碎片导致的Concurrent Mode Failure），采用Serial Old执行Full GC以达到对老年代内存的整理。

## 增量收集算法

- 增量收集算法：每次垃圾收集线程只收集一小片的内存空间，垃圾收集线程和应用程序线程交替执行、直到垃圾收集完成。
  - 对线程间冲突的处理：允许垃圾收集线程以分阶段的方式完成工作。
  - 切割STW的停顿时间。
- 缺陷：线程切换、上下文转换的消耗导致垃圾回收的总体成本上升，造成系统吞吐量下降。

## 分区算法

- 分区算法：将整个堆空间划分成连续的不同小区间，根据目标停顿时间，每次合理地回收若干个小区间。

> 一般情况下，在相同条件下，堆空间越大，一次GC所需要的时间就越长，有关GC产生的停顿也越长。

> 分代算法：按对象生命周期划分。

