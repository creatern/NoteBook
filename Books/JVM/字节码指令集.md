# 字节码指令集与解析 概述

- 字节码指令（byte code）：JVM的指令由一个字节长度的、代表某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表次操作所需参数的操作数（operand）所构成。
  - JVM基于栈（操作数栈）：大多数指令不包含操作数。
  - 操作码的长度为1Byte（0\~255），指令集的操作码总数不得超过256 。
- 执行模型：

```java
do{
    自动计算PC寄存器的值+1;
    根据PC寄存器的指示位置，从字节码流中取出操作码;
    if(字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作;
}while(字节码长度 > 0)
```

- 操作码分类：

1. 与数据类型相关。
2. 没有明确指明操作类型的字母。
3. 与数据类型无关的。

| 操作码助记符<br />（数据类型相关） | 数据类型 |
| ---------------------------------- | -------- |
| i                                  | int      |
| l                                  | long     |
| s                                  | short    |
| b                                  | byte     |
| c                                  | char     |
| f                                  | float    |
| d                                  | double   |

- 大多数对于boolean、byte、short、char类型数据的操作使用相应的int类型作为运算类型：大部分的指令不支持整数类型 byte、char、short，甚至没有指令支持boolean类型。编译器在编译期/运行期将byte、short类型的数据带符号扩展为相应的int类型（Sign-Extend），将boolean、char零位扩展为相应的int类型（Zero-Extend）。

- 字节码指令按用途分类：

1. 加载与存储指令。
2. 算术指令。
3. 类型转换指令。
4. 对象的创建与访问指令。
5. 方法调用与返回指令。
6. 操作数栈管理指令。
7. 比较控制指令。
8. 异常处理指令。
9. 同步控制指令。

# 加载和存储指令

- 加载和存储指令：将数据从栈帧的局部变量表和操作数栈之间来回传递。

<img src="../../pictures/JVM-加载和存储指令.drawio.svg" width="400"/> 

| 常用指令                       | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 局部变量压栈指令               | `xload`<br />`xload_<n>`：x（i、l、f、d、a），n（0\~3）      |
| 常量入栈指令                   | bipush<br />sipush<br />ldc<br />ldc_w<br />ldc2_w<br />aconst_null<br />iconst_m1<br />`iconst_<i>`<br />`lconst_<l>`<br />`fconst_<f>`<br />`dconst_<d>` |
| 出栈装入局部变量表指令         | xstore<br />`xstore_<n>`：x（i、l、f、d、a），n（0\~3）<br />xastore：x（i、l、f、d、a、b、c、s） |
| 扩充局部变量表的访问索引的指令 | wide                                                         |

- 对于表面上没有出操作数的指令，不需要进行取操作数的动作，其操作数隐含在指令中。

> 将局部变量表中索引为0位置上的数据压入操作数栈：
>
> iload\_0：只有操作码，只要1B空间。
> iload 0：操作码+操作数，需要2B空间。

- 操作数栈（Operand Stacks）：执行每一条指令之前，JVM要求该指令的操作数已经被压入操作数栈中。在执行指令时，JVM会将该指令所需的操作数弹出，并且将该指令的结果重新压入栈中。

<img src="../../pictures/操作数栈字节码指令执行过程.gif" width="600"/> 

- 局部变量表（Local Variables）：字节码程序将计算的结果缓存在局部变量表中。JVM实际上将局部变量表当作数组，依次存放this指针（非静态方法）、所传入的参数、字节码中的局部变量。
  - long、double占用2个Slot，1个Slot占4Byte。

<img src="../../pictures/JVM-LocalVariables-Slot-long-double.drawio.svg" width="1200"/> 

## 局部变量压栈指令

| 指令        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `xload_<n>` | 向操作数栈压入局部变量表中第n个索引位置的操作数<br />n一般预定义为0\~3 |
| `xload`     | 向操作数栈压入局部变量表中第n个索引位置的操作数              |

<img src="../../pictures/JVM-Xload_LocalVariables.drawio.svg" width="1200"/> 

## 常量入栈指令

- 常量入栈指令：将常数压入操作数栈。根据数据类型、入栈内容不同，分为const系列、push系列、ldc系列指令。

| const指令     | 范围          | 对特定常量入栈，入栈的常量隐含在指令本身                     |
| ------------- | ------------- | ------------------------------------------------------------ |
| iconst\_\<n\> | \-1\~5        | iconst\_m1：将-1压入操作数栈。<br />iconst\_1：将1压入操作数栈。 |
| lcons\_\<n\>  | 0\~1          | lconst\_0：将长整数0压入操作数栈。<br />lconst\_1：将长整数1压入操作数栈。 |
| fconst\_\<n\> | 0\~2          | fconst\_0 ：将浮点数0压入操作数栈。<br />fconst\_1 ：将浮点数1压入操作数栈。<br />fconst\_2 ：将浮点数2压入操作数栈。 |
| dconst\_\<n\> | 0\~1          | fconst\_0 ：将双精度数0压入操作数栈。<br />fconst\_1 ：将双精度数1压入操作数栈。 |
| aconst\_null  | null          | 将null压入操作数栈                                           |
| **push指令**  | **范围**      | **将参数压入栈，接收数据类型：int、short、byte**             |
| bipush        | -128\~127     | 8位整数                                                      |
| sipush        | -32768\~32767 | 16位整数                                                     |
| **ldc指令**   | **范围**      | **将指定的内容压入堆栈。**                                   |
| ldc           |               | 接收一个8位参数（int、float、String）。<br />该参数指向常量池中的int、float、String的索引 |
| ldc\_w        |               | 接收两个8位参数（int、float、String）。                      |
| ldc2\_w       | -             | 接收两个8位参数（long、double）。                            |

> iconst 6：错误（超过范围），应该为：bipush 6

## 出栈装入局部变量表指令

| store指令     | 将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量表赋值。 |
| ------------- | ------------------------------------------------------------ |
| xstore        | 没有隐含参数信息，需要提供一个byte类型参数指定目标局部变量表中的位置。 |
| xstore\_\<n\> | x：i、l、f、d、a<br />n：0\~3<br />istore\_n：从操作数栈中弹出一个整数，并将其赋值给局部变量表中索引n位置。 |
| xastore       | x：i、l、f、d、a、b、c、s                                    |

<img src="../../pictures/JVM-xstore_n.drawio.svg" width="700"/> 

# 算术指令

## 算术指令

- 算术指令：对操作数栈上的两个值进行某种特定运算，并将结果重新压入操作数栈。

| 实际类型      | 运算类型      |
| ------------- | ------------- |
| boolean、char | int           |
| short、byte   | int           |
| int           | int           |
| float         | float         |
| reference     | reference     |
| returnAddress | returnAddress |
| long          | long          |
| double        | double        |

- 运算时的溢出：AirthmeticException（除数为0）。

| 运算模式          | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| 向最接近数舍入    | 浮点数运算时，所有的运算结果必须舍入到适当的精度，非精度结果必须舍入为可被表示的最接近的精确值。如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为0的。 |
| 向零舍入（floor） | 将浮点数转换为整数时，将在目标数值类型中选择一个最接近，且不大于原值的数字作为最精确的舍入结果。 |

- NaN：没有明确的数学定义的操作结果。

```java
double x = 10 / 0; //AirthmeticException
double y = 10 / 0.0; //Infinity
double z = 0.0 / 0.0; //NaN
```

| 类型     | 算术指令                            |
| -------- | ----------------------------------- |
| 加法指令 | iadd、ladd、fadd、dadd              |
| 减法指令 | isub、lsub、fsub、dsub              |
| 乘法指令 | imul、lmul、fmul、dmul              |
| 除法指令 | idiv、ldiv、fdiv、ddiv              |
| 求余指令 | irem、lrem、frem、drem              |
| 取反指令 | ineg、lneg、fneg、dneg              |
| 自增指令 | iinc（`iinc 局部变量表索引 by 值`） |

> short、byte等类型，short以int类型在进行自增时，最后需要将结果转回short（i2s），故没有使用iinc，而是iadd。
>
> ```java
> short i = 0;
> while(i < 100){
> i++;
> }
> ```

<img src="../../pictures/JVM-运算指令++.drawio.svg" width="1200"/>

## 位运算指令

| 类型       | 位运算指令                               |
| ---------- | ---------------------------------------- |
| 位移指令   | ishl、ishr、iushr<br />lshl、lshr、lushr |
| 位或指令   | ior、lor                                 |
| 位与指令   | iand、land                               |
| 位异或指令 | ixor、lxor                               |

<img src="../../pictures/JVM-ixor_code.drawio.png" width="600"/> 

## 比较指令

| 比较指令         | 从栈中弹出两个操作数用于比较，将比较结果入栈（int）          |
| ---------------- | ------------------------------------------------------------ |
| fcmpg<br />fcmpl | 若a==b，则压入0；若a&gt;b，则压入1；若a&lt;b，则压入-1。（a先压入，b在栈顶）<br />遇到NaN时，fcmpg指令压入1，而fcmpl指令压入-1。 |
| dcmpg<br />dcmpl | dcmpg指令和dcmpl指令同理fcmpl指令、fcmpg指令。               |
| lcmp             | long类型整数没有NaN，故只需要lcmp指令。                      |

> 只有数值类型才能用于比较指令比较大小，boolean、引用数据类型不能用于比较指令比较大小。

# 类型转换指令

- 类型转换指令：将两种不同的数值类型进行相互转换。

1. 显示类型转换。
2. 处理字节码指令集中数据类型相关指令无法与数据类型一一对应问题。

## 宽化类型转换

- 宽化类型转换（widening numeric conversion）：小范围类型至大范围类型的安全转换（不需要指令执行）。

| 转换类型         | 目标类型                    | 指令                  |
| ---------------- | --------------------------- | --------------------- |
| int、short、byte | long<br />float<br />double | i2l<br />i2f<br />i2d |
| long             | float<br />double           | l2f<br />l2d          |
| float            | double                      | f2d                   |

- int --> long --> float --> double。

- 精度损失问题：（JVM不抛出异常）

  - 宽化类型转换不会因为超过目标类型最大值而丢失信息。
  - int/long-->float、long-->double，可能会发生精度丢失（丢失几位最低位的数值），转换后的浮点数构建IEEE754最接近舍入模式所得到的正确整数值。

```java
float f = 123123123; //1.2312312E8：即123123120
double d = 123123123123123123L; //1.2312312312312312E17：即123123123123123120
```

- byte、char、short不存在到int的宽化类型转换：byte、short被JVM看作int处理。

<img src="../../pictures/JVM-宽化类型转换.drawio.svg" width="300"/> 

## 窄化类型转换

| 转换类型 | 目标类型                  | 指令                  |
| -------- | ------------------------- | --------------------- |
| int      | byte<br />short<br />char | i2b<br />i2s<br />i2c |
| long     | int                       | l2i                   |
| float    | int<br />long             | f2i<br />f2l          |
| double   | int<br />long<br />float  | d2i<br />d2l<br />d2f |

<img src="../../pictures/JVM-窄化类型转换-float2byte.drawio.svg" width="1200"/>

- 精度损失问题：（JVM不抛出异常）可能导致转换结果具备不同的正负号、不同的数量级。
  - 上限溢出、下限溢出、精度丢失。

```java
short s = 128;
byte b = (byte)s;
System.out.println(b); //-128
```

- 浮点数（float/double）转换为整数（int/long）：

1. 如果浮点值为NaN：转换结果为int/long的0。
2. 如果浮点值不是无穷大：使用IEEE754的向零舍入模式取整，获得整数值。如果该整数值在目标类型（int/long）表示范围内，则转换结果为该整数值；否则，根据该整数值的符号，转换为目标类型（int/long）所能表示的最大/最小正数。
3. 如果是double/float的最大值/最小值则转换为int/long中的最大值/最小值。

- double窄化转换为float：向最接近舍入模式舍入一个可使用float表示的数字。

1. 如果转换结果的绝对值太小而无法用float表示：返回float的正负0。

2. 如果转换结果的绝对值太大而无法用float表示：返回float的正负无穷大。

3. double类型的NaN值：按规定转换为float类型的NaN值。

# 对象的创建与访问指令

## 创建指令

- 创建指令：JVM对类实例、数组的创建与操作使用不同的字节码指令。

| 类型   | 创建指令                                    | 说明                                                         |
| ------ | ------------------------------------------- | ------------------------------------------------------------ |
| 类实例 | new                                         | 接收一个指向常量池索引的操作数，表示要创建的类型。<br />执行完毕后，将对象的引用压入栈。 |
| 数组   | newarray<br />anewarray<br />multianewarray | 基本类型数组<br />引用类型数组<br />多维数组                 |

<img src="../../pictures/JVM-newarray-数组.drawio.svg" width="600"/> 

## 字段访问指令

| 字段类型         | 指令                     |
| ---------------- | ------------------------ |
| 类字段（static） | getstatic<br />putstatic |
| 类实例字段       | getfield<br />putfield   |

<img src="../../pictures/Snipaste_2023-06-20_21-46-29.png" width="1200"/>

## 数组操作指令

| 数组操作指令                        | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| xaload<br />（数组的加载指令）      | 将一个数组元素加载到操作数栈。<br />执行时，要求操作数中栈顶元素为数组索引i、栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶的这两个元素，并将a\[i\]重新压入堆栈中。 |
| xastore<br />（数组的存储指令）     | 将一个操作数栈的值存储到数组元素中，给一个指定类型的数组的给定索引赋值。<br />在执行前，操作数栈需要准备3个元素：值、索引、数组引用，之后该指令会弹出这3个元素，并将值赋给数组中指定索引的位置。 |
| arraylength<br />（取数组长度指令） | 弹出栈顶的数组元素，获取数组的长度，将长度压入栈。（`aload_<n>，arraylength`） |

| 数组类型          | 加载指令 | 存储指令 |
| ----------------- | -------- | -------- |
| byte<br />boolean | baload   | bastore  |
| char              | caload   | castore  |
| short             | saload   | sastore  |
| int               | iaload   | iastore  |
| long              | laload   | lastore  |
| float             | faload   | fastore  |
| double            | daload   | dastore  |
| reference         | aaload   | aastore  |

<img src="../../pictures/JVM-数组操作指令.drawio.svg" width="1200"/>

## 类型检查指令

| 指令       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| instanceof | 判断给定的对象是否为某一个类的实例，将判断结果压入操作数栈。 |
| checkcast  | 检查类型强转是否可以进行。<br />如果可以，该指令不会改变操作数栈，否则抛出ClassCastException。 |

<img src="../../pictures/Snipaste_2023-06-20_21-40-50.png" width="600"/> 

# 方法调用与返回指令

## 方法调用指令

| 方法调用指令    | 调用               | 说明                                                         |
| --------------- | ------------------ | ------------------------------------------------------------ |
| invokevirtual   | 对象的实例方法     | 根据对象的实际类型反派（虚方法分派）<br/>支持多态（可重写）。 |
| invokeinterface | 接口方法           | 运行时搜索实现的接口方法，找出合适的方法进行调用。<br />接口的default方法也算是invokeinterface。 |
| invokespecial   | 特殊处理的实例方法 | 静态类型绑定（非重写），不会在调用时进行动态派发。<br/>构造器（\<init\>）、私有方法（private）、父类方法（super）。 |
| invokestatic    | 类方法             | 静态绑定（非重写）。<br />通过类调用的方法，也算是invokestatic（即使满足invoke(special/interface)）。 |
| invokedynamic   | 动态绑定的方法     | 运行时动态解析出调用点限定符所引用的方法，并执行。<br/>该指令的分派逻辑由用户设定的引导方法决定。 |

<img src="../../pictures/JVM-invokeinterface-virsual.drawio.svg" width="800"/> 

## 方法返回指令

- 方法返回指令：根据返回值的类型区分。

| 方法返回指令 | 以方法声明中的返回值类型为准      |
| ------------ | --------------------------------- |
| ireturn      | boolean、byte、char、short、int。 |
| lreturn      | long                              |
| freturn      | float                             |
| dreturn      | double                            |
| areturn      | reference                         |
| return       | void、\<init\>、\<clinit\>        |

1. 返回指令：将当前方法操作数栈的栈顶元素弹出，压入调用者方法的操作数栈；当前方法操作数栈的其他元素都被丢弃。

2. 如果当前返回的是synchronized方法，则执行一个隐含的monitorexit指令，退出临界区。

3. 最终，丢弃当前方法的整个帧，恢复调用者的帧，将控制权交给调用者。

# 操作数栈管理指令

| 操作数栈管理指令                                      | 通用型指令：对栈的压入、弹出无需指明数据类型。               |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| pop<br/>pop2                                          | 将1、2个元素从栈顶弹出，并直接废弃。                         |
| dup、dup2<br/>dup\_x1、dup2\_x1<br/>dup\_x2、dup2\_x2 | 复制栈顶的1、2个数值，将复制值重新压入栈顶。<br/>\_x1、\_x2：插入栈的位置（dup和\_x的系数相加）。 |
| swap                                                  | 将栈顶的两个Slot数值位置交换。<br/>JVM不提供double、long的交换。 |
| nop                                                   | 字节码：0x00。<br/>无作用：调试、占位。                      |

> 插入位置：
>
> - dup_x1：1+1，栈顶2个Slot下方。
>
> - dup_x2：1+2，栈顶3个Slot下方。
>
> - dup2_x1：2+1，栈顶3个Slot下方。
>
> - dup2_x2：2+2，栈顶4个Slot下方。

<img src="../../pictures/20230713093604.png" alt="" width="599"> 

<img src="../../pictures/操作数栈管理指令.gif" alt="" width="679"> 

# 控制转移指令

1. 条件跳转指令
2. 比较条件跳转指令
3. 多条件分支指令
4. 无条件指令

> 比较指令属于算术指令。

## 条件跳转指令

- 条件跳转指令：弹出栈顶元素，测试是否满足条件，若满足，则跳转到指定位置。通常结合比较指令（准备栈顶元素）使用，接受2字节的操作数，用于计算跳转的位置（16位带符号整数作为当前位置的offset）。

> 若只是两个int、short、byte、ref类型的数据入栈，则不需要比较指令和条件跳转指令，而是直接通过比较条件跳转指令来计算跳转的位置。

| 条件跳转指令 | 满足条件：栈顶int类型数值 |
| ------------ | ------------------------- |
| ifeq         | =0                        |
| ifne         | &ne;0                     |
| iflt         | &lt;0                     |
| ifle         | &le;0                     |
| ifgt         | &gt;0                     |
| ifge         | &ge;0                     |
| ifnull       | null                      |
| ifnonull     | 不为null                  |

<img src="../../pictures/JVM-条件跳转指令if.drawio.svg" width="1200"/> 

## 比较条件跳转指令

- 比较条件跳转指令：将比较和跳转两个步骤结合。接收2字节的操作数作为参数，用于计算跳转的位置。在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被消耗，且没有数据入栈。若预设条件成立，则执行跳转。

| 比较条件跳转指令                  | int、byte、short、ref |
| --------------------------------- | --------------------- |
| **比较栈顶两个int类型数值的大小** | **跳转条件**          |
| if\_icmpeq                        | 前者=后者             |
| if\_icmpne                        | 前者&ne;后者          |
| if\_icmplt                        | 前者&lt;后者          |
| if\_icmple                        | 前者&le;后者          |
| if\_icmpgt                        | 前者&gt;后者          |
| if\_icmpge                        | 前者&ge;后者          |
| **比较栈顶两个引用类型数值**      | **跳转条件**          |
| if\_acmpeq                        | 前者=后者             |
| if\_acmpne                        | 前者&ne;后者          |

## 多条件分支跳转指令

| 多条件分支跳转指令 | 用于switch的条件跳转的区别                                   |
| ------------------ | ------------------------------------------------------------ |
| tableswitch        | case值连续，内部只存放起始值、终值、若干个偏移量，由指定的操作数index，可立即定位到跳转偏移量位置，效率高。 |
| lookupswitch       | case值不连续，内部存放各个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转位置，效率低。<br />将case-offset对按照case值的大小进行排序。 |

<img src="../../pictures/JVM-多分支条件跳转指令-switch-case.drawio.svg" width="600"/> 

<img src="../../pictures/JVM-多条件分支跳转指令-switch-case-String.drawio.svg" width="800"/> 

## 无条件跳转指令

- 无条件跳转指令：goto指令接收2字节的操作数共同组成一个带符号整数，用于指定指令的偏移量，指令执行的目的是跳转到偏移量指定的位置。若偏移量过大（超过2字节带符号整数的范围），则使用指令goto\_w（接收4字节的操作数）。

> jsr、jsr\_w、ret也是无条件跳转，主要用于try-catch-finally语句，已经被JVM逐渐废弃。

# 异常处理指令

| 异常机制                                | 指令和处理 |
| --------------------------------------- | ---------- |
| 异常对象的生成：throw（手动、自动）     | athrow     |
| 异常处理：抓抛模型（try-catch-finally） | 异常表     |

## 抛出异常指令 athrow

- 抛出异常指令（athrow）：Java中显式抛出异常（throw）都是由athrow指令实现的。JVM规范规定，大部分的运行时异常会在其他JVM指令检测到异常状况时自动抛出（而不会在字节码中写出）。在抛出异常时，JVM会清除操作数栈上的所有内容，之后将异常实例压入调用者操作数栈。

<img src="../../pictures/JVM-athrow手动-自动.drawio.svg" width="800"/> 

## 异常处理与异常表

- 异常表：若一个方法定义了一个try-catch-fianally的异常处理，则创建一个异常表，包含每个异常处理、finally块的信息（起始位置、结束位置、程序计数器记录的代码处理的偏移位置、被捕获的异常类在常量池中的索引）。
- 当一个异常被抛出时，JVM会在当前方法中寻找匹配的处理。若没有找到，则强制结束该方法、弹出当前栈帧，并且异常重新抛给上层调用者（的栈帧）。若在所有栈帧弹出前仍然没有找到合适的异常处理，则该线程将终止。若该异常在最后一个非守护线程（比如main线程）抛出，则导致JVM自己终止。不管什么时候抛出异常，若异常最终匹配了所有异常类型，则代码继续执行，此时，若方法结束后没有再次抛出异常，在return之前，直接跳转到finally块继续执行。

<img src="../../pictures/JVM-异常表-异常处理.drawio.svg" width="1200"/>

<img src="../../pictures/JVM-try-finally的修改.drawio.svg" width="560"/> 

# 同步控制指令

- JVM支持两种同步结构：方法级的同步、方法内部一段指令序列的同步，都是使用monitor支持的。

## 方法级的同步

- 方法级的同步：隐式的，无须通过字节码指令控制，实现在方法调用和返回操作之间。JVM可以从常量池的方法表结构中的ACC\_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法，若是，则JVM自动在方法调用前进行加锁。

> 调用方法时，调用指令会检查方法的ACC\_SYNCHRONIZED访问标志是否设置。若设置，则执行线程先持有同步锁，再执行方法，最后在方法完成（正常、非正常）时释放同步锁。在方法执行期间，执行线程拥有同步锁，而其他线程都无法再获得同一个锁。若一个同步方法在执行期间抛出异常，且方法内部无法处理此异常，则该同步方法所持有的锁将在异常抛出到同步方法之外时自动释放。

## 方法内指定指令序列的同步

- 当线程进入同步代码块时，使用monitorenter指令请求进入。若当前对象的监视器计数器为0，则其被允许进入；若为1，则判断持有当前监视器的线程是否为该线程，若是，则进入，否则进行等待，直到对象的监视器计数器为0时，才被允许进入。
- 当线程退出同步代码块时，使用monitorexit声明退出。JVM中的任何对象都有一个监视器与之相关联，用于判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。
- 指令monitorenter、指令monitorexit在执行时，都需要再操作数栈顶压入对象，之后指令monitorenter和指令monitorexit的锁定与释放都是针对该对象的监视器进行的。

<img src="../../pictures/JVM-同步控制指令-monitor.drawio.svg" width="800"/> 

