# 类的加载过程概述

<img src="../../pictures/Snipaste_2023-05-18_22-07-39.png" width="800"/> 

<img src="../../pictures/JVM-Page-33.drawio.svg" width="1000"/> 

# 加载阶段 Loading

- Loading（加载）：将字节码文件加载到机器内存，并在内存中构建出类模板对象（Java类的原型、内存中的快照）。JVM把从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，以便JVM在运行期（反射）通过类模板获取Java类中的任意信息、对成员变量进行遍历、方法调用。

1. 由类的全名获取该类的二进制数据流。

> 加载.class文件的方式：从本地系统中获取、通过网络获取（Web Applet）、从zip压缩包中读取（jar、war格式）、动态代理技术、其他文件生成（JSP）、从专有数据库提取、从加密文件中获取（防止.class文件被反编译的保护措施）。

2. 解析类的二进制数据为方法区（JDK1.8之前是永久代，JDK1.8之后是元空间）内的数据结构（类模板）。

> 若输入数据不是JVM规范的class文件，则抛出ClassFormatError。

3. 在堆中创建java.lang.Class实例封装该类位于方法内的数据结构。

> java.lang.Class的构造方法是私有的，只有JVM能够构造。
>
> java.lang.Class的实例是访问类型元数据的入口、实现反射的关键数据，通过该类提供的接口来获得目标类所关联的class文件中具体的信息。

<img src="../../pictures/JVM-class-loading-location.drawio.svg" width="300"/> 

- 数组类：由JVM在运行时根据需要直接创建，没有对应的class文件、二进制数据流，无法通过类加载器创建数组类。（数组的元素类型仍然是依靠类加载器创建的）

| 数组的元素类型 | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 引用类型       | 遵循定义的加载过程递归加载和创建数组的元素类型，JVM使用指定的元素类型和数组维度来创建新的数组类。<br />可访问性由元素类型的可访问性决定。 |
| 基本数据类型   | 基本数据类型由JVM预先定义（不需要类加载），只需要关注数组维度。<br />可访问性被缺省定义为public。 |

# 链接阶段 Linking

## 验证 Verification

- 验证：确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

> 文件格式验证、元数据验证、字节码验证、符号引用验证。

<img src="../../pictures/JVM-Linking-Verifaction.drawio.svg" width="800"/> 

## 准备 Preparation

- 准备（Preparation）：为类变量分配内存并设置默认初始值（零值）。

> 与初始化阶段不同，没有涉及初始化代码的执行。

1. 不包含 static final 修饰的：final在编译时就分配，准备阶段会显式初始化。

2. 不会为实例变量分配初始化：类变量会分配在方法区中，而实例变量随着对象分配到Java堆中。

| 数据类型  | 默认初始化值 |
| --------- | ------------ |
| byte      | (byte)0      |
| short     | (short)0     |
| int       | 0            |
| long      | 0L           |
| float     | 0\.0f        |
| double    | 0\.0         |
| char      | \\u0000      |
| boolean   | false        |
| reference | null         |

> java并不直接支持boolean类型，其boolean类型的内部实现是int。

```java
private static int a = 1; //准备环节，默认初始化为0。
private static final int b = 1; //准备环节，显式初始化为1。ConstantValue
//private fianl int b = 1; 也是显式初始化为1。ConstantValue

private static final String str1 = "Hello"; //准备环节，String以字面量的方式显式初始化。ConstantValue
private static final String str2 = new String("Hellp"); //在<clinit>中进行初始化。
```

<img src="../../pictures/20231024100024.png" width="800"/> 

> ConstantValue：显式初始化（常量）。

## 解析 Resolution

- 解析：将常量池中的符号引用转化为直接引用。

> JVM规范中并没有要求解析阶段一定要按顺序执行，但解析往往伴随着JVM在执行完初始化之后再执行。

> 只要存在直接引用，则一定存在该类、方法、字段；而若只存在符号引用，则不确定。

| 引用类型 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 符号引用 | 一组符号描述所引用的目标，与JVM的内部数据结构和内存布局无关。 |
| 直接引用 | 目标方法在类中方法表的位置，直接执行目标的指针、相对偏移量、一个间接定位到目标的句柄。 |

> 解析主要针对：类、接口、字段、类方法、接口方法、方法类型等。
>
> 对应常量池：CONSTANT\_Class\_info、CONSTANT\_Fieldref\_info、CONSTANT\_Methodref\_info等。

# 初始化阶段 Initialization

- 初始化（Initialization）：JVM真正执行类中定义的Java代码，执行类构造器方法\<clinit\>\(\)。

> \<clinit\>\(\)不同于类的构造器：构造器是虚拟机视角下的\<init\>\(\)。

- \<clinit\>\(\)方法只能由Java编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句生成（指令按语句在源文件中出现的顺序执行）。（无法自定义该同名方法，也不能由我们调用）
- 在加载一个类之前，JVM总会试图加载该类的父类，JVM保证父类的\<clinit\>\(\)方法先于子类的\<clinit\>\(\)方法执行。（父类的static块优先于子类）
- Java编译器并不会为所有的类都产生\<clinit\>()方法，在以下情况中，class文件将不包含\<clinit\>()方法：

1. 该类没有声明任何类变量，没有静态代码块。
2. 该类声明了类变量，但没有显式赋值（使用类变量的初始化语句和静态代码块来执行初始化操作）。
3. 该类中static final修饰的基本数据类型的字段（包括字面量赋值的String），也不会加入到\<clinit\>\(\)方法。

> 引用数据类型（以及new的String），则在\<clinit\>()中进行初始化。

```java
private static final String str1 = "Hello"; //准备环节，String以字面量的方式显式初始化。ConstantValue
private static final String str2 = new String("Hellp"); //在<clinit>()中进行初始化。

private static final Integer INTERGE_CONS1 = Integer.valueOf(100); //在<clinit>()中进行初始化。
```

<img src="../../pictures/20231024111809.png" width="1000"/>

- JVM保证一个类的\<clinit\>\(\)方法在多线程下被同步加锁（隐式）。

> 若多个线程同时准备初始化一个类，则只有一个线程能够进入，其他线程只能等待，等该类初始化完成后，JVM会直接将准备好的信息返回给处于等待队列的线程。

## 类的初始化时机：主动/被动使用

| 类的使用方式 | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 主动使用     | 触发类的初始化\<clinit\>\(\)（只有第一次使用时会触发初始化） |
| 被动使用     | 不触发类的初始化\<clinit\>\(\)                               |

> 初始化&ne;加载，只要有使用就一定被加载，只有主动使用才会初始化。

**主动使用**

1. 创建类的实例：new关键字、反射、克隆、反序列化。
2. 调用类的静态方法时。
3. 访问类/接口的静态变量、或对该静态变量赋值。（除了final）

>final修饰的基本数据类型、String字面量都是准备环节就显式赋值。
>
>而fianl修饰的引用类型仍然会触发主动使用，在\<clinit\>()中进行初始化。

4. 初始化子类时，若其父类还未初始化，则先触发父类的初始化。但是，一个父接口（没有定义default方法时）不会因为其子接口或实现类的初始化而初始化，只有程序首次使用特定接口的静态字段时，才会导致该接口的初始化。

> JVM初始化一个类时，要求其所有的父类都已经被初始化，但不适用于接口。

```shell
# 跟踪类的加载信息并打印
-XX:+TraceClassLoading
```

5. 若接口定义了default方法，则直接实现、或间接实现该接口的类的初始化之前，要先初始化该接口。

6. JVM会先初始化启动时被标明为启动类（main()方法）的类。
7. java.lang.reflect包中的方法反射类的方法时（Class.forName()等）。
8. 动态语言支持：首次调用java\.lang\.invoke\.MethodHandle实例时，若MethodHandle指向的方法所在的类（解析结果REF\_getStatic、REF\_putStatic、REF\_invokeStatic句柄对应的类）没有初始化，则初始化。

**被动使用**：除了主动使用外的其他使用类的方式，不会导致类的初始化。

1. 访问静态字段时，只有声明了该字段的类才会被初始化。子类引用父类的静态变量时，不会导致子类被初始化。
2. 对象数组定义类引用时，不会触发该类的初始化。

```java
Order[] orders = new Order[10]; //不会触发Order类的初始化
orders[0] = new Order(); //触发Order类的初始化
```

3. 引用常量（final）不会触发该类/接口的初始化。（准备环节就已经显式赋值）

4. ClassLoader\#loadClass()方法**加载**类时，并不是对类的主动使用，不会导致类的初始化。

# 类的使用 Using

# 类的卸载 Unloading

- 类的生命周期取决于其对应的Class对象的生命周期。当对应的Class对象不再被引用时，该Class对象结束生命周期，对应的该类在方法区中的数据也被卸载，从而结束该类的生命周期。

<img src="../../pictures/JVM-Unloading-example.drawio.svg" width="600"/> 

1. 启动类加载器加载的类型在整个运行期间是不可能被卸载的。（JVM规范、JLS规范）
2. 系统类加载器或拓展类加载器加载的类在运行期间极小可能被卸载，系统类加载器和拓展类加载器的实例在整个运行期间总能被直接/间接地访问，一般不会变为无法触及。
3. 自定义的类加载器实例加载的类在运行期间也不太可能被卸载，只有在简单的上下文环境中才能被卸载，且通常需要借助于强制调用JVM的GC才能完成卸载。

