# 日期时间概述

1. jdk 1.0 Date类。
2. jdk 1.1 Calendar类，一定程度上替换Date类。
3. jdk 1.8 提出一套新的API：
   - java.time – 包含值对象的基础包
   - java.time.chrono – 提供对不同的日历系统的访问
   - java.time.format – 格式化和解析时间和日期
   - java.time.temporal – 包括底层框架和扩展特性
   - java.time.zone – 包含时区支持的类

**前两代的问题**

- 可变性：像日期和时间这样的类应该是不可变的。
- 偏移性：Date中的年份是从1900开始的，而月份都从0开始。
- 格式化：格式化只对Date有用，Calendar则不行。
- 线程不安全；不能处理闰秒等。

**计算世界时间的主要标准有：**

- UTC（Coordinated Universal Time）
- GMT（Greenwich Mean Time）
- CST（Central Standard Time）

# java.lang.System

- System#currentTimeMillis()：时间戳，返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。

````java
public static long currentTimeMillis(){..}
````

# java.util.Date

- java.util.Date：表示特定的瞬间，精确到毫秒。

| 构造器          | 说明               |
| --------------- | ------------------ |
| Date()          | 获取本地当前时间   |
| Date(long date) | 通过时间戳获取时间 |

| 方法       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| getTime()  | 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此Date 对象表示的毫秒数 |
| toString() | 将此 Date 对象转换为以下形式的 String：<br /><img src="../../../../pictures/166405516247526.png" width="300"/> |

```java
//空参构造器：创建当前时间的Date对象
Date date1 = new Date();
System.out.println(date1); //toString()
//Wed Oct 26 16:51:02 CST 2022
//星期 月 日  时间   时间标准 年

//时间戳
System.out.println(date1.getTime());
//1666774415833

//指定时间的构造器
Date date2 = new Date(1666774415833L);
System.out.println(date2);
//Wed Oct 26 16:53:35 CST 2022
```

# java.sql.Date

- java.sql.Date：对应数据库中的日期类型的变量，继承自java.util.Date类。

```java
//创建java.sql.Date的对象
java.sql.Date date = new java.sql.Date(174242344342L);
System.out.println(date); //1975-07-11
```

- java.util.Date、java.sql.Date转换：

```java
//import java.util.Date：因此java.sql.Date需要使用全限定名来区分

//java.sql.Date --> java.util.Date
Date date1 = new java.sql.Date(13819381293819L);
java.sql.Date date2 = (java.sql.Date)date1;

//java.util.Date --> java.sql.Date
Date date3 = new Date();
//java.sql.Date date4 = (java.sql.Date)date3; 报错
java.sql.Date date4 = new java.sql.Date(date.getTime());
```

# java.text.SimpleDateFormat

- java.text.SimpleDateFormat：不与语言环境有关的方式来格式化和解析日期的具体类。

| 构造器                           | 说明                                                       |
| -------------------------------- | ---------------------------------------------------------- |
| new SimpleDateFormat()           | 默认格式                                                   |
| new SimpleDateFormat("具体格式") | 指定方式格式化和解析<br />如：yyyyy.MMMMM.dd GGG hh:mm aaa |

- format()：格式化，日期-->字符串。

```
SimpleDateFormat对象.format(Date对象);
```

- parse()：解析，字符串-->日期  (格式化的逆过程)。
  - throws ParseException。

```
SimpleDateFormat对象.parse("识别的格式");
```

```java
@Test
public void testSimpleDateFormat() throws ParseException {
    //实例化SimpleDateFormat 使用默认的构造器
    SimpleDateFormat sdf = new SimpleDateFormat();

    Date date = new Date();
    System.out.println(date);
    //Thu Oct 27 22:11:08 CST 2022

    //格式化：日期-->字符串
    String format = sdf.format(date);
    System.out.println(format);
    //2022/10/27 下午10:11

    //解析
    String str = "2022/10/23 上午10:10";
    //格式要求默认："yyyy/MM/dd aaa hh:mm:ss " 不同版本不一样
    Date date1 = sdf.parse(str);
    System.out.println(date1);
    //Sun Oct 23 10:10:00 CST 2022

    //指定方式格式化和解析 调用带参的构造器
    //SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyy.MMMMM.dd GGG hh:mm aaa");
    SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
    //格式化
    String format1 = sdf1.format(date);
    System.out.println(format1);
    //02022.十月.27 公元 10:20 下午
    //2022-23-27 10:23:55
    //解析: 要求字符串必须符合SimpleDateFormat识别的格式（通过构造器参数实现)
    //否则报错
    Date date2 = sdf1.parse("1999-12-31 23:59:59");
    System.out.println(date2);
    //Sun Jan 31 23:59:59 CST 1999
}
```

# java.util.Calendar（日历）

- Calendar：抽象基类，主用用于完成日期字段之间相互操作的功能。

| 实例化                        | 说明 |
| ----------------------------- | ---- |
| Calendar.getInstance()        |      |
| 子类GregorianCalendar的构造器 |      |

- Calendar实例：系统时间的抽象表示，`get(int field)`取得想要的时间信息，如：YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND。

| 方法                                  | 说明                    |
| ------------------------------------- | ----------------------- |
| public int get(int field)             | 获取日历                |
| public void set(int field,int value)  | 设置时间                |
| public void add(int field,int amount) | 增加或减少时间 , 负数减 |
| public final Date getTime()           | 日历类-->Date类         |
| public final void setTime(Date date)  | Date类-->日历类         |

- 获取月份时：一月是0，二月是1，... ，12月是11
- 获取星期时：周日是1，周二是2 ... 周六是7

```java
//1.实例化
//方式一：创建子类GregorianCalendar的对象
//方式二：调用其静态方法getInstance()
Calendar calendar = Calendar.getInstance();
//System.out.println(calendar.getClass());
//class java.util.GregorianCalendar 仍然来自于其子类

//get()
int days = calendar.get(Calendar.DAY_OF_MONTH);
//get(Calendar.该类内部的静态属性)  具体查看API
System.out.println(days); //返回本个月的第几天
System.out.println(calendar.get(Calendar.DATE)); //返回-日

//set()
calendar.set(Calendar.DAY_OF_MONTH,22);
//修改calendar对象内的属性 //Calendar类的属性不变：不可变性
days = calendar.get(Calendar.DAY_OF_MONTH);
System.out.println(days); //22 返回修改后的日期

//add()
calendar.add(Calendar.DAY_OF_MONTH,3); //负数则减
//增加3天
days = calendar.get(Calendar.DAY_OF_MONTH);
System.out.println(days); //25 返回增加后的日期
calendar.add(Calendar.DAY_OF_MONTH,-1); //负数则减
//减1天
days = calendar.get(Calendar.DAY_OF_MONTH);
System.out.println(days); //24 返回减后的日期

//getTime() 日历类-->Date类
Date time = calendar.getTime();
System.out.println(time);
//Mon Oct 24 23:29:51 CST 2022

//setTime() Date类-->日历类
Date date = new Date();
calendar.setTime(date);
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));//27
```

- 

# LocalDate、LocalTime、LocalDateTime

- LocalDate、LocalTime、LocalDateTime：不可变性，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间，提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。

| 类            | 说明                        |
| ------------- | --------------------------- |
| LocalDate     | IOS格式（yyyy-MM-dd）的日期 |
| LocalTime     | 时间                        |
| LocalDateTime | 日期和时间                  |

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| now() <br />now(ZoneId zone)                                 | 静态方法，根据当前时间创建对象/指定时区的对象                |
| of()                                                         | 静态方法，根据指定日期/时间创建对象                          |
| getDayOfMonth()<br />getDayOfYear()                          | 获得月份天数(1-31) <br />获得年份天数(1-366)                 |
| getDayOfWeek()                                               | 获得星期几，返回一个 DayOfWeek 枚举值                        |
| getMonth()                                                   | 获得月份，返回一个 Month 枚举值                              |
| getMonthValue() <br />getYear()                              | 获得月份(1-12) <br />获得年份                                |
| getHour()<br />getMinute()<br />getSecond()                  | 获得当前对象对应的小时、分钟、秒                             |
| withDayOfMonth()<br />withDayOfYear()<br />withMonth()<br />withYear() | 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 |
| plusDays()<br />plusWeeks()<br />plusMonths()<br />plusYears()<br />plusHours() | 向当前对象添加几天、几周、几个月、几年、几小时               |
| minusMonths() <br />minusWeeks()<br />minusDays()<br />minusYears()<br />minusHours() | 从当前对象减去几月、几周、几天、几年、几小时                 |

```java
@Test
public void test1(){
    //now() 获取当前时间
    LocalDate localDate = LocalDate.now();
    LocalTime localTime = LocalTime.now();
    LocalDateTime localDateTime = LocalDateTime.now();

    System.out.println(localDate);
    System.out.println(localTime);
    System.out.println(localDateTime);
    //2022-10-28
    //15:54:10.480256600
    //2022-10-28T15:54:10.480256600

    //of() 设置指定的年月日时分秒时，没有偏移量
    LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 13);
    System.out.println(localDateTime1);
    //2020-10-06T13:23:13

    //getXxx() 获取日期属性
    System.out.println(localDateTime.getDayOfMonth());
    System.out.println(localDateTime.getDayOfWeek());
    System.out.println(localDateTime.getDayOfYear());
    System.out.println(localDateTime.getMinute());
    //28
    //FRIDAY
    //301
    //28

//体现不可变性
    //withXxx() 修改
    LocalDate localDate1 = localDate.withDayOfMonth(22);
    System.out.println(localDate);
    System.out.println(localDate1);
    //2022-10-28
    //2022-10-22

    LocalDateTime localDateTime2 = localDateTime.withHour(4);
    System.out.println(localDateTime);
    System.out.println(localDateTime2);
    //2022-10-28T16:34:05.769278400
    //2022-10-28T04:34:05.769278400

    //plusXxx() 添加
    LocalDateTime localDateTime3 = localDateTime.plusYears(3);
    System.out.println(localDateTime);
    System.out.println(localDateTime3);
    //2022-10-28T16:35:34.425305800
    //2025-10-28T16:35:34.425305800
}
```

# java.time.Instant

- Instant：时间线上的一个瞬时点，可能被用来记录应用程序中的事件时间戳。

- java.time包通过值类型Instant提供机器视图。Instant表示时间线上的一点，而不需要任何上下文信息：
  - 例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。
- java.time包是基于纳秒计算的：Instant的精度可以达到纳秒级。 

> $$
> 1 ns = 10^{-9} s \\
> 
> 1s = 1000 ms = 10^6 us =10^9ns
> $$

| 方法                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| now()                         | 静态方法，返回默认UTC时区的Instant类的对象                   |
| ofEpochMilli(long epochMilli) | 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象 |
| atOffset(ZoneOffset offset)   | 结合即时的偏移来创建一个 OffsetDateTime                      |
| toEpochMilli()                | 返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳        |

```java
Instant instant = Instant.now();
System.out.println(instant);
//2022-10-28T08:40:37.774837200Z

//添加时间的偏移
OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
System.out.println(offsetDateTime);
//2022-10-28T16:42:42.421531800+08:00

//toEpochMilli() 获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数
long milli = instant.toEpochMilli();
System.out.println(milli);
//1666946757201

//ofEpochmilli() 通过给定的毫秒数
Instant instant1 = instant.ofEpochMilli(12312312312L);
System.out.println(instant1);
//1970-05-23T12:05:12.312Z
```

# java.time.format.DateTimeFormatter

- java.time.format.DateTimeFormatter：格式化与解析日期或时间

1. 预定义的标准格式：
   - ISO_LOCAL_DATE_TIME
   - ISO_LOCAL_DATE
   - ISO_LOCAL_TIME
2. 本地化相关的格式：如 ofLocalizedDateTime(FormatStyle.LONG)。
3. 自定义的格式：如 ofPattern(“yyyy-MM-dd hh:mm:ss”)。

| 方法                                        | 说明                                     |
| ------------------------------------------- | ---------------------------------------- |
| ofPattern(String pattern)                   | 静态方法 ， 返回一个指定字符串格式的     |
| DateTimeFormatterformat(TemporalAccessor t) | 格式化一个日期、时间，返回字符串         |
| parse(CharSequence text)                    | 将指定格式的字符序列解析为一个日期、时间 |

```java
@Test
public void test3(){
//方式1预定义的标准格式。
    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
      //格式化 日期-->字符串
    LocalDateTime localDateTime = LocalDateTime.now();
    String str1 = dateTimeFormatter.format(localDateTime);
    dateTimeFormatter.format(localDateTime);
    System.out.println(str1);
    System.out.println(localDateTime);
      //2022-10-28T17:00:23.5674663
      //2022-10-28T17:00:23.567466300
      //解析 字符串-->日期
    TemporalAccessor parse = dateTimeFormatter.parse("2019-02-18T17:00:23.22222");
    System.out.println(parse);
       //{},ISO resolved to 2019-02-18T17:00:23.222220
//方式2本地化相关的格式。
    DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);
    //格式化
    String format = dateTimeFormatter1.format(localDateTime);
    System.out.println(format);
    //2022/10/28 下午5:04

    DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);
    //格式化
    String format1 = formatter.format(LocalDate.now());
    System.out.println(format1);
    //2022年10月28日星期五

//方式3自定义的格式。
    DateTimeFormatter dateTimeFormatter2 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");
    //格式化
    String str = dateTimeFormatter2.format(LocalDateTime.now());
    System.out.println(str);
    //2022-10-28 05:10:10

    //解析
    TemporalAccessor parse1 = dateTimeFormatter2.parse("2019-10-23 12:12:23");
    System.out.println(parse1);
    //{MilliOfSecond=0, HourOfAmPm=0, NanoOfSecond=0, SecondOfMinute=23, MinuteOfHour=12, MicroOfSecond=0},ISO resolved to 2019-10-23
}
```

# 其它API

**ZoneId：**

- 该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris

**ZonedDateTime：**

- 一个在ISO-8601日历系统时区的日期时间，
  - 如 2007-12-03T10:15:30+01:00 Europe/Paris。
- 其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，
  - 例如：Asia/Shanghai等

**Clock：**

- 使用时区提供对当前即时、日期和时间的访问的时钟。
- 持续时间：Duration，用于计算两个“时间”间隔
- 日期间隔：Period，用于计算两个“日期”间隔

**TemporalAdjuster**

- 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。

**TemporalAdjusters :** 

- 该类通过静态方法(`firstDayOfXxx()/lastDayOfXxx()/nextXxx()`)提供了大量的常用TemporalAdjuster 的实现。

# 