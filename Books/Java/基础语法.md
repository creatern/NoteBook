# 变量

- 变量的命名规则：

1. 26个英文字母大小写，`0-9，_，$`。
2. 数字不可以开头。
3. 不能使用关键字和保留字。
4. 严格区分大小写。
5. 不能包含空格。

| 命名规范      | 说明                                                         | 示例    |
| ------------- | ------------------------------------------------------------ | ------- |
| 包名          | 多单词时都小写                                               | xxxyyy  |
| 类名/接口名   | 多单词时每个单词首字母大写                                   | XxxYy   |
| 变量名/方法名 | 多单词时第一个单词首字母小写，<br />第二个单词开始每个单词首字母大写 | xxxYyy  |
| 常量名        | 所有字母都大写，多单词用下划线连接                           | XXX_YYY |

| 变量     | 声明位置         | 具体类型                                   | 初始化值特点           |
| -------- | ---------------- | ------------------------------------------ | ---------------------- |
| 成员变量 | 方法体外且类体内 | 实例变量<br />类变量（static）             | 生命周期               |
| 局部变量 | 方法体内         | 形参<br />方法局部变量<br />代码块局部变量 | 除形参外，均要显式初始 |

- 变量：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。变量是程序中最基本的存储单元，包含变量类型、变量名、存储的值。  

- 定义变量：告诉编译器（compiler）这个变量是属于哪一种数据类型，这样编译器才知道需要配置多少空间给它，以及它能存放什么样的数据。

1. Java每个变量必须先声明，后使用。
2. 使用变量名来访问这块区域的数据。
3. 变量的作用域：其定义所在的一对`{}`（函数体）内，变量只有在其作用域内才有效。由于变量被定义出来后，只是暂存在内存中，等到程序执行到某一个点后，该变量会被释放掉，也就是说变量有它的生命周期。因此变量的有效范围是指程序代码能够访问该变量的区域，若超出该区域访问变量则编译时会出现错误。在程序中，一般会根据变量的有效范围，将变量分为“成员变量”和“局部变量”。
4. 同一个作用域内，不能定义重名的变量。

- 系统的内存可大略的分为3个区域：系统区（OS）、程序区（Program）、数据区（Data）。当程序执行时，程序代码会加载到内存中的程序区，数据暂时存储在数据区中。

<img src="../../pictures/567682923220659.png" width="400"/> 



# 基本数据类型

<img src="../../pictures/544083715232095.png" width="700"/> 

> String不是基本数据类型，属于引用数据类型。  

| 整型  | 存储空间 | 标识 |
| ----- | -------- | ---- |
| byte  | 1 Byte   |      |
| short | 2 Byte   |      |
| int   | 4 Byte   | 默认 |
| long  | 8 Byte   | l、L |

```java
byte b1 = -128;
byte b2 = 128; //错误，超出范围-128~127

//声明long型常量须后加‘l’或‘L’，否则默认int
long l2 = 123456789010; //错误，认为是int自动转long，大于2^31，超过int的范围。
```

| 浮点类型         | 标识       | 存储空间 | 表数范围                                      |
| ---------------- | ---------- | -------- | --------------------------------------------- |
| float（单精度）  | f、F       | 4 Byte   | -3.403E38~3.403E38<br />尾数精确到7位有效数字 |
| double（双精度） | d、D、缺省 | 8 Byte   | -1.798E308~-1.798E308<br />精度是float的两倍  |

```java
//声明float型常量，须后加‘f’或‘F’。否则默认double
float f2 = 12.3  //编译失败：被认为是自动类型转换，但不能自动大转小。
```

- char：字符（2 Byte），使用单引号。

> Java中的所有字符都使用Unicode编码。

```java
//1. 中文、数字、字母等Unicode码支持的
char c2 = '中';

//2. 换行符
char c3 = '\n'; //换行

//3. ASCII码
char c1 = 97; //'a'

//4. Unicode 值来表示字符型常量：‘\uXXXX’（XXXX代表一个十六进制整数）。
char c4 = '\u0043';
```

- boolean：取值只能是true、false。不可以使用0、非0的整数、null替代。

> Java虚拟机中没有任何供boolean值专用的字节码指令。
>
> Java语言表达所操作的boolean值，在编译之后都使用JVM中的int数据类型来代替：true用1表示，false用0表示。

- 默认初始化值：整数类型和char都是0、小数都是0.0、boolean是false。 （long、float需要带上标识符）

## 类型转换

- boolean类型不可以转换为其它的数据类型，也不能与其它数据类型运算。
- byte、short、char之间不会相互转换：如果操作数的类型低于int类型，则自动转换为int类型（++、--除外）。（不兼容的错误，可能损坏数据，编译不予通过。）

<img src="../../pictures/153093916248762.png" width="800"/>

| 转换方式 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 自动提升 | 容量小的类型自动转换为容量大的数据类型。<br />多种类型的数据混合运算：自动将所有数据转换成容量最大的数据类型，再进行计算。 <br />当为变量赋值的数据类型与变量类型不一致，并且赋值的数据类型级别低于变量类型的级别时，自动数据类型转换会将赋值数据自动转换为变量的类型。 |
| 强制转换 | 强转符：`(数据类型)变量`<br />可能造成精度降低或溢出。       |

<img src="../../pictures/228581200247119.png" width="843"/>   

```java
//转为byte超过精度范围
int i2 = 128;
byte b1 = (byte)i2;   //-128

int i3 = 200;
byte b2 = (byte)i3; //-56
 
int i4 = 2000;
byte b3 = (byte)i4; //-48 
```

## int 进制

```java
int num1 = 0b110;
int num2 = 110;
int num3 = 0127;
int num4 = 0x110A;
```

# 运算符

| 运算方向 | 优先级从高到低         |
| -------- | ---------------------- |
|          | `. () {} ; ,`          |
| R->L     | `++ -- ~ !(type)`      |
| L->R     | `* / %`                |
| L->R     | `+ -`                  |
| L->R     | `<< >> >>>`            |
| L->R     | `< > <= >= instanceof` |
| L->R     | `== !=`                |
| L->R     | `&`                    |
| L->R     | `^`                    |
| L->R     | `|`                    |
| L->R     | `&&`                   |
| L->R     | `||`                   |
| R->L     | `?:`                   |
| R->L     | `= *= /= %=`           |
| R->L     | `+= -= <<= >>=`        |
| R->L     | `>>>= &= ^= |=`        |

- % ：如果对负数取模，忽略模数负号，取正值计算。
- /：整数之间做除法时，只保留整数部分而舍弃小数部分。
- 只有单目运算符、三元运算符、赋值运算符是从右向左运算的。
- 赋值运算符支持连续赋值。

```java
int a,b;
a = b = 1;
```

- `==`比较基本数据类型的大小、引用类型的地址值。

## + 加号与连接符

| +      | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 加号   | 除boolean外的任何基本数据类型之间的计算。<br />（char和数值进行计算时，相当于对char的ASCII码值进行加减） |
| 连接符 | 任何基本数据类型使用+和String连接时。<br />String和其他基本数据类型有且只能是连接运算（包括boolean）。 |

```java
//String的连接
System.out.println("" + 1 + 2); //12
System.out.println(1 + 2 + ""); //3
```

## i++、++i

| 自增/自减 | 说明                                |
| --------- | ----------------------------------- |
| i++、i--  | 先返回值，再进行自增/自减。         |
| ++i、--i  | 先进行自增/自减，再返回计算后的值。 |

```java
//++、-- 不会改变数据类型
byte b1 = 127;
b1++; //-128
```

```java
(num++)++ //错误
```

## `?:` 三元运算符

```java
条件表达式 ? 表达式1 ：表达式2；
```

- `?:`要求返回一个结果。 条件表达式为boolean类型，true则返回表达式1，false则返回表达式2。  表达式1和表达式2为要求是同种类型,或者可自动转换（自动将类型转换为最高的一个） 。

## 逻辑运算

<img src="../../pictures/331722510239086.png" width="608"/>  

- `&` 左边无论真假，右边都进行运算。
- `&&`（短路）如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。

## 位运算

<img src="../../pictures/257723710239788.png" width="602"/>   

| 运算符 | 说明                                           | 运算                          |
| :----- | :--------------------------------------------- | ----------------------------- |
| a & b  | 有0则0                                         | 若a=1100，b=1010；则a&b=1000  |
| a \| b | 有1则1                                         | 若a=1100，b=1010；则a\|b=1110 |
| a ! b  | 不同则1，同则0                                 | 若a=1100，b=1010；则a!b=0110  |
| a >> b | 将a的二进制右移b位；相当于a除以2^b（注意范围） | 若a=8,b=2；则a>>b=2           |
| a << b | 将a的二进制左移b位；相当于a乘以2^b（注意范围） | 若a=8,b=2；则a<<b=32          |

# 数组

- 数组（Array）：多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。

- 数组本身是引用数据类型，而数组中的元素可以是任何数据类型。创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址，故数组的长度一旦确定就不能修改。

- 数组从维度、数据类型来区别。

```java
int[] arr1;
//int 数据类型
//[] 维度
```

```java
//一维数组
int[] arr; //还未分配空间
//静态初始化
int[] arr = new int[]{1,2,3};
//动态初始化
int[] arr = new int[3]; //对数组默认初始化

//多维数组（以二维为例）相当于数组内保存对其他数组的引用。
int[][] arr; //还未分配空间
int[][] arr = new int[3][]; //3xn
int[][] arr = new int[3][3]; //3X3
int[][] arr = {
    {1,2},
    {1,2,3}
};
```

- 数组索引调用 0开始，-1结尾。ArrayIndexOutofBoundsExcetion、NullPointerException。

```java
arr[0];
arr[-1];
```

# 流程控制

> 顺序结构：程序从上到下逐行地执行，中间没有任何判断和跳转。

## 分支结构

### if...else

- 条件返回的必须是boolean类型。

```java
if(条件) //代码

if(条件1){
    //执行代码块;
} else if(条件2){
    //执行代码块;
} else{
    //执行代码块;
}
```

### switch-case

> 凡是可以使用switch-case结构的都可以使用if-else。反之，不成立。

- `case:`：根据switch表达式中的值，一次匹配各个case中的常量，一旦匹配成功，则进入相应的case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或者此swtich-case结构末尾结束为止。

1. case子句中的值必须是常量，不能是变量名或不确定的表达式值。
2. break语句用来在执行完一个case分支后使程序跳出switch语句块。如果没有break，程序会顺序执行到switch结尾。（控制流贯穿问题）
3. default子句是可任选的，位置也是灵活的（放哪都是最后执行的）。当没有匹配的case时，执行default。

```java
switch(表达式){
    case 常量1:
        语句1;
        break;
    case 常量2:
        语句2;
        break;
        … …
            case 常量N:
        语句N;
        break;
    default:
        语句;
        break;
}
```

> `case->`：case中任意一个匹配成功，箭头右侧的代码都被执行，且在这些代码结束之后，不会产生控制流贯穿问题。 
>
> ```java
> switch(值){
>      case 匹配值 -> 语句; 
> }
> ```

- yield：yield返回一个值作为switch语句的返回值。return 会直接跳出当前循环或者方法，而 yield 只会跳出当前switch块。

```java
int opt = switch(fruit){
    case "apple" -> 1;
    case "banana" -> 2;
    default -> {
        int code = fruit.hashCode();
        yield code;
    }
};
```

## 循环结构

### for

```
//执行过程：①-②-③-④-②-③-④-②-③-④-.....-②
for (①初始化部分; ②循环条件部分; ④迭代部分){
    ③循环体部分;
}
```

- 循环条件部分为boolean类型表达式，当值为false时，退出循环。在每次开始循环前执行检查（在循环失败时也执行了一次）。
- 初始化部分和循环条件部分可以声明/更新多个变量，但必须是同一个类型，用逗号分隔。初始化部分若声明变量，则该变量只在该循环中有效，且只在第一次循环开始前声明。循环条件部分声明的变量在每次循环开始前都会再次声明。

> for循环中的①-②-③-④均可以省略。
>
> ```java
> for(;;)
> ```

```java
//没有大括号时：
for (int i = 0; i < 10; i++)
    //循环内
    if (i == 2)
        break;
//循环外
//if(i == 1) //错误
```

### forEach

```
for(类型 标识符: 可迭代类型的表达式) {
    语句;
} 
```

```java
int[] numbers = new int[] {1,2,3,4,5,6,7,8,9,10};

for(int element : numbers) {
    System.out.println(element);
}
```

### while

```
//执行过程：①-②-③-④-②-③-④-②-③-④-...-②
①初始化部分
while(②循环条件部分)｛
    ③循环体部分;
    ④迭代部分;
}
```

<img src="../../pictures/289043723220669.png" width="696"/>

1. for和while的初始化作用域范围不同：for 只在循环内部，而while在外部。
2. for和while的迭代最终值不同（若为i时）。

```java
int i = 1;
while (i <= 100){
       result += i;
       i++;
}
// i = 101; 满足条件 i <= 100 后仍然i++;i++之后才不满足条件则停止，会比范围多1
//其i++本质上是执行语句

for(int i = 1; i <= 100; i++){
    ...    
}
//i = 100; 执行到 i <= 100 就停止;不会超过范围
```

### do...while

```
//执行过程：①-③-④-②-③-④-②-③-④-...②
①初始化部分;
do{
    ③循环体部分
    ④迭代部分
}while(②循环条件部分);
```

- do-while循环至少执行一次循环体（不满足条件的时候也会执行一次），但如果满足执行多次，do...while和while没有区别，并不会多出1次。

<img src="../../pictures/199433823239095.png" width="689"/>   

### 嵌套循环

- 嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行`m*n`次。

## 循环关键字

> return结束方法，也可结束循环

| 关键字         | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| break          | 终止某个语句块的执行，跳出最近的一个循环体。                 |
| 带label的break | 在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块。 |
| continue       | 跳过其所在循环语句块的一次执行，继续下一次循环。             |
| continue       | 在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环。 |

```java
label1: { ……
label2:     { ……
label3:         { ……
                break label2;
                ……
                }
            }
        }
```
