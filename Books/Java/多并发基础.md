# Java内存模型

## Java内存模型与线程读写

<img src="../../pictures/Thread-Java内存模型.drawio.svg" width="650"/> 

- Java内存模型（抽象概念）规定，所有的变量都存放在主内存中。

1. 当线程需要使用变量时，会把主内存中的变量复制到自己的工作空间（工作内存）。
2. 线程读写变量时操作的是自己工作内存中的变量。
3. 线程在处理完后，将变量值更新到主内存中。

## 共享变量内存可见性问题

- 假设线程A和线程B同时处理一个共享变量，各自使用不同的CPU，并且L1 Cache和L2 Cache都为空，且假定共享变量X的值为0：

1. 线程A对共享变量X进行处理：
   1. 首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值(0)。
   2. 在自己的工作内存中修改变量X的值(1)，然后将其写入到两级Cache，并刷新到主内存中。
   3. 此时，L1 Cache (A)中X=1，L2 Cache 中X=1，主内存中X=1。
2. 线程B对共享变量X进行处理：
   1. 首先获取共享变量X的值，L1 Cache(B) 未命中，而L2 Cache命中，于是读取L2 Cache中X的值(1)。
   2. 在自己的工作内存中修改变量X的值(2)，然后将其写入到两级Cache，并刷新到主内存中。
   3. 此时，L1 Cache (B)中X=2，L2 Cache 中X=2，主内存中X=2。
3. 线程A再次对共享变量X进行处理：
   1. 首先获取共享变量X的值，L1 Cache(A) 命中，于是读取 L1 Cache(A) 中X的值(1)。
   2. 此时，线程A读取到的X值(1)和L2 Cache、主内存中的X值(2)都不一致，出现了共享变量的内存不可见问题。

# 同步

## synchronized

- synchronized块是Java提供的一种原子性内置锁（监视器锁），Java中的每个对象都可以把它当作一个同步锁来使用。

1. 内置锁是<b>排他锁、独占锁</b>，当一个线程获取了该锁后，其他线程必须等待该线程释放锁后才能获取该锁。
   1. 线程的执行代码在进入synchronized块前会自动获取内部锁，此时其他访问该同步代码块的线程会被阻塞挂起。
   2. 得到内部锁的线程会在正常退出同步代码块、或抛出异常后、或在同步块内调用了该内置锁资源的wait系列方法时，释放该内置锁。
2. synchronized的使用会导致上下文切换，带来线程调度开销（很耗时）。因为Java的线程和操作系统中的原生线程是一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态来执行阻塞操作。
3. sychronized的内存语义（加锁和释放锁），解决了共享变量内存可见性问题。
   1. 把在synchronized块内使用到的变量从线程的工作内存中清除，使得sychronized块使用的变量必须直接从主内存获取。也就是，获取锁之后，会清空锁块内本地内存中将会被用到的共享变量，只有在使用这些共享变量时才会从主内存中获取。
   2. 在退出sychronized块时，把在sychronized块内对共享变量的修改刷新到主内存。也就是，释放锁时，将本地内存中修改的共享变量刷新到主内存。

## volatile

- volatile是一种弱形式的同步（非阻塞），可以确保对一个变量的更新对其他线程马上可见。

1. 当一个变量被声明为volatile时，线程在写入变量时，不会把值缓存在寄存器或其他位置，而是会把值刷新会主内存。这样，当其他线程读取该共享变量时，会从主内存中重新获取最新值，而不是读取线程的工作内存中的值。
2. volatile的内存语义和sychronized相似，因此，对于已经使用了sychronized的位置，不必要使用volatile。
   1. 当线程写入了volatile变量值时，就等价于线程退出sychronized同步块。
   2. 读取volatile变量时，就等价于进入sychronized同步块。
3. volatile不是独占锁（非阻塞），并不能保证原子性。如果一个操作依赖于变量的当前值（读取-计算-写入），并且在多个线程之间进行修改，volatile仍然无法保证线程安全，需要使用sychronized。也就是说，只有当写入变量值不依赖变量的当前值时（原子性操作），才适合使用volatile关键字。
4. 禁止指令重排序，编译器和处理器不会对volatile变量的读写操作进行指令重排序，保证了操作的顺序性。

# CAS操作

## CAS概述

- CAS（Compare and Swap）是JDK提供的非阻塞原子性操作，通过硬件保证了“比较-更新”操作的原子性。

## ABA问题

- 假如线程I使用CAS修改初始值为A的变量X：

1. 线程I首先会去获取当前变量X的值(A)，之后使用CAS操作尝试修改X的值(B)。此时，如果CAS操作成功了，程序运行也不一定正确。
2. 有可能线程I获取变量X的值(A)后，在执行CAS之前，线程II使用CAS修改了变量X的值(B)，然后又使用CAS修改变量X的值(A)。
3. 此时，虽然线程I执行CAS时，X的值(A)，但这个A已经不是线程I获取的A了，而是线程II修改之后的A。

- ABA问题产生的原因是变量的状态值发生了环形转换（A&rarr;B&rarr;A） ，而如果变量的值只能朝着一个方向转换就不会存在ABA问题，例如AtomicStampedReference类给每个变量的状态值都配置了时间戳。

# [Unsafe](./Unsafe.md)

- JDK的rt.jar包中的Unsafe类提供了硬件级别的原子性操作，该类中的所有方法都是native的，使用JNI的方式访问本地C++实现库。

# Java指令重排序

- Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。