# Java内存模型

## Java内存模型与线程读写

<img src="../../pictures/Thread-Java内存模型.drawio.svg" width="650"/> 

- Java内存模型（抽象概念）规定，所有的变量都存放在主内存中。

1. 当线程需要使用变量时，会把主内存中的变量复制到自己的工作空间（工作内存）。
2. 线程读写变量时操作的是自己工作内存中的变量。
3. 线程在处理完后，将变量值更新到主内存中。

## 共享变量内存可见性问题

- 假设线程A和线程B同时处理一个共享变量，各自使用不同的CPU，并且L1 Cache和L2 Cache都为空，且假定共享变量X的值为0：

1. 线程A对共享变量X进行处理：
   1. 首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值(0)。
   2. 在自己的工作内存中修改变量X的值(1)，然后将其写入到两级Cache，并刷新到主内存中。
   3. 此时，L1 Cache (A)中X=1，L2 Cache 中X=1，主内存中X=1。
2. 线程B对共享变量X进行处理：
   1. 首先获取共享变量X的值，L1 Cache(B) 未命中，而L2 Cache命中，于是读取L2 Cache中X的值(1)。
   2. 在自己的工作内存中修改变量X的值(2)，然后将其写入到两级Cache，并刷新到主内存中。
   3. 此时，L1 Cache (B)中X=2，L2 Cache 中X=2，主内存中X=2。
3. 线程A再次对共享变量X进行处理：
   1. 首先获取共享变量X的值，L1 Cache(A) 命中，于是读取 L1 Cache(A) 中X的值(1)。
   2. 此时，线程A读取到的X值(1)和L2 Cache、主内存中的X值(2)都不一致，出现了共享变量的内存不可见问题。

# 同步

## synchronized

- synchronized块是Java提供的一种原子性内置锁（监视器锁），Java中的每个对象都可以把它当作一个同步锁来使用。

1. 内置锁是<b>排他锁、独占锁</b>，当一个线程获取了该锁后，其他线程必须等待该线程释放锁后才能获取该锁。
   1. 线程的执行代码在进入synchronized块前会自动获取内部锁，此时其他访问该同步代码块的线程会被阻塞挂起。
   2. 得到内部锁的线程会在正常退出同步代码块、或抛出异常后、或在同步块内调用了该内置锁资源的wait系列方法时，释放该内置锁。
2. synchronized的使用会导致上下文切换，带来线程调度开销（很耗时）。因为Java的线程和操作系统中的原生线程是一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态来执行阻塞操作。
3. sychronized的内存语义（加锁和释放锁），解决了共享变量内存可见性问题。
   1. 把在synchronized块内使用到的变量从线程的工作内存中清除，使得sychronized块使用的变量必须直接从主内存获取。也就是，获取锁之后，会清空锁块内本地内存中将会被用到的共享变量，只有在使用这些共享变量时才会从主内存中获取。
   2. 在退出sychronized块时，把在sychronized块内对共享变量的修改刷新到主内存。也就是，释放锁时，将本地内存中修改的共享变量刷新到主内存。

## volatile

- volatile是一种弱形式的同步（非阻塞），可以确保对一个变量的更新对其他线程马上可见。

1. 当一个变量被声明为volatile时，线程在写入变量时，不会把值缓存在寄存器或其他位置，而是会把值刷新会主内存。这样，当其他线程读取该共享变量时，会从主内存中重新获取最新值，而不是读取线程的工作内存中的值。
2. volatile的内存语义和sychronized相似，因此，对于已经使用了sychronized的位置，不必要使用volatile。
   1. 当线程写入了volatile变量值时，就等价于线程退出sychronized同步块。
   2. 读取volatile变量时，就等价于进入sychronized同步块。
3. volatile不是独占锁（非阻塞），并不能保证原子性。如果一个操作依赖于变量的当前值（读取-计算-写入），并且在多个线程之间进行修改，volatile仍然无法保证线程安全，需要使用sychronized。也就是说，只有当写入变量值不依赖变量的当前值时（原子性操作），才适合使用volatile关键字。
4. 禁止指令重排序，编译器和处理器不会对volatile变量的读写操作进行指令重排序，保证了操作的顺序性。

# CAS操作

## CAS概述

- CAS（Compare and Swap）是JDK提供的非阻塞原子性操作，通过硬件保证了“比较-更新”操作的原子性。

## ABA问题

- 假如线程I使用CAS修改初始值为A的变量X：

1. 线程I首先会去获取当前变量X的值(A)，之后使用CAS操作尝试修改X的值(B)。此时，如果CAS操作成功了，程序运行也不一定正确。
2. 有可能线程I获取变量X的值(A)后，在执行CAS之前，线程II使用CAS修改了变量X的值(B)，然后又使用CAS修改变量X的值(A)。
3. 此时，虽然线程I执行CAS时，X的值(A)，但这个A已经不是线程I获取的A了，而是线程II修改之后的A。

- ABA问题产生的原因是变量的状态值发生了环形转换（A&rarr;B&rarr;A） ，而如果变量的值只能朝着一个方向转换就不会存在ABA问题，例如AtomicStampedReference类给每个变量的状态值都配置了时间戳。

# [Unsafe](./Unsafe.md)

- JDK的rt.jar包中的Unsafe类提供了硬件级别的原子性操作，该类中的所有方法都是native的，使用JNI的方式访问本地C++实现库。

# Java指令重排序

- Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。

1. 尽管重排序在单线程下没有问题，但在多线程环境下，可能会导致非预期的程序执行结果。
2. volatile关键字修饰的变量可以避免重排序，编译器和处理器不会对volatile变量的读写操作进行指令重排序。也就是，可以确保volatile写之前的操作不会被编译器重排到其写之后，以及volatile读之后的操作也不会被编译器重排到其读之前。

# 伪共享

## 伪共享与Cache行

- 伪共享的产生是由于多个变量被放入了同一个Cache行中，并且多个线程同时去写入Cache行中不同的变量。且Cache与内存之间交换数据的单位是Cache行（局部性原理，当缓存中做不到变量时，会将变量所在内存中大小为Cache行的内存放入Cache行）。

1. 当CPU访问某个变量时，首先会去看CPU Cache内是否有该变量。如果有，则直接从中获取；否则就去主内存里面获取该变量，然后把该变量所在内存区域的一个Cache行大小的内存复制到Cache中。
2. 由于存放到Cache行的是内存块而不是单个变量，所以<u>可能会把多个变量存放到一个Cache行</u>中。
3. 当多个线程同时修改一个Cache行里面的多个变量时（<b>伪共享</b>），由于同时只能有一个线程操作Cache行，所以相比将每个变量放到Cache行中，性能会下降。

<img src="../../pictures/Thread-伪共享的内存模型.drawio.svg" width="400"/> 

- 多个线程不可能同时去修改自己所使用的CPU中（与其他进程所使用的CPU）相同Cache行的变量。如上图，假定变量x和y同时被放到了CPU的一级缓存和二级缓存：

1. 当线程1使用CPU1对变量x进行更新时，首先会修改CPU1的一级缓存中的变量x所在的Cache行。
2. 此时，在缓存一致性协议下，CPU2中的变量x对应的Cache行失效。
3. 之后，线程2使用CPU2在写入变量x时，就只能去二级缓存中查找，破坏了一级缓存。

## 伪共享的避免

### 字节填充

- 在JDK8之前，一般是通过<b>字节填充</b>来避免伪共享。也就是，创建一个变量时，使用填充字段填充该变量所在的Cache行，避免将多个变量存放在同一个Cache行。

### @Contented

- JDK8提供<code>@sun.misc.Contented</code>注解来解决伪共享的问题，可以修饰变量或类。

1. 在默认情况下，<code>@Contened</code>注解只用于Java核心类（例如rt包下的类等）。
2. 如果用户类路径下的类需要用这个注解，则需要添加 JVM参数<code>-XX:-RestrictContended</code>。
3. 填充的默认宽度为128，可以通过<code>-XX:ContendedPaddingWidth</code>参数来自定义宽度。

# 锁

## 乐观锁与悲观锁