# Java内存模型

## Java内存模型与线程读写

<img src="../../pictures/Thread-Java内存模型.drawio.svg" width="650"/> 

- Java内存模型（抽象概念）规定，所有的变量都存放在主内存中。

1. 当线程需要使用变量时，会把主内存中的变量复制到自己的工作空间（工作内存）。
2. 线程读写变量时操作的是自己工作内存中的变量。
3. 线程在处理完后，将变量值更新到主内存中。

## 内存可见性问题

- 假设线程A和线程B同时处理一个共享变量，各自使用不同的CPU，并且L1 Cache和L2 Cache都为空，且假定共享变量X的值为0：

1. 线程A对共享变量X进行处理：
   1. 首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值(0)。
   2. 在自己的工作内存中修改变量X的值(1)，然后将其写入到两级Cache，并刷新到主内存中。
   3. 此时，L1 Cache (A)中X=1，L2 Cache 中X=1，主内存中X=1。
2. 线程B对共享变量X进行处理：
   1. 首先获取共享变量X的值，L1 Cache(B) 未命中，而L2 Cache命中，于是读取L2 Cache中X的值(1)。
   2. 在自己的工作内存中修改变量X的值(2)，然后将其写入到两级Cache，并刷新到主内存中。
   3. 此时，L1 Cache (B)中X=2，L2 Cache 中X=2，主内存中X=2。
3. 线程A再次对共享变量X进行处理：
   1. 首先获取共享变量X的值，L1 Cache(A) 命中，于是读取 L1 Cache(A) 中X的值(1)。
   2. 此时，线程A读取到的X值(1)和L2 Cache、主内存中的X值(2)都不一致，出现了共享变量的内存不可见问题。

# synchronized关键字

# volatile关键字

1. 内存可见性：当一个线程修改了volatile变量的值，该变量的新值会立即被写回主内存，并通知其他线程所修改的值。其他线程读取该变量的值时会从主内存中重新加载，而不是从线程私有的缓存中读取。
2. 禁止指令重排序：编译器和处理器不会对volatile变量的读写操作进行指令重排序，保证了操作的顺序性。

3. 并不能保证原子性：如果一个操作依赖于变量的当前值，并且在多个线程之间进行修改，volatile仍然无法保证线程安全。