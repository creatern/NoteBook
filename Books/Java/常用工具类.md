# Math 数学计算

## java.lang.Math

- java.lang.Math提供了一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型。

| 方法             | 说明                                  |
| ---------------- | ------------------------------------- |
| abs()            | 绝对值                                |
| sqrt()           | 平方根                                |
| pow()            | a的b次幂                              |
| log()            | 自然对数                              |
| exp()            | e为底指数                             |
| max()<br />min() | 最大/小值                             |
| random()         | 返回0.0到1.0的随机数（double）        |
| round()          | double型数据a转换为long型（四舍五入） |

## BigInteger、BigDecimal

- Integer类作为int的包装类，能存储的最大整型值为2<sup>31-1</sup>，Long类也是有限的，最大为2<sup>63-1</sup>。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力。

<table>
    <tr>
        <th width="15%">java.math</th>
        <th>描述</th>
    </tr>
    <tr>
        <td rowspan="2">BigInteger</td>
        <td>不可变的任意精度的整数，提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法</td>
    </tr>
    <tr>
        <td>还提供模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作</td>
    </tr>
    <tr>
        <td rowspan="2">BigDecimal</td>
        <td>支持不可变的、任意精度的有符号十进制定点数</td>
    </tr>
    <tr>
        <td>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高</td>
    </tr>
</table>

```java
BigInteger bi = new BigInteger("2313123232323312223123122222222");
BigDecimal bd = new BigDecimal("1213123.12312312312");
BigDecimal bd2 = new BigDecimal("23");

System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_DOWN));
// 52744.48361404883
System.out.println(bd.divide(bd2, 15, BigDecimal.ROUND_HALF_UP));
// 52744.483614048831304
```

# <span name="比较器">比较器</span> Comparable与Comparator

- 比较器：Java中的对象在正常情况下，只能使用`== 或 !=`比较，而不能使用` > 或 < `比较。

<table>
	<thead>
		<tr>
			<th width="15%">接口</th>
			<th width="15%">比较器</th>
			<th width="70%">意义</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Comparable</td>
			<td>自然排序</td>
			<td>实现类的对象在任何位置都可以比较大小</td>
		</tr>
		<tr>
			<td>Comparator</td>
			<td>定制排序</td>
			<td>临时性的比较，定制排序大于自然排序。</td>
		</tr>
	</tbody>
</table>

## Comparable 自然排序

- String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象大小的方法。

- 自然排序：自定义类实现Comparable接口，重写comparaTo()指明如何排序。

- 重写compareTo()的规则：

1. 如果当前对象this大于形参对象obj，则返回正整数。
2. 如果当前对象this小于形参对象obj，则返回负整数。
3. 如果当前对象this等于形参对象obj，则返回零。

```java
Goods[] arr = new Goods[4];
arr[0] = new Goods("联想",199);
arr[1] = new Goods("华硕",100);
arr[2] = new Goods("星际",100);
arr[3] = new Goods("盛大",2321);

Arrays.sort(arr);

System.out.println(Arrays.toString(arr));// [Goods{name='星际', price=99.0}, Goods{name='华硕', price=100.0}, Goods{name='联想', price=199.0}, Goods{name='盛大', price=2321.0}]
```

```java
public class Goods implements Comparable {
    private String name;
    private double price;

    // 指明Goods的排序，按价格从低到高排序，再按照产品名称从高到低排序
    @Override
    public int compareTo(Object o) {
        if (o instanceof Goods) {
            Goods goods = (Goods) o;
            //方式一
            if (this.price > goods.price) {
                return 1;
            } else if (this.price < goods.price) {
                return -1;
            } else {
                // return 0;
                // 使用String类重写的compareTo()方法排序
                // 注意负号 从高到低
                return -this.name.compareTo(goods.name);
            }
            //方式二
            // return Double.compare(this.price,goods.price);
        }

        throw new RuntimeException("数据类型不一致");
    }
}
```

## Comparator 定制排序

- Comparator对象强行对多个对象进行整体排序的比较：没有实现java.lang.Comparable接口的、 实现了java.lang.Comparable接口的排序规则但不适合当前操作的。定制排序大于自然排序，如果存在自然排序，则被定制排序覆盖。

- 重写compare(Object o1,Object o2)规则：

1. 返回正整数，则表示o1大于o2；
2. 返回0，表示相等；
3. 返回负整数，表示o1小于o2。

```java
Goods[] arr = new Goods[5];
arr[0] = new Goods("联想", 199);
arr[1] = new Goods("华硕", 100);
arr[2] = new Goods("星际", 100);
arr[3] = new Goods("盛大", 2321);
arr[4] = new Goods("盛大", 221);

Arrays.sort(arr, new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
        if (o1 instanceof Goods && o2 instanceof Goods) {
            Goods g1 = (Goods)o1;
            Goods g2 = (Goods)o2;

            if(g1.getName().equals(g2.getName())){
                return -Double.compare(g1.getPrice(),g2.getPrice());
            }else{
                return g1.getName().compareTo(g2.getName());
            }
        }
        throw new RuntimeException("数据类型不一致");
    }
});

System.out.println(Arrays.toString(arr));// [Goods{name='星际', price=99.0}, Goods{name='华硕', price=100.0}, Goods{name='联想', price=199.0}, Goods{name='盛大', price=2321.0}]
```

# Pattern 正则

<table>
    <thead>
        <tr>
            <th>Pattern</th>
            <th>正则表达式</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>compile()</td>
            <td>静态，返回一个Pattern对象，编译正则表达式。
                <br />flag：模式标识。
                <br />
                <code>Pattern.CASE_INSENSITIVE</code>、r：匹配时忽略大小写，默认只考虑US ASCII字符。
                <br />
                <code>Pattern.UNICODE_CASE</code>、u：搭配r，匹配Unicode字符的大小写。
                <br />
                <code>Pattern.UNICODE_CHARACTER</code>、U：包含了u，使用Unicode替代POSIX。
                <br />
                <code>Pattern.MULTILINE</code>、m：指定
                <code>^、$</code>用于匹配行，而不是全文。
                <br />
                <code>Pattern.UNIX_LINES</code>、d：搭配m，只有
                <code>\n</code>作为行终止符。
                <br />
                <code>Pattern.DOTALL</code>、s：指定
                <code>.</code>匹配所有字符（包括行终止符）。
                <br />
                <code>Pattern.COMMENTS</code>、x：指定忽略空白字符、注释（
                <code>#</code>）。
                <br />
                <code>Pattern.LITERAL</code>：指定逐字地采纳，必须精确匹配（字母大小写的差异除外）。
                <br />
                <code>Pattern.CANON_EQ</code>：考虑Unicode字符的等价性，
            </td>
        </tr>
        <tr>
            <td>matcher()</td>
            <td>返回对应的匹配器（Matcher）</td>
        </tr>
        <tr>
            <td>split()
                <br />splitAsStream()
            </td>
            <td>返回将输入按指定分隔符分割的数组/Stream。
                <br />limit：数组的最大长度。
                <br />若分割到第limit-1个分隔符，则剩余的全部存入数组的最后一个位置。
                <br />limit&le;0时，分割整个输入；limit=0时，坠尾的字符串不会置于数组中。
            </td>
        </tr>
        <tr>
            <td>
                <strong>Matcher</strong>
            </td>
            <td>
                <strong>匹配器（任何实现CharSequence接口的）</strong>
            </td>
        </tr>
        <tr>
            <td>matches()</td>
            <td>若匹配模式，则返回true。</td>
        </tr>
        <tr>
            <td>lookingAt()</td>
            <td>若输入的开头匹配，则返回true。</td>
        </tr>
        <tr>
            <td>find()</td>
            <td>查找下一个匹配，若找到下一个匹配，则返回true。
                <br />start：指定查找起始点。
            </td>
        </tr>
        <tr>
            <td>start()
                <br />end()
            </td>
            <td>返回当前匹配的开始、结尾索引位置。
                <br />groupIndex：群组索引（从1开始，0表示整个匹配）。
            </td>
        </tr>
        <tr>
            <td>group()</td>
            <td>返回当前的匹配。
                <br />groupIndex：指定群组的匹配。
            </td>
        </tr>
        <tr>
            <td>replaceAll()
                <br />replaceFirst()
            </td>
            <td>返回将匹配器的输入中所有/第一个匹配替换后的结果。
                <br />replacement：替换字符串（
                <code>$n</code>指定群组的引用，
                <code>\$</code>来表示
                <code>$</code>）。
            </td>
        </tr>
        <tr>
            <td>reset()</td>
            <td>复位。
                <br />input：将匹配器用于另一个输入。
            </td>
        </tr>
    </tbody>
</table>

- 群组`()`（子表达式）

```java
Pattern compile = Pattern.compile("(([1-9]|1[0-2]):([0-5][0-9]))[ap]m", Pattern.CASE_INSENSITIVE);
Matcher matcher = compile.matcher("11:59am");
if (matcher.matches()) {
    for (int i = 0; i <= matcher.groupCount(); i++) {
        System.out.println("groupIndex:" + i + "\t" + matcher.group(i));
    }
}
```