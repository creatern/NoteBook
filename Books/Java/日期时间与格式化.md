# 日期时间API

## 日期时间API概述

<table>
    <thead>
        <tr>
            <th width="10%">JDK 版本</th>
            <th width="20%">引入或更新的类/包</th>
            <th width="70%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>JDK 1.0</td>
            <td><code>java.util.Date</code></td>
            <td>最初用于表示时间点的类，提供了基本的日期和时间处理功能。</td>
        </tr>
        <tr>
            <td>JDK 1.1</td>
            <td><code>java.util.Calendar</code></td>
            <td>作为对Date类功能的增强和补充，提供了更灵活的日历和时间处理能力。</td>
        </tr>
        <tr>
            <td>JDK 8</td>
            <td><code>java.time</code></td>
            <td>新的时间日期API包，包含值对象的基础包，提供现代、易用且线程安全的日期时间类。</td>
        </tr>
        <tr>
            <td></td>
            <td><code>java.time.chrono</code></td>
            <td>提供对不同日历系统的访问，支持非公历日历系统。</td>
        </tr>
        <tr>
            <td></td>
            <td><code>java.time.format</code></td>
            <td>提供日期和时间的格式化和解析功能，增强了国际化处理能力。</td>
        </tr>
        <tr>
            <td></td>
            <td><code>java.time.temporal</code></td>
            <td>提供底层框架及日期和时间相关的扩展字段和操作。</td>
        </tr>
        <tr>
            <td></td>
            <td><code>java.time.zone</code></td>
            <td>包含时区支持的相关类，提供精细化的时区管理和调整规则。</td>
        </tr>
    </tbody>
</table>

- <code>java.util.Date</code>与<code>java.util.Calendar</code>的缺陷：

1. 可变性：像日期和时间这样的类应该是不可变的。
2. 偏移性：Date中的年份是从1900开始的，而月份都从0开始。
3. 格式化：格式化只对Date有用，Calendar则不行。
4. 线程不安全；不能处理闰秒等。

- 计算世界时间的主要标准有：

1. UTC（Coordinated Universal Time）
2. GMT（Greenwich Mean Time）
3. CST（Central Standard Time）

## Date 日期时间

### java.util.Date

- java.util.Date：表示特定的瞬间，精确到毫秒。

<table>
	<thead>
		<tr>
			<th width="20%">构造器</th>
			<th width="80%">说明</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Date()</td>
			<td>获取本地当前时间</td>
		</tr>
		<tr>
			<td>Date(long date)</td>
			<td>通过时间戳获取时间</td>
		</tr>
	</tbody>
</table>
<table>
	<thead>
		<tr>
			<th width="20%">方法</th>
			<th width="80%">说明</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>getTime()</td>
			<td>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此Date 对象表示的毫秒数</td>
		</tr>
		<tr>
			<td>toString()</td>
			<td>将此 Date 对象转换为以下形式的 String：
				<img src="../../pictures/166405516247526.png" width="300"/>
			</td>
		</tr>
	</tbody>
</table>

```java
// 空参构造器：创建当前时间的Date对象
Date date1 = new Date();
// Wed Oct 26 16:51:02 CST 2022
// 星期 月 日  时间   时间标准 年

// 时间戳
System.out.println(date1.getTime());
// 1666774415833

// 指定时间的构造器
Date date2 = new Date(1666774415833L);
System.out.println(date2);
// Wed Oct 26 16:53:35 CST 2022
```

### java.sql.Date

- java.sql.Date：对应数据库中的日期类型的变量，继承自java.util.Date。

```java
//创建java.sql.Date的对象
java.sql.Date date = new java.sql.Date(174242344342L);
System.out.println(date); //1975-07-11
```

- java.util.Date、java.sql.Date转换：

```java
//import java.util.Date：因此java.sql.Date需要使用全限定名来区分

//java.sql.Date --> java.util.Date
Date date1 = new java.sql.Date(13819381293819L);
java.sql.Date date2 = (java.sql.Date)date1;

//java.util.Date --> java.sql.Date
Date date3 = new Date();
//java.sql.Date date4 = (java.sql.Date)date3; 报错
java.sql.Date date4 = new java.sql.Date(date.getTime());
```

## Calendar 日历

- Calendar：抽象基类，主用用于完成日期字段之间相互操作的功能。
- Calendar实例化的方式：

1. <code>Calendar.getInstance()</code>
2. 子类GregorianCalendar的构造器

- Calendar实例是对系统时间的抽象表示，通过`get(int field)`取得想要的时间信息，如<code>YEAR、MONTH、DAY_OF_WEEK</code>、<code>HOUR_OF_DAY </code>、<code>MINUTE</code>、<code>SECOND</code>。

<table>
	<thead>
		<tr>
			<th width="40%">方法</th>
			<th width="60%">说明</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>public int get(int field)</td>
			<td>获取日历</td>
		</tr>
		<tr>
			<td>public void set(int field,int value)</td>
			<td>设置时间</td>
		</tr>
		<tr>
			<td>public void add(int field,int amount)</td>
			<td>增加或减少时间 , 负数减</td>
		</tr>
		<tr>
			<td>public final Date getTime()</td>
			<td>日历类&rarr;Date类</td>
		</tr>
		<tr>
			<td>public final void setTime(Date date)</td>
			<td>Date类&rarr;日历类</td>
		</tr>
	</tbody>
</table>

- 获取月份时：一月是0，二月是1，... ，12月是11
- 获取星期时：周日是1，周二是2 ... 周六是7

```java
//1.实例化
//方式一：创建子类GregorianCalendar的对象
//方式二：调用其静态方法getInstance()
Calendar calendar = Calendar.getInstance();
//System.out.println(calendar.getClass());
//class java.util.GregorianCalendar 仍然来自于其子类

//get()
int days = calendar.get(Calendar.DAY_OF_MONTH);
//get(Calendar.该类内部的静态属性)  具体查看API
System.out.println(days); //返回本个月的第几天
System.out.println(calendar.get(Calendar.DATE)); //返回-日

//set()
calendar.set(Calendar.DAY_OF_MONTH,22);
//修改calendar对象内的属性 //Calendar类的属性不变：不可变性
days = calendar.get(Calendar.DAY_OF_MONTH);
System.out.println(days); //22 返回修改后的日期

//add()
calendar.add(Calendar.DAY_OF_MONTH,3); //负数则减
//增加3天
days = calendar.get(Calendar.DAY_OF_MONTH);
System.out.println(days); //25 返回增加后的日期
calendar.add(Calendar.DAY_OF_MONTH,-1); //负数则减
//减1天
days = calendar.get(Calendar.DAY_OF_MONTH);
System.out.println(days); //24 返回减后的日期

//getTime() 日历类-->Date类
Date time = calendar.getTime();
System.out.println(time);
//Mon Oct 24 23:29:51 CST 2022

//setTime() Date类-->日历类
Date date = new Date();
calendar.setTime(date);
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));//27
```

## Instant 与 Duration

### Instant 时间戳

1. java.time包是基于纳秒计算的，Instant的精度可以达到纳秒级。 
2. Instant不可修改，返回的都是新的实例

<table>
    <thead>
        <tr>
            <th width="30%">方法</th>
            <th width="70%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>now()</code></td>
            <td>返回当前时间的时间戳（Instant）。</td>
        </tr>
        <tr>
            <td><code>ofEpochMilli(long epochMilli)</code></td>
            <td>静态方法，返回在1970-01-01 00:00:00 UTC基础上加上指定毫秒数之后的Instant类的对象。</td>
        </tr>
        <tr>
            <td><code>atOffset(ZoneOffset offset)</code></td>
            <td>结合即时的偏移量来创建一个OffsetDateTime对象。</td>
        </tr>
        <tr>
            <td><code>toEpochMilli()</code></td>
            <td>返回<code>1970-01-01 00:00:00 UTC</code>到当前时间的毫秒数，即为时间戳。</td>
        </tr>
    </tbody>
</table>

### Duration 时间量

1. Duration时间量：秒数（long）+纳秒数（int）。
2. Duration不可修改，返回的都是新的实例。
3. 对于跨越[夏令时](#ZoneDateTime)边界的日期，应该使用Period类设置间隔，而不应该使用Duration。

<table>
    <tr>
        <td width="30%"><Code>between()</Code></td>
        <td width="70%">返回两个Instant之间的时间量（Duration）</td>
    </tr>
</table>

### Instant与Duration的操作

<table>
<thead>
    <tr>
        <th width="20%">方法名及其扩展</th>
        <th width="80%">说明</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>plus()</td>
        <td rowspan="2">在当前的Instant/Duration上加/减一个Duration</td>
    </tr>
    <tr>
        <td>minus()</td>
    </tr>
    <tr>
        <td>plusXxx()</td>
        <td rowspan="2">在当前的Instant/Duration上加/减一个对应时间单位（例如：plusSeconds(), minusHours()等）</td>
    </tr>
    <tr>
        <td>minusXxx()</td>
    </tr>
    <tr>
        <td>multipliedBy()</td>
        <td rowspan="3">返回当前的Duration的乘法、除法或取反的结果<br/>这些方法只能应用于Duration，不能直接应用于Instant</td>
    </tr>
    <tr>
        <td>dividedBy()</td>
    </tr>
    <Tr>
        <td>negated()</td>
    </Tr>
    <tr>
        <td>isZero()</td>
        <td>判断当前的Duration是否为零</td>
    </tr>
    <tr>
        <td>isNegative()</td>
        <td>判断当前的Duration是否为负值</td>
    </tr>
</tbody>
</table>

```java
Instant start = Instant.now();
Instant end = Instant.now();
Duration between = Duration.between(start, end);
Duration plusDays = between.plusDays(1);
//between.plusDays(1) != between
//between.plusDays(1) != plusDays
```

### <code>System#currentTimeMillis()</code>

- <code>System#currentTimeMillis()</code>：时间戳，返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差（long）。

## LocalXxx 本地日期/时间

### LocalDate、LocalTime、LocalDateTime

- LocalDate、LocalTime、LocalDateTime：不可变性，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间，提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。
- 对于不存在的日期，如`2-31`会返回当前月最后一个有效日期。

<table>
	<thead>
		<tr>
			<th width="20%">LocalDate</th>
			<th width="80%">本地日期（没有时区信息）IOS格式的日期（yyyy-MM-dd）</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>new()
				<br />ofXxx()
			</td>
			<td>静态，返回一个LocalDate。
				<br />当前时间、指定时间（月份从1开始）。
			</td>
		</tr>
		<tr>
			<td>plus()、minus()
				<br />plusXxx()、minusXxx()
			</td>
			<td>在当前时间上加/减一个Duration、Period。
				<br />在当前时间上加/减一个对应时间单位。
			</td>
		</tr>
		<tr>
			<td>withXxx()</td>
			<td>返回一个新的（修改了指定时间部分的）LocalDate实例。</td>
		</tr>
		<tr>
			<td>getXxx()</td>
			<td>获取指定单位的时间。</td>
		</tr>
		<tr>
			<td>until()</td>
			<td>获取Period，两个日期之间的时长。
				<br />unit：按照指定的ChronUnit计算时长。
			</td>
		</tr>
		<tr>
			<td>isBefore()
				<br />isAfter()
			</td>
			<td>将当前的LocalDate和另一个LocalDate比较。</td>
		</tr>
		<tr>
			<td>isLeapYear()</td>
			<td>是否为闰年。</td>
		</tr>
		<tr>
			<td>
				<strong>LocalTime</strong>
			</td>
			<td>
				<strong>本地时间，当日时刻</strong>
			</td>
		</tr>
		<tr>
			<td>-</td>
			<td>大部分方法和LocalDate相同</td>
		</tr>
		<tr>
			<td>plus操作
				<br />minus操作
			</td>
			<td>以24小时循环操作。</td>
		</tr>
		<tr>
			<td>
				<strong>LocalDateTime</strong>
			</td>
			<td>
				<strong>本地日期和时间</strong>
			</td>
		</tr>
		<tr>
			<td>-</td>
			<td>大部分方法和LocalDate相同</td>
		</tr>
	</tbody>
</table>

```java
LocalDate now = LocalDate.ofInstant(Instant.now(), ZoneId.systemDefault());
LocalDate post = LocalDate.of(2022, 1, 2);
long until = post.until(now, ChronoUnit.DAYS);
```

### TemporalAdjuster 日期调整器

- TemporalAdjuster（日期调整器）提供大量常见调整的静态方法，也可实现该接口来自定义调整方法。

- TemporalAdjuster接口实现的Lambda表达式的参数是Temporal，需要强转为LocalDate；而<Code>TemporalAdjusters.ofDateAdjuster()</Code>方法期望的Lambda是`UnaryOperator<LocalDate>`，不需要强转。

```java
TemporalAdjuster NEXT_WORKDAY = TemporalAdjusters.ofDateAdjuster(w -> {
    LocalDate result = w;
    do {
        result = result.plusDays(1);
    } while (result.getDayOfWeek().getValue() >= 6);
    return result;
});
LocalDate localDate = LocalDate.of(2023, Month.OCTOBER,22).with(NEXT_WORKDAY);
```

## <span name="ZoneDateTime">ZoneDateTime</span> 时区时间（夏令时）

- [互联网编码分配管理机构](https://www.iana.org/time-zones)（Internet Assigned Numbers Authority，IANA）保存的IANA数据库存储者世界上所有已知的时区，Java使用该数据库。
- 格林威治皇家天文台时间（Coordinated Universal Time，UTC）不考虑夏令时

```java
// Java支持的所有时区ID
Set<String> availableZoneIds = ZoneId.getAvailableZoneIds();
```

<table>
	<thead>
		<tr>
			<th width="20%">ZoneId</th>
			<th width="80%">时区ID</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>of</td>
			<td>返回指定id的ZoneId对象。</td>
		</tr>
		<tr>
			<td>
				<strong>ZoneDateTime</strong>
			</td>
			<td>
				<strong>时区日期时间</strong>
			</td>
		</tr>
		<tr>
			<td>-</td>
			<td>大部分的方法和LocalDateTime相同。</td>
		</tr>
		<tr>
			<td>
				<strong>LocalDateTime</strong>
			</td>
			<td>
				<strong>本地日期时间</strong>
			</td>
		</tr>
		<tr>
			<td>atZone()</td>
			<td>指定ZoneId将LocalDateTime转换为ZoneDateTime。</td>
		</tr>
	</tbody>
</table>

# 格式化相关API

## SimpleDateFormat

- <code>java.text.SimpleDateFormat</code>不以与语言环境有关的方式来格式化和解析日期的具体类。

<table>
	<thead>
		<tr>
			<th width="30%">构造器</th>
			<th width="70%">意义</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>new SimpleDateFormat()</td>
			<td>默认格式</td>
		</tr>
		<tr>
			<td>new SimpleDateFormat(&quot;具体格式&quot;)</td>
			<td>指定方式格式化和解析，例如<code>yyyyy.MMMMM.dd GGG hh:mm aaa</code>
			</td>
		</tr>
	</tbody>
</table>
<table>
    <tr>
        <td width="15%">format()</td>
        <td width="10%">格式化</td>
        <td width="75%">日期&rarr;字符串</td>
    </tr>
    <tr>
        <td>parse()</td>
        <td>解析</td>
        <td>字符串&rarr;日期</td>
    </tr>
</table>

```java
// 格式化
SimpleDateFormat对象.format(Date对象);

// 解析
SimpleDateFormat对象.parse("识别的格式");
```

```java
@Test
public void testSimpleDateFormat() throws ParseException {
    //实例化SimpleDateFormat 使用默认的构造器
    SimpleDateFormat sdf = new SimpleDateFormat();

    Date date = new Date();
    System.out.println(date);
    //Thu Oct 27 22:11:08 CST 2022

    //格式化：日期-->字符串
    String format = sdf.format(date);
    System.out.println(format);
    //2022/10/27 下午10:11

    //解析
    String str = "2022/10/23 上午10:10";
    //格式要求默认："yyyy/MM/dd aaa hh:mm:ss " 不同版本不一样
    Date date1 = sdf.parse(str);
    System.out.println(date1);
    //Sun Oct 23 10:10:00 CST 2022

    //指定方式格式化和解析 调用带参的构造器
    //SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyy.MMMMM.dd GGG hh:mm aaa");
    SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
    //格式化
    String format1 = sdf1.format(date);
    System.out.println(format1);
    //02022.十月.27 公元 10:20 下午
    //2022-23-27 10:23:55
    //解析: 要求字符串必须符合SimpleDateFormat识别的格式（通过构造器参数实现)
    //否则报错
    Date date2 = sdf1.parse("1999-12-31 23:59:59");
    System.out.println(date2);
    //Sun Jan 31 23:59:59 CST 1999
}
```

## DateTimeFormatter

- <code>java.time.format.DateTimeFormatter</code>格式化与解析日期或时间

1. 预定义的标准格式：<code>ISO_LOCAL_DATE_TIME</code>、<code>ISO_LOCAL_DATE</code>、<code>ISO_LOCAL_TIME</code>。
2. 本地化相关的格式：如 <code>ofLocalizedDateTime(FormatStyle.LONG)</code>。
3. 自定义的格式：如<code>ofPattern("yyyy-MM-dd hh:mm:ss")</code>。

<table>
	<thead>
		<tr>
			<th width="40%">方法</th>
			<th width="60%">意义</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>ofPattern(String pattern)</td>
			<td>静态方法 ， 返回一个指定字符串格式的</td>
		</tr>
		<tr>
			<td>DateTimeFormatterformat(TemporalAccessor t)</td>
			<td>格式化一个日期、时间，返回字符串</td>
		</tr>
		<tr>
			<td>parse(CharSequence text)</td>
			<td>将指定格式的字符序列解析为一个日期、时间</td>
		</tr>
	</tbody>
</table>

```java
//方式1预定义的标准格式。
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
//格式化 日期-->字符串
LocalDateTime localDateTime = LocalDateTime.now();
String str1 = dateTimeFormatter.format(localDateTime);
dateTimeFormatter.format(localDateTime);
System.out.println(str1);
System.out.println(localDateTime);
//2022-10-28T17:00:23.5674663
//2022-10-28T17:00:23.567466300
//解析 字符串-->日期
TemporalAccessor parse = dateTimeFormatter.parse("2019-02-18T17:00:23.22222");
System.out.println(parse);
//{},ISO resolved to 2019-02-18T17:00:23.222220
```

```java
//方式2本地化相关的格式。
DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);
//格式化
String format = dateTimeFormatter1.format(localDateTime);
System.out.println(format);
//2022/10/28 下午5:04

DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);
//格式化
String format1 = formatter.format(LocalDate.now());
System.out.println(format1);
//2022年10月28日星期五
```

```java
//方式3自定义的格式。
DateTimeFormatter dateTimeFormatter2 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");
//格式化
String str = dateTimeFormatter2.format(LocalDateTime.now());
System.out.println(str);
//2022-10-28 05:10:10

//解析
TemporalAccessor parse1 = dateTimeFormatter2.parse("2019-10-23 12:12:23");
System.out.println(parse1);
//{MilliOfSecond=0, HourOfAmPm=0, NanoOfSecond=0, SecondOfMinute=23, MinuteOfHour=12, MicroOfSecond=0},ISO resolved to 2019-10-23
```