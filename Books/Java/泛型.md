# \<T\> 泛型

- 泛型：允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。类型参数在使用时确定（即传入实际的类型参数，也称为类型实参）。
- 泛型中的类型必须是类。（基本数据类型则使用包装类）

> 1. 解决元素存储的安全性问题。
> 2. 解决获取数据元素时，需要类型强制转换的问题。
>
> - 泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生`ClassCastException`异常。代码更加简洁、健壮。

# 自定义泛型

- 自定义泛型（结构中使用了泛型的）：泛型类、泛型接口、泛型方法。

1. 泛型的声明：`interface List<T> 和 class GenTest<K,V> ` 。其中，T、K、V不代表值，而是表示类型。（任意字母都可以，常用T（Type）表示）
2. 泛型的实例化（确定类型）：指明泛型中字母代表的类型。

```java
//以下的String就是对泛型的实例化。
List<String> strList = new ArrayList<String>();
```

> 泛型之间是可以嵌套使用的。

## 泛型类/接口

| 泛型实例化         | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| 没有指明泛型的类型 | 默认类型为java.lang.Object类型，且编译不检查类型（泛型擦除）。 |
| 指明泛型的类型     | 编译时检查类型，内部结构使用到泛型的位置，都指定为指明的泛型类型。 |

- 泛型使用时类似于Object，但不等同于Object。

```java
//泛型擦除，编译不会类型检查
ArrayList list = new ArrayList();
//一旦指定Object，编译会类型检查，必须按照Object处理
ArrayList<Object> list2 = new ArrayList<Object>();
```

- 类型推断：可以只写一部分的`<>`泛型指明。

```java
Map<String,Integer> map = new HashMap<>();
```

- 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内：`<E1,E2,E3>`。
- 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。
- 泛型不同的引用不能相互赋值。

```java
ArrayList<String> list1 = null;
ArrayList<Integer> list2 = null;
//ArrayList<String>、ArrayList<Integer>是不同的两种类型。
list1 = list2; //错误
```

| B extends A  | 关系                                                         |
| ------------ | ------------------------------------------------------------ |
| `G<A>、G<B>` | A、B是对G中的泛型的指明。<br />不具备子父类关系。<br />`G<?>`是`G<A>、G<B>`的公共父类。 |
| `A<G>、B<G>` | A、B是类，而G是对A、B中的泛型的指明。<br />具备子父类关系。  |

```java
public void show(List<Object> list){}
public void show1(List list){}

//此时的list1和list2不具备子父类关系，是并列的。
List<Object> list1 = null;
List<String> list2 = null;
list1 = list2; //错误 (泛型不同的引用不能相互赋值。)

test.show(list1);
//show(List<Object> list) 参数也不能是是list2
//test.show(list2);

test.show1(list1);
test.show1(list2);

//此时的list01和list02具备子父类关系
List<String> list01 = null;
ArrayList<String> list02 = null;
list01 = list02;
```

- 如果泛型结构是一个接口/抽象类，则不可创建泛型类的对象。
- 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型，但在静态方法中不能使用类的泛型。
- 异常类不能是泛型的。

```java
E[] arr = new E[10]; //错误
E[] arr = (E[])new Object[10]; //正确
```

```java
public class Order<T> {
    private String orderName;
    private int orderId;

    //类的内部结构就可以使用类的泛型
    T orderT;

    //泛型类的构造器不是：public GenericClass<E>(){}
    public Order() {}

    //静态方法中不能使用类的泛型
    //public static void show(T orderT){
    //    System.out.println(orderT);
    //}

    public T getOrderT() {return orderT;}

    public void setOrderT(T orderT) {this.orderT = orderT;}
}
```

## 泛型方法

- 泛型方法：普通类/泛型类中的方法都可以被泛型化。
- 泛型方法中出现泛型结构（`<T>`，不是T）时，泛型的参数与类的泛型参数没有任何关系。
- 泛型方法可以被static修饰。（在方法调用时指明泛型，而非实例化时），但不能在静态方法中使用类的泛型（类的泛型是在实例化的时候指明的，而静态方法在类中实现）。

```java
//[访问权限] <泛型> 返回类型 方法名([泛型标识 参数名称]) 抛出的异常
public static <E> List<E> copyFormArrayToList(E[] arr) {
    ArrayList<E> list = new ArrayList<>();

    for (E e : arr) {
        list.add(e);
    }
    return list;
}
```

# 泛型继承

- 当父类有泛型时，子类除了指定或保留父类的泛型，还可以增加泛型。

```java
class Father<T1, T2> {
}

//1. 子类不保留父类的泛型

// 1)没有类型（擦除）等价于class Son1 extends Father<Object,Object>{}
class Son1 extends Father {}
// 2)指明具体类型。子类在继承带泛型的父类时：如果指明了泛型类型，则实例化子类对象时，不再需要指明泛型
class Son2 extends Father<Integer, String> {
}

//2. 子类保留父类的泛型（泛型子类）

// 1)全部保留
class Son3<T1, T2> extends Father<T1, T2> {}
// 2)部分保留
class Son4<T2> extends Father<Integer, T2> {}
```

# `<?>` 通配符

- `<?>`（通配符）允许所有泛型的引用调用。

| 上/下限限制条件 | 描述       | 说明                                          |
| --------------- | ---------- | --------------------------------------------- |
| `? extends 类`  | 上限（<=） | 指定的类型必须是(该类的子类)继承某个类/接口。 |
| `? super 类`    | 下限（>=） | 指定的类型（该类的父类）不能小于操作的类。    |

```java
//Person继承Object，Student继承Person：Object > Person > Student。

//<? extends Person> 需要小于等于Person
List<? extends Person> list = new ArrayList<Object>(); //错误
List<? extends Person> list = new ArrayList<Person>();
List<? extends Person> list = new ArrayList<Student>();

//<? super Person> 需要大于等于Person
List<? super Person> list = new ArrayList<Student>(); //错误
List<? super Person> list = new ArrayList<Person>();
List<? super Person> list = new ArrayList<Object>();
```

# 
