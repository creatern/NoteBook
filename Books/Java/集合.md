# 集合概述

## 数组的局限性

- Java容器：集合和数组都是对多个数据进行内存层面的存储操作。

1. 数组一旦初始化以后，其 长度、元素的数据类型 不可改变。
2. 数组提供的方法非常有限，对于添加，删除，插入数据等操作，非常不便，同时效率不高。
3. 数组存储有序、可重复的数据。数组无法满足无序、不可重复的数据需求。

## 集合体系

### Collection

<table>
    <thead>
        <tr>
            <th width="30%">Collection接口</th>
            <th width="70%">单列数据，定义了存取一组对象(一个一个的对象)的方法的集合</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>List接口
                <br>ArrayList / LinkedList / Vector
            </td>
            <td>元素有序，可重复的集合  --&gt;“动态数组”</td>
        </tr>
        <tr>
            <td>Set接口
                <br>HashSet / LinkedSet / TreeSet
            </td>
            <td>元素无序，不可重复的集合 --&gt; 类型于数学中的”集合“</td>
        </tr>
    </tbody>
</table>

<img src="../../pictures/51232021239497.png" width="700"/>  

### Map

- Map用于存储双列数据（键值对），保存具有映射关系"key-value"键值对(一对一对的数据)的集合。一个key只能对应一个value，而一个value可以对应多个key。（<code>HashMap / LinkedHashMap / TreeMap / Hashtable / Properties</code>）

<img src="../../pictures/236772121227364.png" width="650"/>    

<table>
    <thead>
        <tr>
            <th width="30%">动作</th>
            <th width="30%">方法</th>
            <th width="40%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="2">添加</td>
            <td>add(Object obj)</td>
            <td>将元素e添加到集合中</td>
        </tr>
        <tr>
            <td>addAll(Collection coll)</td>
            <td>将coll集合中的元素添加到当前的集合中</td>
        </tr>
        <tr>
            <td>获取有效元素的个数</td>
            <td>int size()</td>
            <td></td>
        </tr>
        <tr>
            <td>清空集合</td>
            <td>void clear()</td>
            <td></td>
        </tr>
        <tr>
            <td>是否是空集合</td>
            <td>boolean isEmpty()</td>
            <td></td>
        </tr>
        <tr>
            <td rowspan="2">是否包含某个元素</td>
            <td>boolean contains(Object obj)</td>
            <td>通过元素的equals()方法来判断是否是同一个对象
                <br> 向Collection接口的实现类中添加数据obj时，要求obj所在类要重写equals()方法，用来判断
            </td>
        </tr>
        <tr>
            <td>boolean containsAll(Collection c)</td>
            <td>调用元素的equals()方法来比较的。拿两个集合的元素挨个比较</td>
        </tr>
        <tr>
            <td rowspan="2">删除</td>
            <td>boolean remove(Object obj)</td>
            <td>通过元素的equals方法判断是否是要删除的那个元素。
                <br>只会删除找到的第一个元素
            </td>
        </tr>
        <tr>
            <td>boolean removeAll(Collection coll)</td>
            <td>取当前集合的差集</td>
        </tr>
        <tr>
            <td>交集</td>
            <td>boolean retainAll(Collection c)</td>
            <td>把交集的结果存在当前集合中，不影响c集合
                <br>从当前集合中返回coll中匹配的元素,并将当前集合改为交集
            </td>
        </tr>
        <tr>
            <td>集合是否相等</td>
            <td>boolean equals(Object obj)</td>
            <td>调用元素内的equals()方法一一进行比较
                <br>如果是ArrayList() 则还要求有序
            </td>
        </tr>
        <tr>
            <td>转成对象数组</td>
            <td>Object[] toArray()</td>
            <td>集合--&gt;数组
                <br>数组--&gt;集合 调用Arrays类静态方法 aslist()
            </td>
        </tr>
        <tr>
            <td>获取集合对象的哈希值</td>
            <td>hashCode()</td>
            <td></td>
        </tr>
        <tr>
            <td>遍历</td>
            <td>iterator()</td>
            <td>返回迭代器对象，用于集合遍历 
                <br>返回Iterator接口的实例，用于遍历元素。
            </td>
        </tr>
    </tbody>
</table>

```java
public class CollectionTest {

    @Test
    public void test1() {
        Collection coll = new ArrayList();
        // add() 添加
        coll.add(123);
        coll.add("Jack");
        coll.add(false);
        coll.add(new String("Tom"));
        coll.add(new Person("Mac", 20));

        Collection coll1 = new ArrayList();
        // addAll(Collection coll) 添加coll集合中的所有元素
        coll1.addAll(coll);
        System.out.println(coll); // [123, Jack, false, Tom, com.zjk.Person@76ed1b7c]
        // 调用了String中的toString()方法
        // Person中为重写toString()方法

        coll1.clear();

        // isEmpty() 判断当前集合是否为空
        coll1.isEmpty();

        // contains(Object obj) 判断当前集合中是否包含obj
        // 在判断时，会调用obj对象所在类的equals()方法
        boolean contains = coll.contains(123);
        System.out.println(contains); // true
        System.out.println(coll.contains(new String("Tom"))); // true
        // 调用String重写的equals()方法
        System.out.println(coll.contains(new Person("Mac", 20))); // false
        // Person类中未重写equals()方法

        // containsAll(Collection coll) 判断形参coll中的所有元素是否都存在于当前集合中
        Collection coll2 = new ArrayList();
        coll2.add(123);

        System.out.println(coll.containsAll(coll2)); //true

        //remove(Object obj) 移除
        coll.remove(123);
        System.out.println(coll.remove(new String("Tom"))); //true
        //调用了equals()方法
        System.out.println(coll.remove(new Person("Mac", 20))); //false
        //Person类中未重写equals()方法，所以无法匹配来删除
        System.out.println(coll); //[Jack, false, com.zjk.java2.Person@75bd9247]

        //removeAll(Collection coll) 从当前集合中移除coll中的所有元素
        coll.removeAll(coll2);
        System.out.println(coll); //[Jack, false, com.zjk.java2.Person@75bd9247]

        coll1.add(new Person("Mac", 20));
        //retainAll(Collection coll) （交集）从当前集合中返回coll中匹配的元素,并将当前集合改为交集。
        //调用equals()方法来匹配
        System.out.println(coll); //[Jack, false, com.zjk.java2.Person@75bd9247]
        System.out.println(coll1); //[com.zjk.java2.Person@7d417077]
        coll.retainAll(coll1);
        System.out.println(coll); //[]

        Collection coll3 = new ArrayList();
        coll3.add(new String("Tom"));
        coll3.add(new Person("Mac", 20));
        Collection coll4 = new ArrayList();
        coll4.add(new String("Tom"));
        coll4.add(new Person("Mac", 20));

        //equals(Object obj)
        System.out.println(coll3.equals(coll4)); //false
        //调用元素内的equals()方法一一进行比较
        //且如果是ArrayList() 则还要求有序

        //hashCode()
        System.out.println(coll.hashCode()); //1

        //toArray() 集合-->数组
        Object[] arr = coll3.toArray();
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }

        //数组-->集合 调用Arrays类静态方法 aslist()
        List<Object> list = Arrays.asList(arr);
        System.out.println(list);//[Tom, com.zjk.java2.Person@7dc36524]
        List<int[]> ints = Arrays.asList(new int[]{123, 456});
        System.out.println(ints);//[[I@35bbe5e8] 只有一个元素

        List ints1 = Arrays.asList(new Integer[]{123, 456});
        System.out.println(ints1);//[123, 456]  包装类

        List ints2 = Arrays.asList(123, 456);
        System.out.println(ints2); //[123, 456]

        //iterator() 返回Iterator接口的实例 用于遍历元素，放在Iterator.Test.java中
    }
}
```

# Collection

## <span name="Iterator">Iterator</span> 迭代器（模式）

### Iterator()

- Iterator对象称为迭代器（迭代器模式），主要用于遍历 Collection 集合中的元素。GOF给<b>迭代器模式</b>的定义为，提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。

1. Collection接口继承`java.lang.Iterable`接口，所有实现了Collection接口的集合类都有`iterator()`方法，用以返回一个实现了Iterator接口的对象。（每次通过`iterator()`方法创建的Iterator对象都是新的对象）
2. 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。
3. Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。

```java
Iterator iterator = coll.iterator();
```

<table>
	<thead>
		<tr>
			<th width="20%">方法</th>
			<th width="80%">描述</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>hasNext()</td>
			<td>如果迭代存在下一个元素，则返回true，否则false。
				<br />迭代器的其他方法执行需要该方法的判断（NoSuchElementException）。
			</td>
		</tr>
		<tr>
			<td>next()</td>
			<td>返回迭代的下一个元素（游标移动）。</td>
		</tr>
		<tr>
			<td>remove()</td>
			<td>删除此迭代器返回的下一个元素。（对集合删除有效）
				<br />如果游标未移动，再次调用则IllegalStateException。
			</td>
		</tr>
	</tbody>
</table>

```java
// 提通过Collection接口的iterator()方法创建Iterator对象
Iterator iterator = coll.iterator();
// hasNext():判断是否还有下一个元素
while(iterator.hasNext()){
    // next():①指针下移 ②将下移以后集合位置上的元素返回
    System.out.println(iterator.next());
}
```

```java
// 错误1 it.next() 报错NoSuchElementException
Iterator iterator = coll.iterator();
Object obj;
while((obj = iterator.next()) != null){
    System.out.println(obj);
}

// 错误2：每次通过coll.iterator()方法创建的Iterator对象都是新的对象
// 跳不出循环
while((coll.iterator().next()).hasNext){
    System.out.println(obj);
}
```

###  [forEach](./基础配置与语法.md#foreach)

- forEach循环迭代访问Collection和数组：不需获取Collection或数组的长度，无需使用索引访问元素，底层调用Iterator完成操作。

```java
for(要遍历的集合/数组的元素的类型 在循环中使用的元素名称 : 要遍历的集合/数组){
    ...
}
```

## List

### List的性质

- List：存储有序的，可重复的数据，每个元素都有对应的顺序索引。

<table>
    <thead>
        <tr>
            <th width="15%">List实现类</th>
            <th width="85%">说明</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>ArrayList</td>
            <td>主要实现类
                <br>线程不安全，效率高
                <br>底层存储Object[] elementData
            </td>
        </tr>
        <tr>
            <td>LinkedList</td>
            <td>频繁的插入和删除操作 
                <br>底层存储双向链表
            </td>
        </tr>
        <tr>
            <td>Vector</td>
            <td>古老实现类
                <br />线程安全，效率低 
                <br />底层存储Object[] elementData
            </td>
        </tr>
    </tbody>
</table>

- `List subList(int fromIndex, int toIndex)`：返回从fromIndex到toIndex(不包括toIndex)位置的子集合

<table>
	<thead>
		<tr>
			<th width="30%">方法</th>
			<th width="70%">意义</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>add(int index, Object ele)
				<br />addAll(int index, Collection eles)
			</td>
			<td>插入</td>
		</tr>
		<tr>
			<td>remove(int index)
				<br />remove(Object obj)
			</td>
			<td>删
				<br />删除，并返回此元素。
			</td>
		</tr>
		<tr>
			<td>set(int index, Object obj)</td>
			<td>改</td>
		</tr>
		<tr>
			<td>Object get(int index)</td>
			<td>查</td>
		</tr>
		<tr>
			<td>size()</td>
			<td>长度</td>
		</tr>
		<tr>
			<td>int indexOf(Object obj)
				<br />int lastIndexOf(Object obj)
			</td>
			<td>首次出现的位置，否则返回-1。
				<br />最后出现的位置。
			</td>
		</tr>
	</tbody>
</table>

### ArrayList

#### add() 自动扩增

```java
public void add(int index, E element) {
    rangeCheckForAdd(index);
    modCount++;
    final int s;
    Object[] elementData;
    if ((s = size) == (elementData = this.elementData).length)
        elementData = grow(); // 增加ArrayList的长度：
    System.arraycopy(elementData, index,
                     elementData, index + 1,
                     s - index);
    elementData[index] = element;
    size = s + 1;
}

// ArrayList.add()超过长度时，对底层数组（elementData）的扩展
private Object[] grow(int minCapacity) {
    int oldCapacity = elementData.length;
    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        int newCapacity = ArraysSupport.newLength(oldCapacity,
                                                  minCapacity - oldCapacity, 
                                                  oldCapacity >> 1 );
        return elementData = Arrays.copyOf(elementData, newCapacity);
    } else {
        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
    }
}
```

#### Arrays.asList() 与 sublist()

<table>
    <tr>
        <td>Arrays.asList()</td>
        <td>返回的不是java.util下的ArrayList，而是<b>Arrays的内部类</b>（继承AbstractList，但没有重写add()方法）</td>
    </tr>
    <tr>
        <td>subList()</td>
        <td>返回的是<b>ArrayList的内部类SubList</b>（ArraysList的视图，不是ArrayList），对于SubList子列表的所有操作最终会反映到原列表上</td>
    </tr>
</table>
<table>
	<thead>
		<tr>
			<th width="12%">修改的对象</th>
			<th width="20%">元素（set()）</th>
			<th width="68%">结构（add()、remove()）</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>子集合</td>
			<td>影响原集合</td>
			<td>对子集合调用的remove()，此时删除的是对应于该子集合的下标位置的元素， 且只能是子集合中包含的元素。</td>
		</tr>
		<tr>
			<td>原集合</td>
			<td>影响子集合</td>
			<td>对父集合元素的增加/删除，均会导致子列表的遍历、增加、删除操作抛出ConcurrentModificationException。</td>
		</tr>
	</tbody>
</table>

#### remove() 与 包装类

```java
list.remove(2);  // 视为索引2 而不是数据2
list.remove(new Integer(2)); // 删除数据2
```

### LinkedList

- LinkedList：双向链表，对于频繁的插入/删除元素的操作，建议使用LinkedList类，效率较高。同时，定义了`内部类Node`，作为LinkedList中保存数据的基本结构。其内部声明了Node类型的first和last属性，默认值为null。

```java
// Node：体现了LinkedList的双向链表
private static class Node<E> {
    E item;
    Node<E> next; //记录下一个元素的位置
    Node<E> prev; //记录前一个元素的位置

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

```java
list.add(123); // 将123封装到Node中，创建了Node对象。
```

### Vector

- Vector()构造器创建对象时，底层创建长度为10的数组，add()扩容时默认2倍。

## Set

### Set的性质

- Set：存储无序，不可重复的数据。

<table>
    <tr>
        <td width="15%">无序性</td>
        <td width="85%">不等于随机性，遍历的顺序仍然是添加时的顺序。存储的数组在底层数组并非按照数组索引的顺序添加，而是根据数据的Hash值决定的。</td>
    </tr>
    <tr>
        <td>不可重复性</td>
        <td>保证添加的元素按照equals()方法判断时，相同的元素只能添加一次</td>
    </tr>
</table>

1. 作为Collection的子接口，Set并没有提供额外的方法。
2. Set 不允许存在相同的元素（ equals() 判断），相同时add()返回false。
3. 向Set中添加的数据，其所在类一定要重写`hashCode()`和`equals()`，保证相等的对象必须具有相等的散列码。

<table>
    <thead>
        <tr>
            <th width="15%">Set实现类</th>
            <th width="85%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>HashSet</td>
            <td>主要实现类
                <br />线程不安全
                <br />可存储null
            </td>
        </tr>
        <tr>
            <td>LinkedHashSet</td>
            <td>HashSet子类
                <br />遍历其内部数据时，可按照添加的顺序遍历
            </td>
        </tr>
        <tr>
            <td>TreeSet</td>
            <td>可按照添加对象的指定属性排序</td>
        </tr>
    </tbody>
</table>

#### Set添加元素（HashSet）

1. 向hashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在hashSet底层数组中的存放位置（索引），判断数组此位置上是否已经有元素。
2. 如果此位置上没有其他元素，则元素a添加成功 --情况1。
3. 如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值
4. 如果hash值不相同，则元素a添加成功 --情况2。
5. 如果hash值相同，进而需要调用元素a所在类的equals()方法。
   1. equals()返回true，元素a添加失败。
   2. equals()返回false，则元素a添加成功  --情况3。

- 对于添加成功的情况2和情况3而言，元素a与已经存在指定索引位置上的数据（元素b）以链表的方式存储。
- HashSet底层：数组+链表
  1. jdk 1.7 ：元素a放到数组中，指向原来的元素
  2. jdk 1.8 ：原来的元素在数组中，指向元素a

<img src="../../pictures/539705218221142.png" width="661"/>      

<img src="../../pictures/141841619239568.png" width="669"/> 


```java
Set set = new HashSet();
set.add(456);
set.add(123);
set.add("AA");
set.add("BB");
set.add(new Person("Mac",21));
set.add(new String("CC"));
System.out.println(set); //[AA, BB, CC, 456, com.zjk.java2.Person@75bd9247, 123]

// 不可重复性
set.add(123);
System.out.println(set); //[AA, BB, CC, 456, com.zjk.java2.Person@75bd9247, 123]
// 调用equals()方法比较,需要用到hashCode()方法，Integer 123发现相同，所以不添加

// Person类中未重写hashCode()方法和equals()方法,比较的还是地址，所以认为不一样
set.add(new Person("Mac",21));
System.out.println(set);// [AA, BB, CC, com.zjk.java2.Person@7d417077, 456, com.zjk.java2.Person@75bd9247, 123]
```

<img src="../../pictures/227085513239570.png" width="696"/> 

```java
HashSet hashSet = new HashSet();

Person p1 = new Person("Mac", 21);
Person p2 = new Person("Tom", 21);
hashSet.add(p1);
hashSet.add(p2);

p1.setName("AA");
//对应集合中的元素也改变,但是此时存放的位置还是按照原先p1("Mac",21)计算的哈希值存放的。
hashSet.forEach(System.out::println);
//Person{name='AA', age=21}
//Person{name='Tom', age=21}

hashSet.remove(p1);
//此时remove()寻找的哈希值，是修改后的p1("AA",21)的哈希值，无法和集合中p1的哈希值匹配，
// 故找不到，无法成功remove()
hashSet.forEach(System.out::println);
//Person{name='AA', age=21}
//Person{name='Tom', age=21}

Person p3 = new Person("AA",21);
hashSet.add(p3);
//同理，此时在集合中，存放("AA",21)计算的哈希值的位置实际上是空的，所以可以添加
hashSet.forEach(System.out::println);
//Person{name='AA', age=21}
//Person{name='Tom', age=21}
//Person{name='AA', age=21}
```

### HashSet

- HashSet 按 Hash 算法来存储集合中的元素。

1. 不能保证元素的排列顺序、HashSet 不是线程安全的、集合元素可以是 null。
2. HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。
3. 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。（“相等的对象必须具有相等的散列码”）

### LinkedHashSet

- LinkedHashSet在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。因此，对于频繁的遍历操作，LinkedHashSet效率高于HashSet。

<img src="../../pictures/208262222221142.png" width="609"/>   

### TreeSet

- TreeSet：红黑树结构。向TreeSet中添加的数据，要求是相同类的对象   

# Map

## Map体系与性质

- Map：双列数据，存储键值对Entry（key-value）。

<img src="../../pictures/453525713247603.png" width="502"/>   

<table>
    <thead>
        <tr>
            <th width="15%">实现类</th>
            <th width="85%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>HashMap</td>
            <td>主要实现类
                <br />线程不安全，效率高
                <br />可存储null的key和value。
            </td>
        </tr>
        <tr>
            <td>LinkedMap</td>
            <td>按照添加的顺序实现遍历（频繁遍历操作）。</td>
        </tr>
        <tr>
            <td>TreeMap</td>
            <td>按照添加的key排序。</td>
        </tr>
        <tr>
            <td>Hashtable</td>
            <td>古老的实现类
                <br />线程安全，效率低
                <br />不能存储null的key和value。
            </td>
        </tr>
        <tr>
            <td>Properties</td>
            <td>处理配置文件
                <br />key和value都是String类型。
            </td>
        </tr>
    </tbody>
</table>

- Map与Collection并列存在，保存具有映射关系的数据（key-value）。
- key 和 value 之间存在单向一对一关系（通过指定的 key 总能找到唯一的、确定的 value）。

| 单元  | 存储       | 数据          |
| ----- | ---------- | ------------- |
| key   | Set        | 任何引用类型  |
| value | Collection | 任何引用类型  |
| Entry | Set        | key-value构成 |

<img src="../../pictures/235545813240272.png" width="400"/>   

<table>
	<thead>
		<tr>
			<th width="70%">方法</th>
			<th width="30%">操作</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Object put(Object key,Object value)
				<br />void putAll(Map map)
			</td>
			<td>添加</td>
		</tr>
		<tr>
			<td>Object remove(Object key)
				<br />void clear()
			</td>
			<td>删除（返回value）
				<br />清空
			</td>
		</tr>
		<tr>
			<td>Object get(Object key)
				<br />boolean containsKey(Object key)
				<br />boolean containsValue(Object value)
				<br />int size()
				<br />boolean isEmpty()
				<br />boolean equals(Object obj)
			</td>
			<td>查</td>
		</tr>
		<tr>
			<td>Set keySet()
				<br />Collection values()
				<br />Set entrySet()
			</td>
			<td>视图</td>
		</tr>
	</tbody>
</table>
## HashMap

### HashMap的性质

| 属性                       | 说明                                                         |
| :------------------------- | :----------------------------------------------------------- |
| `DEFAULT_INITIAL_CAPACITY` | HashMap的默认容量，16                                        |
| `MAXIMUM_CAPACITY`         | HashMap的最大支持容量，2^30                                  |
| `DEFAULT_LOAD_FACTOR`      | HashMap的默认加载因子(0.75)                                  |
| `TREEIFY_THRESHOLD`        | Bucket中链表长度大于该默认值，转化为红黑树(8)                |
| `UNTREEIFY_THRESHOLD`      | Bucket中红黑树存储的Node小于该默认值，转化为链表             |
| `MIN_TREEIFY_CAPACITY`     | 桶中的Node被树化时最小的hash表容量。<br>当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。 |
| `table`                    | 存储元素的数组，总是2的n次幂                                 |
| `entrySet`                 | 存储具体元素的集                                             |
| `size`                     | HashMap中存储的键值对的数量                                  |
| `modCount`                 | HashMap扩容和结构改变的次数。                                |
| `threshold`                | 扩容的临界值，= 容量`*`填充因子 (`16*0.75`)<br>提前扩容，为了减少链表的长度。 |
| `loadFactor`               | 填充因子                                                     |

> **负载因子值的大小，对HashMap有什么影响？**
>
> - 负载因子的大小决定了HashMap的数据密度。负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容会影响性能，建议初始化预设大一点的空间。
> - 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。

### 底层实现

HashMap的底层实现：

- jdk1.7之前 : 数组+链表 
- jdk1.8 : 数组+链表+红黑树  

#### JDK7

- `HashMap map = new HashMap()`;

1. 在实例化以后，底层创建了长度是16的一维数组Entry[] table。

- `map.put(key1,value1)`;  ...假设之前可能已经执行过多次put...

1. 首先，调用key1所在类的hashCode()计算key1的哈希值，此哈希值经过某种算法计算之后，得到Entry数组中的存放位置。
2. 如果此位置上的数据为空，此时的key1-value1添加成功   **情况1**
3. 如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据（以链表形式存在）），比较key1和已经存在的一个或多个数据的哈希值。
4. 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功  **情况2**
5. 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals()来比较。
6. 如果equals()返回false：此时key1-value1添加成功  **情况3**
7. 如果equals()返回true：使用value1替换相同key的value值(value2)。 

- 关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。
- 在不断的添加（`put()`）过程中会涉及到扩容问题：

1. 当超过临界值threadshould（12）时，且要存放的位置非空时，扩容。
2. 默认的扩容方式：扩容为原来容量的2倍，并将原来的数据复制过来。

<img src="../../pictures/331595916239572.png" width="851"/>   

#### JDK8

1. `new HashMap()`底层没有创建一个长度为16 的数组。
2. jdk1.8 底层的数组是 `Node[]`  而非`Entry[]`。
3. 首次调用put()方法时，底层创建长度为16的数组。
4. jdk1.7的底层结构只有数组+链表；而jdk1.8的底层结构是数组+链表+红黑树
5. jdk1.7新的元素指向旧的元素，jdk1.8旧的元素指向新的元素。

- 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64，此时，此索引位置上的所有数据改为使用红黑树存储。 

<img src="../../pictures/506635916227439.png" width="920"/>   

## LinkedHashMap

- LinkedHashMap中定义内部类Node替换了HashMap中的Entry，在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。

```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

## TreeMap

1. TreeMap存储键值对时，需要根据键值对进行排序，保证所有的键值对处于有序状态。
2. TreeMap底层使用红黑树结构存储数据，要求所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException。

<table>
	<thead>
		<tr>
			<th width="10%">Key排序</th>
			<th width="90%">说明</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>自然排序</td>
			<td>所有的 Key 必须实现 <a href="./常用工具类#比较器">Comparable</a> 接口。</td>
		</tr>
		<tr>
			<td>定制排序</td>
			<td>创建 TreeMap 时，传入一个Comparator对象负责对TreeMap 中的所有 key 进行排序。
				<br />此时不需要Key实现Comparable 接口。
			</td>
		</tr>
	</tbody>
</table>


- TreeMap判断两个key相等的标准是两个key通过`compareTo()`方法或`compare()`方法返回0，而不是`equals()`。

```java
Person p1 = new Person("Tom", 21);
Person p2 = new Person("Jac", 23);
Person p3 = new Person("Mac", 19);

TreeMap map = new TreeMap();

map.put(p1, 99);
map.put(p2, 98);
map.put(p3, 100);

// 自然排序
// Person类中重写了Comparable接口的compareTo()方法
Set entrySet = map.entrySet();
Iterator iterator = entrySet.iterator();
while (iterator.hasNext())
    System.out.println(iterator.next());

TreeMap treeMap = new TreeMap(new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
        if (o1 instanceof Person && o2 instanceof Person) {
            Person p1 = (Person) o1;
            Person p2 = (Person) o2;

            return p1.getAge() - p2.getAge();
        }
        throw new RuntimeException("数据类型不一致");
    }
});
treeMap.putAll(map);


Set entrySet1 = treeMap.entrySet();
Iterator iterator1 = entrySet1.iterator();
while (iterator1.hasNext())
    System.out.println(iterator1.next());
}
```

## Properties

- Properties 类是 HashTable 的子类，该对象用于处理属性文件。由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型。

<table>
	<thead>
		<tr>
			<th width="60%">方法</th>
			<th width="40%">操作</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>setProperty(String key,String value)</td>
			<td>存</td>
		</tr>
		<tr>
			<td>getProperty(String key)</td>
			<td>取</td>
		</tr>
	</tbody>
</table>

```java
Properties properties = new Properties();

FileInputStream fileIn = new FileInputStream("jdbc.properties");

properties.load(fileIn); // 加载流对应的文件

String name = properties.getProperty("name");
String password = properties.getProperty("password");

System.out.println("name=" + name + "\n" + "passsword=" + password);
fileIn.close();
```

# Collections 集合工具类

## Collections概述

- Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。

<table>
	<thead>
		<tr>
			<th width="60%">方法（static）</th>
			<th width="40%">说明</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>reverse(List)</td>
			<td>反转</td>
		</tr>
		<tr>
			<td>shuffle(List)</td>
			<td>随机排序</td>
		</tr>
		<tr>
			<td>sort(List)
				<br />sort(List, Comparator)
			</td>
			<td>根据元素的自然顺序按升序排序
				<br />根据指定的Comparator排序
			</td>
		</tr>
		<tr>
			<td>swap(List, int, int)</td>
			<td>指定i处元素和j处元素进行交换</td>
		</tr>
		<tr>
			<td>Object max(Collection)
				<br />Object max(Collection，Comparator)
				<br />Object min(Collection)
				<br />Object min(Collection，Comparator)
			</td>
			<td>查找</td>
		</tr>
		<tr>
			<td>int frequency(Collection，Object)</td>
			<td></td>
		</tr>
		<tr>
			<td>void copy(List dest,List src)</td>
			<td>src中的内容复制到dest中
				<br />IndexOutOfBoundsException: Source does not fit in dest
			</td>
		</tr>
		<tr>
			<td>boolean replaceAll(List list，Object oldVal，Object newVal)</td>
			<td>替换</td>
		</tr>
	</tbody>
</table>
## synchronizedList() 同步控制


- Collections的同步控制：提供多个 synchronizedXxx() 方法，将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。

```java
List list = new ArrayList();
list.add(123);

// Collections.synchronizedXxx() 返回线程安全的
// 返回线程安全的list
List safeList = Collections.synchronizedList(list);
```