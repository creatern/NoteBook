# 概述

## 程序、进程、线程

- **程序(program)** 是为完成特定任务、用某种语言编写的一组指令的集合。
  - 即指一段静态的代码，静态对象。
  - 作为执行蓝本的同一段程序，可以被多次加载到系统的不同内存区域执行，形成不同进程。
- **进程(process)是程序的一次执行过程，或是正在运行的一个程序。是由代码，数据，内核状态和一组寄存器组成**
  - 进程是一个内核级的实体，进程结构的所有成分都在内核空间中。
    - 一个用户程序不能直接访问这些数据   
  - 进程的生命周期：一个程序的一次动态执行过程：自身的产生、存在和消亡的过程。
    - **一个进程在其执行的过程中，可以产生多个线程，形成多个执行流。每个线程也有其生命周期。**
  - **进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域**
- **线程(thread)** ：进程可进一步细化为线程（轻型进程），是一个程序内部的一条执行路径（执行流）。 **线程是由表示程序运行状态的寄存器（程序计数器，栈指针等）以及堆栈组成** 。线程是计算过程在某一时刻的状态。
  - 线程是一个用户级的实体，线程结构驻留在用户空间中，
    - 能被普通的用户级函数直接访问。 
  - 若一个进程同一时间并行执行多个线程，就是支持多线程的。
  - 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。
  - 一个进程中的多个线程共享相同的内存单元/内存地址空间，线程包含进程地址空间中的代码和数据。（多个线程共享同一个进程中的方法区和堆）
    - 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患
    - 当两个线程对同一个对象进行访问时，他们将共享数据。
  - **一个执行流是由CPU运行程序代码并操作程序的数据所形成的**，
    - 线程被认为是以CPU为主体的行为，  

## 单核CPU、多核CPU

- 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务（可以将一个线程挂起，先执行其他的线程），但是因为CPU时间单元特别短，因此感觉不出来。
- 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器(Linux,Windos Server)都是多核的）
- 一个Java应用程序java.exe，其实**至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程**。
  - 当然如果发生异常，会影响主线程。

## 并行与并发

- 并行：多个CPU同时执行多个任务。
- 并发：一个CPU(采用时间片)同时执行多个任务。

## 多线程的优点

1.  提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
2.  提高计算机系统CPU的利用率
3.  改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

- 程序需要同时执行两个或多个任务。
- 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。
- 需要一些后台运行的程序时。

## 线程

- Java语言的JVM允许程序运行多个线程，它通过`java.lang.Thread类`来体现。
- 继承Thread类的方式
- 实现Runnable接口的方式

## 线程的分类

Java中的线程分为两类：一种是守护线程，一种是用户线程。

- 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。
- 守护线程是用来服务用户线程的，通过在start()方法前调用
- `Thread.setDaemon(true)`可以把一个用户线程变成一个守护线程。
- Java垃圾回收就是一个典型的守护线程。
  - 若JVM中都是守护线程，当前JVM将退出

# 创建


## Thread类

### 继承Thread类

- 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。

| 构造器                                               | 说明                                               |
| :--------------------------------------------------- | :------------------------------------------------- |
| Thread()                                             | 创建新的Thread对象                                 |
| Thread(String threadname)                            | 创建线程并指定线程实例名                           |
| Thread(Runnable target)                              | 指定实现Runnable接口的线程体对象                   |
| Thread(Runnable target, String name)                 | 指定实现Runnable接口的线程体对象、线程名称         |
| Thread(TreadGroup group,Runnable target,String name) | 指明该线程所属的线程组、提供线程体的对象、线程名称 |

1. 定义子类继承Thread类。
2. 子类中重写Thread类中的run方法。
   - 将此线程执行的操作声明在run()中
3. 创建Thread子类对象，即创建了线程对象。
4. 调用线程对象start方法：启动线程，调用run方法。

**注意点：**

1. 调用start()方法来启动线程，线程体run()方法由JVM调用（由操作系统的CPU调度决定）。如果直接调用run()方法则没有启动线程。
2. 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出异常“IllegalThreadStateException”。

```java
public class ThreadTest {
    public static void main(String[] args) { //主线程
      //3.创建Thread类的子类的对象 //主线程
        MyThread t1 = new MyThread();
      //4.通过此对象调用start() //主线程
        t1.start();
      //在主线程中创建t1对象，在当前线程中执行(与main线程一起执行)
      //4.1 启动当前线程
      //4.2 调用当前线程的run()

      //再启动一个线程
      //t1.start();  
      //不能令已经调用start()的对象来再启动一个线程，否则报错,需要重新创建一个线程对象来调用start()
        MyThread t2 = new MyThread();
        t2.start();

        //以下仍然是在main线程中执行的。
        for (int i = 0; i < 100; i++) {
            if (i % 2 != 0) {
                System.out.println(i + "*");
                System.out.println(Thread.currentThread().getName());
            }
        }
    }
}

//1.创建Thread类的子类
class MyThread extends Thread {
    @Override
//    2.重写run()方法
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i + "-");
                System.out.println(Thread.currentThread().getName());
            }
        }
    }
}
```

### Thread类的方法

| 方法               | 说明                                                         |
| :----------------- | :----------------------------------------------------------- |
| start()            | 启动当前线程，并调用当前线程的run()方法                      |
| run()              | 线程体：线程在被调度时执行的操作，重写此方法。               |
| yield()            | 线程让步(释放当前CPU的执行权)（有可能立刻又被赋予执行权）<br>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程<br> 若队列中没有同优先级的线程，忽略此方法 |
| join()             | 当某个程序执行流中调用其他线程的 join() 方法时，该线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止，该线程才结束阻塞状态。<br>低优先级的线程也可以获得执行 |
| sleep(long millis) | 线程睡眠(毫秒)，在睡眠时间内，当前线程是阻塞状态。<br>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。<br> 抛出InterruptedException异常 |
| stop()             | 强制线程生命期结束，不推荐使用（已过时）                     |
| suspend()          | 使另一个线程(`线程对象.suspend()`)暂停执行，要想恢复，需要其他线程使用resume()方法。<br>容易造成死锁<br>如果存在a.b两线程使用同一个锁，在a线程中使用了 `b.suspend()`使得b线程阻塞，但是b线程并未释放锁，那么a线程也无法打开锁。于是死锁。 |
| resume()           | 恢复线程                                                     |
| interrupt()        | 中断线程的阻塞，并且该线程收到InterruptException异常.        |

## ThreadGroup类 线程组

- Java中每个线程都属于某个线程组。线程组使一组线程可以作为一个对象进行统一处理或维护。
- 一个线程只能在创建时设置其所属的线程组，在线程创建后就不允许将线程从一个线程组移到另一个线程组。

- 线程组是由java.lang包中的ThreadGroup类实现的。在创建线程时可以显式地指定线程组，此时需要从如下3种线程构造方法中选择一种：
  - public Thread(ThreadGroup group,Runnable target);
  - public Thread(ThreadGroup group,String name);
  - public Thread(ThreadGroup group,Runnable target,String name);

- 若在线程创建时并没有显式指定线程组，则新创建的线程自动属于父线程所在的线程组。
  - 在Java应用程序启动时，Java运行系统为该应用程序创建了一个称为main的线程组，如果以后创建的线程没有指定线程组，则这些线程都将属于main线程组。


**ThreadGroup类对Java应用程序中的线程组进行管理。**

- 一个线程组可以包含任意数目的线程。
- 一个线程组内不仅可以包含线程，还可以包含其他线程组。
- 在Java应用程序中，最顶层线程组是main。
  - 在main中可以创建线程或线程组，并且可以在main的线程组中进一步创建线程组，因此在Java应用程序中，形成了以main为根的线程与线程组的树状结构。

## Runnable接口

### 实现Runnable

```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```

```java
public class RunnableTest {
    public static void main(String[] args) {
      //3.Thread类构造器：new Thread(Ruannable target)
        Thread t = new Thread(new RunTest());
      //4.调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。
        t.start();
    }
}

//1.定义子类，实现Runnable接口
class RunTest implements Runnable {
   //2.子类中重写Runnable接口中的run方法
    @Override
    public void run() {
        //代码
    }
}
```

### Thread和Runnable比较

**Thread实现Ruannable接口**

```java
public class Thread extends Object implements Runnable
```

1. Tread类实现了Runnable接口
2. 都需要重写run()

**区别**

- 继承Thread：线程代码存放Thread子类run方法中。
- 实现Runnable：线程代码存在接口的子类的run方法。

**优点比较：**

- 继承Tread类：
  - 代码简单 
- 实现Runnable接口
  1. 避免了单继承的局限性。
  2. 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。
  3. 符合OOP的设计思想。从OO设计的角度，Tread类时虚拟CPU的封装，其子类也应该与CPU有关，但在继承Tread类的子类构造线程的方法中，其子类大多也与CPU无关。

## Callable接口

与使用Runnable相比， Callable功能更强大些

- call()方法相比run()方法，可以有返回值
- call()方法可以抛出异常,被外面的操作捕获，获取异常的信息
- Callable支持泛型的返回值
- 需要借助FutureTask类，比如获取返回结果

**Future接口**

-  可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。
-  FutrueTask是Futrue接口的唯一的实现类
-  FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值

**使用：**

1. 创建一个Callable接口的实现类
2. 实现call()方法，将此线程需要执行的操作声明在call()方法中
3. 创建一个Callable接口实现类的对象
4. 将Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象
5. 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法启动线程
6. （可选）获取callable中的call方法的返回值 

**例**

```java
public class TreadNew {
    public static void main(String[] args) {
//      3. 创建一个Callable接口实现类的对象
        NumTread numTread = new NumTread();
//      4. 将Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numTread);
//        FutureTask<Integer> futureTask = new FutureTask<Integer>(numTread); //支持泛型
//      5. 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法启动线程
        new Thread(futureTask).start();

        try {
//            6. 获取callable中的call方法的返回值
            //get()的返回值即为FutureTask构造器参数Callable实现类重写的call()方法的返回值
            Object sum = futureTask.get();
//            Integer sum = futureTask.get();//支持泛型
            System.out.println(sum);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    }
}

//1. 创建一个Callable接口的实现类
class NumTread implements Callable {
    //class NumTread implements Callable<Integer> { //支持泛型
    //    2. 实现call()方法，将此线程需要执行的操作声明在call()方法中
    @Override
//    public Integer call() throws Exception {//支持泛型
    public Object call() throws Exception {
        int sum = 0; //自动装箱
        for (int i = 0; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}
```

## 线程池

- 提高响应速度（减少了创建新线程的时间）
- 降低资源消耗（重复利用线程池中线程，不需要每次都创建）
- 便于线程管理
  - corePoolSize：核心池的大小
  - maximumPoolSize：最大线程数
  - keepAliveTime：线程没有任务时最多保持多长时间后会终止
  - ...

```java
public class ThreadPool {
    public static void main(String[] args) {
//        1.提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);

//        设置线程池的属性
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
//        System.out.println(service.getClass());
        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();

//        2.执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread()); //适合使用于Runnable
        service.execute(new NumberThread1()); //适合使用于Runnable
//        service.submit(Callable接口的实现类对象); //适合使用于Callable
        service.shutdown();
    }
}

class NumberThread implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}

class NumberThread1 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}
```

### 线程池相关API

- JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors

**ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor**

-  void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable
   - `<T> Future<T> submit(Callable<T> task)`：执行任务，有返回值，一般又来执行Callable
-  void shutdown() ：关闭连接池

**Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池**

- Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池
- Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池
- Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池
- Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

# 调度 优先级

- 线程的调度：在单个CPU上以某种顺序运行多个线程。

**调度策略**

- 时间片：同优先级线程组成先进先出队列（先到先服务），使用时间片策略

<img src="../../../pictures/9075515221057.png" width="212"/>   

- 抢占式：高优先级的线程抢占CPU：对高优先级，使用优先调度的抢占式策略

**调度方法**

- getPriority() ：返回线程优先值
- setPriority(int newPriority) ：改变线程的优先级

| 优先级        | 数值 |
| :------------ | :--- |
| MAX_PRIORITY  | 10   |
| MIN_PRIORITY  | 1    |
| NORM_PRIORITY | 5    |

- 一般，主线程具有普通优先级NORM_PRIOPITY
- 线程创建时继承父线程的优先级
  - 父线程：执行创建新线程语句所在线程。 

**基于优先级的抢先式调度**

- Java基于线程的优先级选择高优先级的线程进行运行。该线程（当前线程）将持续运行，直到它中止运行，或其他高优先级线程成为可运行的。
  - 当其他高优先级线程成为可运行的时，低优先级线程被高优先级线程抢占运行。
    - 线程中止运行的原因可能有多种，如执行Thread.sleep()调用，或等待访问共享资源。
  - 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。
- 在Java运行系统中可以按优先级设置多个线程等待池，JVM先运行高优先级池中的线程，高优先级等待池空后，才考虑低优先级。如果线程运行中有更高优先级的线程成为可运行的，则CPU将被高优先级线程抢占。
- 抢先式调度可能是分时的，即每个同等优先级池中的线程轮流运行，也可能不是，即线程逐个运行，由具体JVM而定。
  - 线程一般通过使用sleep()等方法保证给其他线程运行时间。

# 生命周期

**JDK中用Thread.State类定义了线程的几种状态**

- 新建状态 new： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
  - 线程还未被分配有关的系统资源。 
- 就绪（可运行）状态 runnable：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源
  - 表示系统处于运行就绪状态，此时线程仅仅是可以运行。
  - start()方法使系统为线程分配必要的资源，将线程中虚拟的CPU置为Runnable状态，并将线程交给系统调度。
  - 在多线程程序设计中，系统中往往会有多个线程同时处于Runnable状态，他们将 竞争有限的CPU资源，有运行系统根据线程调度策略进行调度
- 运行状态：当就绪的线程被调度并获得CPU资源时,便进入运行状态（线程占有CPU并实际运行的状态）， run()方法定义了线程的操作和功能 。此时线程状态的变迁有以下三种：
  1. 如果线程正常执行结束或应用程序停止运行，线程将进人终止状态。
  2. 如果当前线程执行了yild()方法，或者当前线程因调度策略（执行过程中，有一个更高优先级的线程进入可运行状态，这个线程立即被调度执行，当前线程占有的CPU被抢占；或在分时方式时，当前执行线程执行完当前时间片)由系统控制进入可运行状态。
  3. 如果发生下面几种情况时，线程就进入阻塞状态。
     - 线程调用了sleep()方法或join()方法，进入阻塞状态。
     - 线程调用wait()方法时，由运行状态进入阻塞状态。
     - 如果线程中使用synchronized来请求对象的锁未获得时，进入阻塞状态。
     - 如线程中有输入/输出操作，也将进入阻塞状态，待输入/输出操作结束后，线程进入可运行状态。
- 阻塞状态：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态。
  - 对象锁阻塞： 如果线程中使用synchronized来请求对象的锁但未获得时，进人对象锁阻塞状态。
    - 该状态下的线程当获得对象锁后，将进人可运行状态。
  - 等待阻塞：线程调用wait()方法时，线程由运行状态进人等待阻塞状态。
    - 在等待阻塞状态下的线程若被notify()和notifyAll()唤醒，被interrupt()中断或者等待时间到，线程将进入对象锁阻塞状态。
  - 其他阻塞：线程调用了sleep()方法或join()方法时，线程进人其他阻塞状态。
    - sleep()方法而进人其他阻塞状态的线程，睡眠时间到时将进人可运行状态，
    - join()方法而进人其他阻塞状态的线程，当其他线程结束或等待时间到时，进入可运行状态。
- 死亡(终止)状态：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。
  - 终止状态是线程执行结束的状态，没有任何方法可改变它的状态。
    <img src="../../../pictures/204051510227351.png" width="701"/>     

# 同步

  - 对多条操作共享数据(多个线程共同操作的变量，如static)的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。

## synchronized 同步锁机制

- 对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。

### synchronized 对象锁

- 临界区(critical sections)：一个程序的各个并发线程中对同一个对象进行访问的代码段。在Java语言中，临界区可以是一个语句块或是一个方法，并且用synchronized关键字标识。

- 对象锁：临界区的控制是通过对象锁进行的。Java将每个由`synchronized(someObject){}`语句指定的对象someObject设置一个锁，称为对象锁(monitor)。对象锁是一种独占的排他锁(exclusive locks)。当一个线程获得了对象的锁后，便拥有该对象的操作权，其他任何线程不能对该对象进行任何操作。线程在进入临界区时，首先通过`synchronized(someObject)`语句测试并获得对象的锁，只有获得对象锁才能继续执行临界区中的代码，否则将进入等待状态。

- 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。

#### 对象锁的使用

1. 关于对象锁的返还。对象的锁在如下几种情况下由持有线程返还。
   - 当synchronized()语句块执行完后
   - 当在synchronized()语句块中出现异常(Exception)。
   - 当持有锁的线程调用该对象的wait()方法。此时该线程将释放对象的锁，而被放人对象的wait pool中，等待某种事件的发生。
2. 共享数据的所有访问都必须作为临界区，使用synchronized进行加锁控制。
   - 对共享数据所有访问的代码，都应该作为临界区使用synchronized进行标识。这样保证所有的操作都能够通过对象锁的机制进行控制。
   - 如果有一种访问操作未标记为synchronized,则这种操作将绕过对象锁，很可能破坏共享数据的一致性。
3. 用synchronized保护的共享数据必须是私有的。
   - 将共享数据定义为私有的，使线程不能直接访问这些数据，必须通过对象的方法。
   - 而对象的方法中带有由synchronized标记的临界区，实现对并发操作多个线程的控制。
4. 同步方法：如果一个方法的整个方法体都包含在synchronized语句块中，则可以把该关键字放在方法的声明中。
   - 这种方式程序的可读性好，便于理解，因此比较常用。
   - 但控制对象锁的时间稍长，因此并发执行的效率会受到一定的影响，但影响不是很大。
5. Java中对象锁具有可重入性。
   - Java运行系统中，一个线程在持有某个对象的锁的情况下，可以再次请求并获得该对象的锁，这就是对象锁具有可重入性的含义。
   - 锁的可重入性是很重要的因为这可以避免单个线程因为自已已经持有的锁而产生死锁。

#### 同步的范围

1. 如何找问题，即代码是否存在线程安全？（非常重要）
   1. 明确哪些代码是多线程运行的代码
   2. 明确多个线程是否有共享数据
   3. 明确多线程运行代码中是否有多条语句操作共享数据
2. 如何解决呢？（非常重要）
   - 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。
     - 即所有操作共享数据的这些语句都要放在同步范围中
3. 切记：
   - 范围太小：没锁住所有有安全问题的代码
   - 范围太大：没发挥多线程的功能。**

#### 对象锁的释放

**释放锁的操作**

-  当前线程的同步方法、同步代码块执行结束。
-  当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
-  当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
-  当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。

**不会释放锁的操作**

- 线程执行同步代码块或同步方法时，程序调用`Thread.sleep()、Thread.yield()方法`暂停当前线程的执行
- 线程执行同步代码块时，其他线程调用了该线程的`suspend()方法`将该线程挂起，该线程不会释放锁（同步监视器）。
  - 应尽量避免使用`suspend()和resume()`来控制线程

### 死锁

- **不同的线程分别占用对方需要的同步资源不放弃** ，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
- 出现死锁后， **不会出现异常，不会出现提示** ，只是所有的线程都处于阻塞状态，无法继续

1. 专门的算法、原则
2. 尽量减少同步资源的定义
3. 尽量避免嵌套同步

### 不同临界区的锁

- 同步方法的锁：静态方法（类名.class）、非静态方法（this）
- 同步代码块：自己指定，很多时候也是指定为this或类名.class

1. 必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全
2. 一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）

#### 同步代码块

```java
synchronized (同步监视器对象){  
    // 需要被同步的代码；(即操作共享数据的代码)
}
```

1. 操作共享数据（static修饰的等）的代码，即需要被同步的代码。
2. 同步监视器（对象锁）：多个线程必须要共用同一把锁。
3. 解决了线程的安全问题。操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。

##### 对象锁的选择

- 实现Runnable接口：在创建多个线程时是同一个Runnable对象内的方法体。
  - this  
  - 类名.class 
  - run()方法外的对象
- 继承Thread类：在创建多个线程时是不同的Thread对象内的方法体。
  - 慎用this 
  - 类名.class 
  - run()方法外的静态对象（static）

```java
public class WindowTest2 {
    public static void main(String[] args) {
        Windows w1 = new Windows();

        Thread t1 = new Thread(w1);
        Thread t2 = new Thread(w1);
        Thread t3 = new Thread(w1);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

class Windows implements Runnable {
    private int ticket = 100;
    private static int tickets = 100;
    Object obj = new Object();

    @Override
    public void run() {
        while (true) {
//            Object obj = new Object(); 错误
            //synchronized (obj) { //要求线程必须共用同一把锁
            //synchronized(this){ //使用当前对象作锁。此时的this：唯一的Windows的对象。
            synchroniaed(Window.class){  //通过类作为锁，类也是对象。
            //如果都是使用同一个Runnable接口的实现类的对象来创建线程时。
                if (tickets > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + "卖票，票号为：" + tickets);
                    tickets--;
                } else {
                    break;
                }
            }
        }
    }
}
```

```java
public class WindowTest {
    public static void main(String[] args) {
        Window w1 = new Window();
        Window w2 = new Window();
        Window w3 = new Window();

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }

}

class Window extends Thread {
    private static int tickets = 100;
    static Object obj = new Object(); //static 确保线程使用同一把锁

    @Override
    public void run() {
        while (true) {
//            Object obj = new Object(); 错误
            //synchronized (obj) { //要求线程必须共用同一把锁
            synchroniaed(Window.class){  //通过类作为锁，类也是对象。
                if (tickets > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(getName() + "卖票，票号为：" + tickets);
                    tickets--;
                } else {
                    break;
                }
            }
        }
    }
}
```

#### 同步方法

- synchronized还可以放在方法声明中，表示整个方法为同步方法。

- 实现Runnable接口的同步监视器：this。
- 继承Tread类的线程：如果此时的同步方法是静态的，则同步监视器为当前类。

```java
public class WindowTest2 {
    public static void main(String[] args) {
        Windows w1 = new Windows();

        Thread t1 = new Thread(w1);
        Thread t2 = new Thread(w1);
        Thread t3 = new Thread(w1);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }


}

class Windows implements Runnable {
    private int ticket = 100;
    Object obj = new Object();

    @Override
    public void run() {
        while (true) {
//            Object obj = new Object(); 错误
            changeTicket();
        }

    }

    public synchronized void changeTicket() {//同步监视器：this
        if (ticket > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + "卖票，票号为：" + ticket);
            ticket--;
        }
    }
}
```

```java
public class WindowTest {
    public static void main(String[] args) {
        Window w1 = new Window();
        Window w2 = new Window();
        Window w3 = new Window();

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }

}

class Window extends Thread {
    private static int ticket = 100;

    @Override
    public void run() {
        while (true) {
            changeTicket();
        }
    }

    public static synchronized void changeTicket() {//同步监视器： 类（静态方法）
        if (ticket > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + "卖票，票号为：" + ticket);
            ticket--;
        }
    }
}
```


## Lock 同步锁对象

- Lock：显式定义的同步锁对象。
- `java.util.concurrent.locks.Lock接口`是控制多个线程对共享资源进行访问的工具，提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

- ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。
- 对于继承Tread类的方式，对ReentrantLock对象加static

```java
public class LockTest {
    public static void main(String[] args) {
        Window w = new Window();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }

}

class Window implements Runnable {
    private int ticket = 100;
    //1.实例化
    private ReentrantLock lock = new ReentrantLock();
//    private ReentrantLock lock = new ReentrantLock(true);
//    true：公平 即不会一直都是一个线程抢占执行
//    默认false

    @Override
    public void run() {
        while (true) {
            try{
//                2.调用锁定lock()方法
                lock.lock();
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + ", 票号:" + ticket);
                    ticket--;
                } else {
                    break;
                }
            }finally {
//                3. 调用解锁unlock()的方法
                lock.unlock();
            }

        }
    }
}
```

### synchronized 与 Lock 的对比

1. Lock是显式锁（手动开启(lock())和关闭锁(unlock())），synchronized是隐式锁，出了作用域自动释放同步监视器。
2. Lock只有代码块锁，synchronized有代码块锁和方法锁
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）

**优先使用顺序：**

Lock --> 同步代码块（已经进入了方法体，分配了相应资源）--> 同步方法（在方法体之外）

# 通信

**wait() 与 notify() 和 notifyAll()**

- wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用`notify()或notifyAll()`方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。
- notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待
- notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.

这三个方法**只有在`synchronized方法或synchronized代码块`中才能使用**，否则会报`java.lang.IllegalMonitorStateException`异常。

- 因为这三个方法**必须由锁对象(即必须是同步代码/同步方法的同步监视器)调用**，
  - 而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在**Object类中声明**

## wait() 方法

- 在当前线程中调用方法： 对象名.wait()
- 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。
- 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）
- 调用此方法后，当前线程将释放对象监控权(释放锁，即打开了锁，其他线程得以进入) ，然后进入等待
- 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。

### sleep()和wait()的异同点

**相同：**

- sleep()和wait()两个执行方法，都可以使得当前的线程进入阻塞状态

**不同：**

1. 声明位置不同：
   - sleep()在Tread类中声明
   - wait()在Object类中声明
2. 调用的要求不同：
   - sleep()可以在任何需要的场景下调用
   - wait()必须使用在同步代码块和同步方法中
3. 是否释放同步监视器：（ 如果两个方法都使用在同步代码块/同步方法中 ）
   - sleep()不释放
   - wait()释放

## notify()/notifyAll()

- 在当前线程中调用方法： 对象名.notify()
- 功能：唤醒等待该对象监控权的一个/所有线程(被wait()的线程)。
- 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）

### 典例：生产者消费者问题

生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。

- 这里可能出现两个问题：

1. 生产者比消费者快时，消费者会漏掉一些数据没有取到。
2. 消费者比生产者快时，消费者会取相同的数据。

```java
public class ProductTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p = new Producer(clerk);
        Thread p1 = new Thread(p);
        p1.setName("生产者1");

        Consumer c = new Consumer(clerk);
        Thread c1 = new Thread(c);
        c1.setName("消费者1");

        p1.start();
        c1.start();
    }
}

class Clerk {
    private int productCount = 0;

    //    生产产品
    public synchronized void produceProduct() {
        if (productCount < 20) {
            productCount++;
            System.out.println(Thread.currentThread().getName() + ": 开始生产第" + productCount + "个产品");

            notify();
        } else {
            try {
                wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    //    消费产品
    public synchronized void consumeProduct() {

        if (productCount > 0) {
            System.out.println(Thread.currentThread().getName() + ": 开始消费第" + productCount + "个产品");
            productCount--;

            notify();
        } else {
            try {
                wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class Producer implements Runnable { //消费者

    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ":生产产品...");

        while (true) {

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            clerk.produceProduct();
        }
    }
}

class Consumer implements Runnable { //消费者

    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ":消费产品...");

        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            clerk.consumeProduct();
        }
    }
}
```

### 生产者-消费者问题

编写生产者-消费者模式的程序。生产者每隔100ms产生0~9的一个数，保存在一个MyNumber类型的对象中，并显示出来。只要这个MyNumber对象中保存了新的数字，消费者就将其取出并显示。试定义MyNumber类，编写消费者和生产者程序，并编写主程序创建一个MyNumber对象，以及一个生产者线程、一个消费者线程，并将这两个线程启动运行。

```java
public class MyNumberTest {
    public static void main(String[] args) {
        MyNumber myNumber = new MyNumber();
        Productor p1 = new Productor(myNumber);
        Customer c1 = new Customer(myNumber);

        p1.setName("生产者1");
        c1.setName("消费者1");

        p1.start();
        c1.start();
    }
}

class MyNumber {
    private int num;

    public synchronized void productNewNumber() {
        num = (int) (Math.random() * 100 / 10);
        notify();
        try {
            wait();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void consumNewNumber() {
        if(num == 0){
            notify();
            try {
                wait();
            } catch (InterruptedException e) {
                x
            }
        }
        System.out.println("取出数字" + num);
        num = 0;
        notify();

        try {
            wait();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}

class Customer extends Thread {
    public Customer(MyNumber myNumber) {
        this.myNumber = myNumber;
    }

    MyNumber myNumber = new MyNumber();

    @Override
    public void run() {
        while (true) {
            myNumber.consumNewNumber();
            System.out.println(Thread.currentThread().getName() + "消费产品完成");
        }
    }
}

class Productor extends Thread {

    public Productor(MyNumber myNumber) {
        this.myNumber = myNumber;
    }

    private MyNumber myNumber = new MyNumber();

    @Override
    public void run() {
        while (true) {
            try {
                sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            myNumber.productNewNumber();
            System.out.println(Thread.currentThread().getName() + "生产产品完成");
        }
    }
}
```



1