# Linux信号

## Linux信号处理机制

- Linux通过信号与系统中的进程进行通信，信号（软件中断）是时间发生时对进程的通知机制。信号提供了一种进程间通信的方式，允许一个进程向另一个进程发送信息，用于进程之间的协作和同步。

1. 信号编号：每个信号都有一个唯一的信号编号，通常是正整数。
2. 信号名称：每个信号都有一个与之相关的名称。
3. 信号动作：对于每个信号，进程都可以指定它的处理动作。

- Linux的信号的目的是实现进程之间的通信、控制进程的行为和处理异步事件。

```shell
# 查看所有的信号和对应的编号
kill -l

 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMA
```

## 键盘产生信号

- bash shell允许使用键盘上的组合键来生成多种基本的Linux信号。

1. <kbd>Ctrl</kbd>+<kbd>C</kbd>会产生<code>SIGINT</code>信号（中断进程），并将其发送给当前在shell中运行的所有进程。
2. <kbd>Ctrl</kbd>+<kbd>Z</kbd>会产生<code>SIGTSTP</code>信号（暂停进程），停止shell中运行的任何进程，使其进入后台。
3. <kbd>Ctrl</kbd>+<kbd>\\</kbd>会产生<code>SIGQUIT</code>信号（退出进程），bash shell默认会忽略收到的任何<code>SIGOUT(3)</code>信号和<code>SIGTERM(15)</code>信号。

## trap 捕获信号

```shell
trap [-lp] [[arg] signal_spec ...]
```

- <code>trap</code>命令可以指定shell脚本需要侦测并拦截的Linux信号（可以是信号值或编号）。

1. 如果脚本收到了<code>trap</code>命令列出的信号，则该信号不再由shell处理，而是由本地处理。
2. <code>trap</code>命令会改变信号的原有意思，对其进行改造，在接收到对应信号时执行设置好的命令。

```shell
# 捕获SIGINT信号
trap "echo 'interrupt...failed!'" SIGINT

# 恢复SIGINT信号的默认设置
trap -- SIGINT
```

# Linux进程的信息

## Linux进程的属性与参数

- 进程包括交互进程、批处理进程、守护进程。
- 守护进程：系统开机时通过脚本自动激活启动或root用户启动；后台运行，一直运行；等待请求处理任务。

<table>
	<thead>
		<tr>
			<th align="left" width="10%">进程属性</th>
			<th align="left" width="90%">意义</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="left">PID</td>
			<td align="left">进程ID，唯一值，区分进程</td>
		</tr>
		<tr>
			<td align="left">PPID</td>
			<td align="left">父进程和父进程的PID</td>
		</tr>
		<tr>
			<td align="left">UID</td>
			<td align="left" rowspan="2">启动进程的用户ID和所归属的组ID</td>
		</tr>
        <tr>
            <td align="left">GID</td>
        </tr>
		<tr>
			<td align="left">进程状态</td>
			<td align="left">R（运行）、S（休眠）、Z（僵尸）</td>
		</tr>
		<tr>
			<td align="left">其他</td>
			<td align="left">进程执行的优先级、进程所连接的终端名、进程资源占用</td>
		</tr>
	</tbody>
</table>
<table>
	<tbody>
		<tr>
			<td width="5%">D</td>
			<td width="42.5%">不能被中断</td>
            <td width="5%" rowspan="7"></td>
            <td width="5%">R</td>
            <td width="42.5%">运行中、在队列中可过行的</td>
		</tr>
		<tr>
			<td>S</td>
			<td>休眠</td>
			<td>T</td>
			<td>停止、或被跟踪</td>
		</tr>
		<tr>
			<td>W</td>
			<td>进入内存交换（内核2.6之后失效）</td>
			<td>X</td>
			<td>死亡</td>
		</tr>
		<tr>
			<td>Z</td>
			<td>僵尸（进程完成了，但父进程没有响应）</td>
			<td>&lt;</td>
			<td>优先级较高</td>
		</tr>
		<tr>
			<td>N</td>
			<td>优先级较低</td>
			<td>L</td>
			<td>部分页被锁进内存</td>
		</tr>
		<tr>
			<td>S</td>
			<td>进程的领导者（拥有子进程）</td>
			<td>L</td>
			<td>多个进程的宿主</td>
		</tr>
		<tr>
			<td>+</td>
			<td>后台</td>
            <td></td>
            <td></td>
		</tr>
	</tbody>
</table>
## ps 静态进程监视

- ps（process）：进程监视，报告当前系统的进程状态（非动态）

<table><tbody><tr><td data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5">-a<strong data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5"></strong></td><td>显示所有进程信息 </td><td rowspan="14"><strong>&nbsp;</strong></td><td>-t <strong></strong></td><td data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5">显示属于指定终端主机的程序状态 </td></tr><tr><td>-c <strong></strong></td><td>不显示程序路径 <strong></strong></td><td>-T </td><td>显示当前终端主机下的所有程序 <strong></strong></td></tr><tr><td>-d <strong></strong></td><td>不显示阶段作业程序 </td><td>-u <strong></strong></td><td>使用用户为主的格式来显示程序状态 <strong></strong></td></tr><tr><td>-e </td><td>显示环境变量信息 <strong></strong></td><td>-U <strong></strong></td><td>显示属于指定用户的程序状态 </td></tr><tr><td>-f <strong></strong></td><td data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5">用ASCII字符显示树状结构 <strong data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5"></strong></td><td>-v </td><td>使用虚拟内存的格式显示程序状态 <strong></strong></td></tr><tr><td>-g <strong></strong></td><td>显示所有程序及其所属组的程序 </td><td>-w <strong></strong></td><td>使用宽阔的格式显示程序状态 <strong></strong></td></tr><tr><td>-h </td><td>不显示标题列信息 <strong></strong></td><td>-x <strong></strong></td><td>不区分终端主机 </td></tr><tr><td>-H <strong></strong></td><td>使用树状结构展示程序间的相互关系 <strong></strong></td><td>-X </td><td>使用旧式登录格式显示程序状态 <strong></strong></td></tr><tr><td>-j</td><td>使用工作控制格式显示程序状态</td><td>--cols</td><td>设置每列的最大字符数</td></tr><tr><td>-l</td><td>使用详细格式显示程序状态</td><td>--headers</td><td>重复显示标题列</td></tr><tr><td>-p</td><td>指定程序识别码并显示该程序的状态</td><td>--help</td><td>显示帮助信息</td></tr><tr><td>-r</td><td>仅显示终端主机正在执行中的程序</td><td>--info</td><td>显示排错信息</td></tr><tr><td>-s</td><td data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5">使用程序信号格式显示程序状态</td><td>--lines</td><td>设置显示画面的列数</td></tr><tr><td>-S</td><td data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5">显示包括已中断的子程序的状态</td><td>--version</td><td data-immersive-translate-effect="1" data-immersive_translate_walked="81ace535-7488-4eec-8e3e-38a3e5da32d5">显示版本信息</td></tr></tbody></table>

```shell
# ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 
root 2 0.0 0.0 0 0 ? S 20:05 0:00 [kthreadd]
```

| 参数    | 说明                                  |
| ------- | ------------------------------------- |
| USER    | 启动进程的用户名                      |
| PID     | 进程ID                                |
| %CPU    | 进程占用的CPU百分比                   |
| %MEM    | 进程使用的物理内存百分比              |
| VSZ     | 进程使用的虚拟内存总量 KB             |
| RSS     | 进程使用的、未被换出的物理内存大小 KB |
| TTY     | 终端ID                                |
| STAT    | 进程状态                              |
| START   | 启动进程的时间                        |
| TIME    | 进程消耗CPU的时间                     |
| COMMAND | 启动命令的名称和参数                  |

### <span name="ps-ni">查看进程的<a href="#优先级">优先级</a></span>

```shell
# ps指定输出的格式包括进程的谦让度 ni
ps -o pid,ppid,ni,cmd
```

## top 实时状态监视

- <span name="top">top</span>：系统实时状态监视，动态交互命令，默认每5秒刷新一次。

<table><tbody><tr><td data-immersive-translate-effect="1" data-immersive_translate_walked="e068191a-3cc0-4de8-88e8-6dffdc1d64f3">-a</td><td>按内存使用情况排序</td><td rowspan="7">&nbsp;</td><td>-n</td><td>设置显示的总次数，完成后自动退出</td></tr><tr><td>-b</td><td>使用批处理模式，不进行交互式显示</td><td>-p</td><td>仅显示指定进程ID</td></tr><tr><td>-c</td><td>使用显示模式</td><td>-s</td><td>使用安全模式，不允许交互式指令</td></tr><tr><td>-d</td><td>设置显示的更新速度</td><td>-u</td><td data-immersive-translate-effect="1" data-immersive_translate_walked="e068191a-3cc0-4de8-88e8-6dffdc1d64f3">仅显示与指定用户ID</td></tr><tr><td>-h</td><td>显示帮助信息</td><td>-v</td><td>使用线程模式</td></tr><tr><td>-i</td><td>不显示任何闲置或僵死的行程</td><td>-w</td><td>设置显示的宽度</td></tr><tr><td>-M</td><td>显示内存单位</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table>

```shell
# top
top - 09:59:27 up  1:07,  1 user,  load average: 0.78, 0.44, 0.41
Tasks: 384 total,   1 running, 383 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.4 us,  0.8 sy,  0.0 ni, 98.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  15381.9 total,   8103.5 free,   3652.5 used,   3626.0 buff/cache
MiB Swap:  15625.0 total,  15625.0 free,      0.0 used.  10799.0 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                
   6591 zjk       20   0  659868  73692  58712 S   6.2   0.5   0:03.80 gnome-terminal-                                                        
      1 root      20   0  167120  11592   8136 S   0.0   0.1   0:01.43 systemd                                                                
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd         
```

| 参数                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| top - 09:59:27                 | 当前时间                                                     |
| up  1:07                       | 系统已启动时间（minute）                                     |
| 1 user                         | 当前登录到系统的用户数                                       |
| load average: 0.78, 0.44, 0.41 | 系统负载值：1分钟、5分钟、15分钟<br />若超过CPU个数的2倍，则为高负载；若小于CPU个数，则为正常状态 |
| Tasks                          | 所有进程状态统计                                             |
| %Cpu (s)                       | CPU使用情况                                                  |
| KiB Mem                        | 内存使用情况；buff/cache 用于缓存文件系统的内存              |
| KiB Swap                       | 交换空间使用情况；avail Mem 用于缓存文件内容的交换空间       |

| %Cpu参数 | 说明                                     |
| -------- | ---------------------------------------- |
| us       | 用户态程序使用的时间                     |
| sy       | 内核态程序使用的时间                     |
| ni       | nice优先级调整过的用户态程序使用的时间   |
| id       | CPU空闲时间                              |
| wa       | CPU等待系统IO的时间                      |
| hi       | CPU处理硬件中断的时间                    |
| si       | CPU处理软件中断的时间                    |
| st       | 使用虚拟CPU时，指示被虚拟机偷掉的CPU时间 |

- 应用程序实际占用的内存：MemTotal - MemFree - Buffer - Cached （KB）而不是MemUsed。

# 进程控制

## sleep 睡眠

- sleep：进程没有置入后台时，在当前的CLI睡眠，直到该进程睡眠结束才可以在该CLI上输入下一个命令。睡眠结束时，若进程在后台，则直接恢复到前台。

## kill、killall 终止进程

- 只有进程的属主或root用户可以杀死该进程
- 父进程被终止时，子进程也被终止；而子进程的终止不会导致父进程的终止

| 命令    | 说明                         |
| ------- | ---------------------------- |
| kill    | 按PID杀死单个进程。          |
| killall | 按进程名杀死同名的所有进程。 |

<table><tbody><tr><td>-a</td><td>不限制命令名与进程号的对应关系</td><td rowspan="2">&nbsp;</td><td>-p</td><td>不发送任何信号</td></tr><tr><td>-l</td><td>显示系统支持的信号列表</td><td>-s</td><td data-immersive-translate-effect="1" data-immersive_translate_walked="54491993-7fc2-439e-ac75-c9e05e42b08c">设置向进程发送的信号</td></tr></tbody></table>

| 序号 | 常用信号 | 说明                                |
| ---- | -------- | ----------------------------------- |
| 15   | SIGTERM  | kill、killall命令预设终止程序的信号 |
| 9    | SIGKILL  | 强制删除程序，尽量避免使用          |

# 进程与作业

## Linux作业

- shell将运行的各个进程称为<b>作业（job）</b>，并为作业在当前shell内分配了唯一的<b>作业号</b>，作业号从1开始计数。
- 每次启动新作业时，Linux系统都会为其分配新的作业号和PID。

## jobs 查看作业

- <code>jobs</code>命令通常用于获取当前存在的进程的作业号 。如果存在后台进程，则会输出<code>[ 作业号]+/- 作业状态 启动作业的命令</code>的信息。

1. 带有<code>+</code>的作业为<b>默认作业</b>，如果作业控制命令（fg、bg等）没有指定作业号，则引用的就是该作业。
2. 带有<code>-</code>的作业会在默认作业结束之后成为下一个默认作业。
3. 任何情况下，shell运行的作业中最多只能存在一个默认作业和一个带有<code>-</code>的作业。

```shell
jobs
[1]+  Stopped                 ./test-17-trap.sh
```

## fg 前台作业

- 前台进程会接管当前使用的终端。

- <code>fg</code>命令将作业从后台切换到前台，可以将已停止（Stoped）的作业作为前台进程重启（Running。

## 后台作业

- 后台作业不占用终端窗口。
- 在终端会话中使用后台作业时，每一个后台作业都和（启动它的）终端会话（<code>pts/0</code>）关联在一起。如果终端会话退出，则其下的所有后台作业也都随之退出。

### <code>&amp;</code> 

- 启动命令前加上`$`、或者在所有命令/脚本后面空一格加上<code>&amp;</code>，会将脚本与当前shell分离开来，并将命令或脚本作为一个独立的后台进程运行。

### bg

- <code>bg</code>从前台进程切换到后台，可以将已停止（Stoped）的作业作为后台进程重启（Running）。

### nohup

- <code>nohup</code>命令能阻断发给特定进程的<code>SIGHUP</code>信号，也就是解除终端和进程之间的联系。

1. 当退出终端会话时，使用<code>nohup</code>命令可以避免进程（作业）退出。
2. <code>nohup</code>命令会自动将STDOUT和STDERR产生的消息重定向到当前目录（或者 <code>$HOME</code>）下的<code>nohup.out</code>文件中。
3. 如果使用<code>nohup</code>命令分别运行了多个命令，那么这些命令的输出都会被追加到同一个<code>nohup.out</code>文件中。

# 进程优先级（谦让度）

- 进程的<span name="优先级">优先级</span>（谦让度，nice value）是指内核为进程分配的CPU时间。

1. 优先级的数值为<code>-20~19</code>，数值越小优先级越高；启动进程时，其默认优先级是0；仅有系统管理者可以设置负数等级
2. 进程的优先级是父进程shell优先级的值与（nice命令）所指定优先级的值相加和
3. 指定优先级时：`nice -19 进程`表示优先级是19而不是-19；如果要-19，则`nice --19 进程`；也可以使用`nice -n -19 进程`表示-19

## [ps 查看进程优先级](#ps-ni)

## nice 启动时改变优先级

- <code>nice</code>命令只能在创建进程时指定进程的优先级，且指定的并不就是该进程的优先级，而是一个增量。

1. 只有root用户和特权用户可以提高命令的优先级，而普通用户只能降低其启动的命令的优先级。
2. <code>nice</code>命令会阻止普通用户提高命令的优先级（降低谦让度）。但即使提高优先级失败，试图被提高优先级的命令也会正常执行，只是优先级没有被改变而已。

<table><tbody><tr><td>-g</td><td>匹配进程组ID</td></tr><tr><td>-n</td><td>设置优先级别</td></tr><tr><td>-p</td><td>匹配进程ID</td></tr><tr><td>-u</td><td>匹配用户ID</td></tr><tr><td>--help</td><td>显示帮助信息</td></tr><tr><td>--version</td><td>显示版本信息</td></tr></tbody></table>

```shell
# 普通用户只能降低其启动的命令的优先级
nice -n +5 top &
[1] 21915

ps -o pid,ppid,ni,cmd
    PID    PPID  NI CMD
  21841   14297   0 bash
  21915   21841   5 top
  21952   21841   0 ps -o pid,ppid,ni,cmd
```

## renice 运行时改变优先级

- <code>renice</code>命令可以修改正在运行的进程的调度优先级。

1. <code>renice</code>命令会自动更新运行进程的调度优先级。
2. 只有系统管理者（root用户和特权用户）可以任意改变（提高或降低）任意进程的优先级。
3. 普通用户只能降低自己启动的进程的优先级。

<table><tbody><tr><td> -g </td><td>指定进程组id</td></tr><tr><td> -p </td><td>改变该程序的优先权等级，此参数为预设值</td></tr><tr><td> -u </td><td>指定开启进程的用户名</td></tr></tbody></table>

```shell
# 将行程id为987及32的进程与进程拥有者为daemon及root的优先序号码加1
renice +1 987 -u daemon root -p 32
```

# coproc 协程

- <span name="coproc">coproc</span>（协程）：同时处理两件事情，后台生成一个子shell并在该子shell中执行命令。

```shell
coproc 进程名 { 命令; 命令; }
```

# 定时运行作业与调度

## at 定时任务

### 定时任务概述

- <code>at</code>命令是<b>一次性定时计划任务</b>，允许指定Linux系统何时运行脚本，该命令会将作业提交到队列中，指定shell何时运行该作业。大多数的Linux发行版都安装了<code>at</code>命令对应的软件包。
- <code>at</code>命令的守护进程<b><a href="#atd">atd</a></b>（如果启动了）在后台运行，在<b><a href="#作业队列">作业队列</a></b>中检查待运行的作业。

```shell
# at 23:43 today
at> date >/root/today.log            
at> <EOT>
job 3 at Sun Nov 27 23:43:00 2022
```

### atd进程

- <span name="atd">atd守护进程</span>是<code>at</code>命令的守护进程，（如果启动了）会在<a href="#作业队列">作业队列</a>中检查待运行的作业。

1. atd守护进程会检查系统的一个特殊目录（通常是<code>/var/spool/at</code>或<code>/var/spool/cron/atjobs</code>），从中获取<code>at</code>命令提交的作业。
2. 在默认情况下，atd守护进程每隔60秒会检查一次该特殊目录。如果其中有作业，那么atd守护进程就会查看此作业的运行时间。如果时间和当前时间一致，就运行此作业。

```shell
# 查看atd进程的状态
sudo systemctl status atd
```

### at命令的格式

```shell
at [-f filename] time
```

1. <code>at</code>命令在默认情况下会将STDIN的输入放入队列中，可以通过<code>-f</code>选项来指定读取命令（脚本文件）的文件名。
2. <i>time</i>参数指定了希望何时运行该作业。如果指定的时间已经过去，则<Code>at</Code>命令会在第二天的同一时刻运行指定的作业。
3. <code>at</code>命令可以识别多种日期和时间的格式，具体可查看<code>/usr/share/doc/at/timespec</code>文件。

<table>
    <caption>at命令识别的时间日期格式</caption>
    <tr>
        <th width="20%">时间格式</th>
        <th width="80%">描述</th>
    </tr>
    <tr>
        <td>标准的小时和分钟</td>
        <td>通常是当天的某个时间点，如果错过则在第二天执行。例如<code>10:15</code></td>
    </tr>
    <tr>
        <td>AM/PM指示符</td>
        <td>12小时计时制，时间后面加上AM（上午）、PM（下午）</td>
    </tr>
    <tr>
        <td>特定的时间名称</td>
        <td>midnight（深夜）、noon（中午）、teatime（一般是下午4点）、today（今天）、tomorrow（明天）等比较模糊的词语来指定时间</td>
    </tr>
    <tr>
        <td>标准日期</td>
        <td><code>MMDDYY</code>、<code>MM/DD/YY</code>、<code>DD.MM.YY</code>，指定的日期必须跟在指定时间的后面</td>
    </tr>
    <tr>
        <td>文本日期</td>
        <td>例如<code>Jul 4</code>、<code>Dec 25</code>、<code>month day</code></td>
    </tr>
    <tr>
        <td>时间增量</td>
        <td><code>now + count time-units</code>：now当前时间、time-units是时间单位 minutes（分钟）、hours（小时）、days（天）、weeks（星期）、count是时间的数量，究竟是几天，还是几小时，等等。例如<code>Now + 25 minutes</code>、<code>10:15 PM tomorrow</code>、<code>10:15 + 7 days</code></td>
    </tr>
</table>
### 作业队列

- 在使用<code>at</code>命令时，指定的作业会被提交到<span name="作业队列">作业队列</span>，<b>作业队列</b>保存着通过<code>at</code>命令提交的待处理作业。

1. 针对不同的优先级（谦让度）有52种作业队列。
2. 作业队列通常用小写字母<code>a~z</code>和大写字母<code>A~Z</code>来分别指代这52种作业队列。
3. 作业队列的字母排序越高（排序从<code>a~z</code>，依次升高），此队列中的作业运行优先级越低（谦让度越大）。
4. 默认情况下，<code>at</code>命令提交的作业会被放入<code>a</code>队列，可以使用<code>-q</code>选项来指定放入的队列字母。

### atq 显示当前所有定时任务

```shell
atq
# 4       Wed Nov 30 08:40:00 2022 a root
```

### atrm  删除指定序号的定时任务

## cron 周期任务

### crontab

- <span name="crontab"><code>crontab</code></span>（cron table）命令提交和管理用户需要周期性执行的任务。默认会安装此服务工具，并自动启动[crond](#crond)进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。

```shell
crontab [选项] [crontab 的任务列表文件]
```

<table><tbody><tr><td>-e</td><td>编辑任务</td><td rowspan="3">&nbsp;</td><td>-r</td><td>删除任务</td></tr><tr><td>-i</td><td>删除前询问用户是否确认</td><td>-u</td><td>设置用户名</td></tr><tr><td>-l</td><td>显示任务</td><td>--help</td><td>显示帮助信息</td></tr></tbody></table>

```shell
# 打开cron配置文件进行编辑，产生的文件最终保存到/var/spool/cron/crontabs
sudo crontab -e
```

```shell
# m h  dom mon dow   command
0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
# at 5 a.m every week with:
```

#### /var/spool/cron

- `/var/spool/cron/crontabs`：用户任务调度，用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。所有用户定义的crontab文件（crontab命令）都被保存在`/var/spool/cron/crontabs`目录中，其文件名与用户名一致

### /etc/crontab

- `/etc/crontab`：系统任务调度的配置文件，系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。

```shell
# sudo vim /etc/crontab

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
```

```shell
# 每1分钟执行一次command
* * * * * command

# 每小时的第3和第15分钟执行
3,15 * * * * command

# 在上午8点到11点的第3和第15分钟执行
3,15 8-11 * * * command

# 每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2 * * command

# 每个星期一的上午8点到11点的第3和第15分钟执行
3,15 8-11 * * 1 command

# 每晚的21:30重启smb 
30 21 * * * /etc/init.d/smb restart

# 每月1、10、22日的4 : 45重启smb 
45 4 1,10,22 * * /etc/init.d/smb restart

# 每周六、周日的1:10重启smb
10 1 * * 6,0 /etc/init.d/smb restart

# 每天18 : 00至23 : 00之间每隔30分钟重启smb 
0,30 18-23 * * * /etc/init.d/smb restart

# 每星期六的晚上11:00 pm重启smb 
0 23 * * 6 /etc/init.d/smb restart

# 每一小时重启smb 
* */1 * * * /etc/init.d/smb restart

# 晚上11点到早上7点之间，每隔一小时重启smb
* 23-7/1 * * * /etc/init.d/smb restart

# 每月的4号与每周一到周三的11点重启smb 
0 11 4 * mon-wed /etc/init.d/smb restart

# 一月一号的4点重启smb
0 4 1 jan * /etc/init.d/smb restart

# 每小时执行/etc/cron.hourly目录内的脚本
01 * * * * root run-parts /etc/cron.hourly
```

### crond进程

- <span name="crond">crond进程</span>每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务

```shell
service crond status # 查看crond服务状态
/sbin/service crond start    # 启动服务
/sbin/service crond stop     # 关闭服务
/sbin/service crond restart  # 重启服务
/sbin/service crond reload   # 重新载入配置
ntsysv # 查看crond服务是否已经设置为开机启动
chkconfig –level 35 crond on # 加入开机自动启动
```

