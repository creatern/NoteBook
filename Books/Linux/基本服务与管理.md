# 基本命令

## alias 命令别名

- alias：设置指令的别名。只局限于该次登入的操作（直接在shell里设定的命令别名，在终端关闭或系统重新启动后都会失效）；将别名写入bash的初始化文件/etc/bashrc，每次启动系统都会初始化（持久化）。

- 使用alias时，用户必须使用单引号将原来的命令引起来，防止特殊字符导致错误。

| 命令                     | 说明                                                        |
| ------------------------ | ----------------------------------------------------------- |
| alias<br />alias -p      | 查看已经设置的别名                                          |
| type 别名                | 检查别名是否已被使用                                        |
| alias 别名='命令1;命令2' | 设置别名，多条命令之间使用分号分隔                          |
| unalias 别名             | 撤销别名<br />只是删除本次操作中的别名（/etc/bashrc未更改） |

## history 历史命令

- history默认最大保存1000条历史命令（\$HISTSIZE），保存在\~/\.bash\_history（历史命令文件）。bash命令的历史记录先放在内存中，当shell退出时才被写入到历史文件中。

| 命令                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| history [n]<br />上下光标 | 查看历史命令记录                                             |
| history -c                | 清空当前缓冲区中的历史命令（并未对历史命令文件修改）         |
| history -r                | 将历史命令文件中的命令读入当前历史命令缓冲区<br />（否则只有在第一个终端被打开时才会读取历史命令文件）<br />（若同时打开多个终端，history -a 时其他终端的历史记录不会自动更新。） |
| history -a                | 将历史命令缓冲区中的命令写入历史命令文件                     |
| history -w                | 将**当前**历史命令缓冲区中的命令写入历史命令文件             |

### \!\! 执行上次命令

| 命令      | 说明                         |
| --------- | ---------------------------- |
| \!\!      | 执行上次命令                 |
| \!\{n\}   | 执行指定序号的历史命令       |
| \!\{str\} | 执行以指定字符开头的历史命令 |

## \| 管道符

- \|（管道符）：连接两个命令，将一个程序/命令的输出作为另一个程序/命令的参数输入。一般为输入和输出的结合，一个进程向管道的一端发送数据，而另一个进程从该管道的另一端读取数据。

## 文本操作

| 命令   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| echo   | 输出指定的字符串/变量                                        |
| printf | 格式化并输出结果                                             |
| cat    | 一次性显示文本文件的所有内容<br />不适用于内容大的文件，一旦运行就无法控制后面的操作 |
| more   | 分页显示文本内容<br />使用空格或回车来逐行查看文件内容，只支持文本文件中的基本查看 |
| less   | 在more的基础上，能够使用上下和翻页键                         |
| tail   | 显示文件的最后几行<br />默认显示文件的最后10行               |
| head   | 显示文件的头几行                                             |

### echo 格式化输出

```shell
echo -e "\e[编码1;编码2;编码3m内容"
# 文字色：
#颜色码：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37
echo -e "\e[1;31m内容\e[0m"
#\e[1;31m 将颜色设置为红色
#\e[0m 将颜色重新置回
# 背景色 ：
#颜色码：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47
echo -e "\e[1;42m内容\e[0m"
# 文字闪动：
# 0 关闭所有属性、1 设置高亮度（加粗）、4 下划线、5 闪烁、7 反显、8 消隐
echo -e "\033[37;31;5mMySQL Server Stop...\033[39;49;0m"
```

### sed 流编辑器

- sed流编辑器处理时，把当前处理的行存储在临时缓冲区（模式空间 pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非使用重定向存储输出。

```shell
sed [options] 'command' file(s)
sed [options] -f scriptfile file(s)
```

```shell
[root@localhost ~]# head -3 /etc/passwd |sed -n 2p
bin:x:1:1:bin:/bin:/sbin/nologin
[root@localhost ~]# head -3 /etc/passwd |sed -n 2,3p
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
```

| 命令 | sed替换标记                                              |
| :--- | :------------------------------------------------------- |
| g    | 行内全面替换。                                           |
| p    | 打印行。                                                 |
| w    | 把行写入一个文件。                                       |
| x    | 互换模板块中的文本和缓冲区中的文本。                     |
| y    | 把一个字符翻译为另外的字符<br />（但是不用于正则表达式） |
| \\1  | 子串匹配标记                                             |
| \&   | 已匹配字符串标记                                         |

| 元字符集 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| ^        | 匹配行开始，如：/^sed/匹配所有以sed开头的行。                |
| $        | 匹配行结束，如：/sed$/匹配所有以sed结尾的行。                |
| .        | 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 |
| *        | 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 |
| []       | 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。           |
| [^]      | 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 |
| \(..\)   | 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。 |
| &        | 保存搜索字符用来替换其他字符，如s/love/ **&** /，love这成 **love** 。 |
| \<       | 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。    |
| \>       | 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。     |
| x\{m\}   | 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。               |
| x\{m,\}  | 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。        |
| x\{m,n\} | 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。 |

### sort 文件数据排序

- sort命令默认会将文本中的数据当成字符来排序按照会话指定的默认语言的升序排序顺序输出，包括数字和时间日期等，而不是按照相应的规则来排序。

| 命令                                       | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| sort -n                                    | 将文本识别为数字来排序                                       |
| sort -M                                    | 将文本识别为Mar形式的月份来排序                              |
| sort -t '分隔字符' -k 指定排序的字符段位置 | -t对每行的字符段进行分隔，然后-k选择每行分隔的其中一段字符进行排序 |
| sort -r                                    | 将排序结果降序输出                                           |

```shell
# sort -t '字符' -k  文件
# 将/etc/passwd按uid来排序
[root@bogon ~]# sort -t ':' -k 3  /etc/passwd | head -n 5
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
```

### grep 文本过滤

- grep：默认区分大小写、支持正则。若不指定任何文件名称/给予的文件名为"-"，则grep命令从标准输入设备读取数据。

```shell
grep [选项] {"查找目标文本" | 查找目标文本} {被过滤文本}
```

| 选项 |                    |
| ---- | ------------------ |
| -v   | 反向搜索           |
| -n   | 匹配的同时输出行号 |
| -c   | 统计含有匹配的行数 |

#### 正则

| 正则参数       | 说明                                                |
| :------------- | :-------------------------------------------------- |
| \              | 转义符                                              |
| ^              | 指定匹配字符串的行首 ；指定行的开始                 |
| $              | 指定匹配字符串的结尾  ； 指定行的结束               |
| *              | 表示0个以上的字符 ；匹配0个或多个先前的字符         |
| +              | 表示1个以上的字符 ；匹配1个或多个先前的字符         |
| ?              | 匹配0个或多个先前的字符                             |
| .              | 匹配一个非换行符的字符                              |
| []             | 匹配一个指定范围内的字符                            |
| [^]            | 匹配一个非指定范围内的字符                          |
| `\(..\)`       | 标记匹配字符                                        |
| <              | 指定单词的开始                                      |
| >              | 指定单词的结束                                      |
| x{m}           | 重复字符x，m次                                      |
| x{m,}          | 重复字符x，至少m次                                  |
| x{m,n}         | 重复字符x，至少m次，至多n次                         |
| w              | 匹配单词和数字 即：[A-Z] [a-z] [0-9]                |
| W              | w的反置形式，匹配一个或多个非单词字符，如点号句号等 |
| b              | 单词锁定符                                          |
| `          | ` |                                                     |
| ()             | 分组符                                              |
| [:alnum:]      | 文字数字字符                                        |
| [:alpha:]      | 文字字符                                            |
| [:digit:]      | 数字字符                                            |
| [:graph:]      | 非空格、控制字符                                    |
| [:lower:]      | 小写字符                                            |
| [:upper:]      | 大写字符                                            |
| [:cntrl:]      | 控制字符                                            |
| [:print:]      | 非空字符（包括空格）                                |
| [:punct:]      | 标点符号                                            |
| [:space:]      | 所有空白字符（换行、空格、制表符）                  |
| [:xdigit:]     | 十六进制数字 0-9 a-f A-F                            |

### awk

```shell
awk [options] 'script' var=value file(s)
awk [options] -f scriptfile var=value file(s)
```

| 选项         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| -F fs        | fs指定输入分隔符，fs可以是字符串或正则表达式                 |
| -v var=value | 赋值一个用户定义变量，将外部变量传递给awk                    |
| -f scripfile | 从脚本文件中读取awk命令                                      |
| -m[fr] val   | 对val值设置内在限制<br />-mf选项限制分配给val的最大块数目。<br />-mr选项限制记录的最大数目。 |

### 标准输入与输出

- 执行一个Shell命令通常会自动打开3个标准文件：标准输入文件stdin（对应终端的键盘）、标准输出文件stout、标准错误输出文件stderr（对应终端的屏幕）。
- 进程从标准输入文件得到输入数据，将正常输出数据输出到标准输出文件，而错误信息则打印到标准错误文件。

<img src="../../pictures/153845716239573.png" width="369"/> 

- 如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。 

**cat命令 不带参数时**

- 从标准输入中读取数据并显示到标准输出文件中。此时，每一行键盘（标准输入文件）输入的数据，都会立刻被输出在屏幕上（标准输出文件）。

#### 重定向

- 重定向操作符：把命令/可执行程序的标准输入/输出重定向到指定的文件。

| 操作符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `<`    | 输入重定向                                                   |
| `<<`   | 文档的重定向                                                 |
| `>`    | 输出重定向<br />若`>`后面的文件不存在，则创建该文件。若存在，则将内容覆盖到该文件。 |
| `>>`   | 追加输出重定向<br />若`>>`后面的文件不存在，则创建该文件。若存在，则将内容追加到该文件。 |
| 2>     | 错误输出重定向<br />若`2>`后面的文件不存在，则创建该文件。若存在，则将内容覆盖到该文件。<br />如果有错误信息，则不会在屏幕（标准输出文件）输出，而会保存在指定的文件中。即使没有错误信息也会创建/覆盖。 |
| 2>>    | 追加错误输出重定向<br />若`2>>`后面的文件不存在，则创建该文件。若存在，则将内容追加到该文件。<br />如果有错误信息，则不会在屏幕（标准输出文件）输出，而会保存在指定的文件中。即使没有错误信息也会创建/追加。 |

- 重定向操作符可以混合使用。

```shell
命令 >输出 2>&1 #将标准输出和标准错误输出重定向到同一个文件
ls >myOutAndErr.txt 2>&
```

# 文件管理

| 命令       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| cd         | 切换文件目录。<br />`.`：当前目录<br />`..`：当前目录的父目录<br />`~`：/home |
| pwd        | 显示当前的绝对路径                                           |
| ls<br />ll | （按行）列出当前目录下的文件和目录。<br /> 显示长列表。      |
| file       | 查看文件类型。                                               |

## FHS 目录结构

- 基于文件系统层级标准（FHS）：Linux将文件存储在单个目录结构中（虚拟目录），虚拟目录将安装在PC上的所有存储设备的文件路劲纳入单个目录结构中。Linux虚拟目录结构只包含一个根目录 / 的基础目录。根目录下的目录和文件会按照访问的目录路径一一列出。
- 根驱动器：在Linux PC上安装的第一个硬盘，包含了虚拟目录的核心，从此开始构造其他目录。
- 挂载点：在根驱动器上创建的目录，是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让（该额外存储设备上的）文件和目录出现在这些挂载点的目录上。

| 目录        | 说明                                                         |
| :---------- | :----------------------------------------------------------- |
| /           | 根目录，文件的最顶端。<br />/ect、/bin、/dev、/lib、/sbin应该和根目录放置在同一个分区。 |
| /bin        | 二进制目录，存放系统所需要的重要命令。（命令对应的文件都是可执行的）<br />/usr/bin也存放一些系统命令，普通用户可以使用大部分的命令。 |
| /boot       | Linux启动时，内核及引导系统程序所需要的核心文件。<br />内核文件、gub系统引导管理器（引导装载程序）都位于此目录。 |
| /dev        | 设备文件（光驱、磁盘等）。<br />访问该目录下某个文件相当于访问某个硬件设备，常用的是挂载光驱。 |
| /etc        | 系统的配置文件                                               |
| /home       | 默认的用户主目录。<br />如果添加用户时不指定用户的主目录，默认在/home下创建与用户名同名的文件夹。 |
| /lib        | 动态链接库。<br />/lib64（64位系统）、/usr/1ib、/usr/local/lib等。 |
| /lost+found | 系统意外崩溃、机器意外关机时产生的文件碎片。                 |
| /mnt        | 挂载储存设备的挂载目录。                                     |
| /proc       | 进程目录，存放操作系统运行时的信息<br />此目录的内容存在于内存中，实际不占用磁盘空间。 |
| /root       | root用户的主目录                                             |
| /sbin       | 系统二进制目录，存放一些系统管理的命令，一般只能由root执行。 |
| /tmp        | 临时文件目录，任何人都可以访问。<br />系统软件/用户运行程序时产生的临时文件存放到这里，空间不易过小。<br />此目录数据需要定期清除，重要数据不可放置在此目录下。 |
| /usr        | 用户二进制目录，应用程序存放目录（命令、帮助文件等）。<br />安装Linux软件包时默认安装到/usr/local目录下。 |
| /var        | 此目录的内容经常变动的。                                     |
| /sys        | 系统目录，主要记录与系统核心相关的信息。<br />此目录的内容存在于内存中，实际不占用磁盘空间。 |
| /srv        | 服务目录，存放本地服务的相关文件。                           |
| /run        | 运行目录，存放系统运行时的运行数据。                         |
| /opt        | 可选目录，存放第三方软件包、数据文件。                       |
| /media      | 媒体目录，可移动媒体设备的常用挂载点。                       |

## 文件信息/权限

- 对root用户而言，rw权限是可以无视的，而可执行文件则必须要有x权限（包括root用户）。

| 权限命令 | 说明                |
| -------- | ------------------- |
| chown    | 改变文件所有者      |
| chgrp    | 改变文件所属组      |
| chmod    | 变更文件/目录的权限 |

<img src="../../pictures/Snipaste_2022-11-28_20-30-27.png" width="700"/> 

| 参数 | 文件类型                           |
| :--- | :--------------------------------- |
| -    | 普通文件                           |
| d    | 目录文件                           |
| l    | 符号链接文件                       |
| b/c  | b：块设备文件<br />c：字符设备文件 |
| p    | 管道文件                           |

| 权限 | 说明                  |
| :--- | :-------------------- |
| r    | 读权限                |
| w    | 写权限                |
| x    | 执行权限              |
| 777  | 绝对权限（rwxrwxrwx） |

## 文件操作

| **文件命令**     | **说明**               |
| ---------------- | ---------------------- |
| touch            | 创建/更新文件          |
| mv               | 移动、重命名           |
| cp               | 复制                   |
| mkdir<br />rmdir | 新建目录<br />删除目录 |

### 压缩与归档

#### zip/unzip 压缩/解压缩

| 命令   | 说明               |
| ------ | ------------------ |
| gzip   | 压缩`.gz`          |
| gunzip | 解压               |
| gzcat  | 查看压缩文件的内容 |

#### tar 归档

- .tar、.tar.gz、.tgz、.tar.bz2

| 文件格式  | 命令参数 |
| --------- | -------- |
| \.tar\.xz | -xf      |

### find 检索

```shell
find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression]
```

```shell
# 从当前目录查找文件名开头是Hello的
find . -name "Hello*"
```

### ln 链接

```shell
# 硬链接
ln 源路径 目标路径

# 软链接
ln -s 完整源路径 目标路径
```

| 链接   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 硬链接 | 如果源文件被删除，硬链接仍然可以正常使用、读写数据。<br />不可以跨区/磁盘创建硬链接。<br />硬链接与源文件使用的是相同的设备、inode编号、文件属性和源文件相同。 |
| 软链接 | 如果源文件被删除，则无法继续使用软链接。<br />可以跨分区/磁盘创建软链接。<br />软链接的文件属性被标记为l，同时有指针\-\>指向源文件。 |

# 应用管理

## Linux函数库

- 函数库是一个文件，包含已经编译好的代码和数据，供程序使用。

| 函数库         | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 静态函数库     | 在编译程序时，如果指定静态函数库文件，则编译时将这些静态函数库一起加载到最终的可执行文件中，在程序执行前加入目标程序。<br />文件后缀 .a、所在目录 /usr/lib、通常只有一个程序使用。 |
| 共享函数库     | 在程序启动时加载到程序，可以被不同的程序共享。<br />当一个可执行程序启动时被加载、所在目录 /lib 和 /usr/lib、被多个程序使用。 |
| 动态加载函数库 | 可以在程序运行的任何时候动态的加载。<br />文件后缀 .so 、一般都是共享函数库 。 |

- 缓存文件（/etc/ld.so.cache）：可以找到相关的库文件信息。

```shell
# 修改 /etc/ld.so.conf 文件，将该库的文件路径添加到文件
echo "/usr/local/ssl/lid/" >> /etc/ld.so.conf

# 让系统升级ld.so.cache文件
ldconfig
```

- LD_LIBRARY_PATH环境变量

```shell
export LD_LIBRARY_PATH=/usr/local/ssl/lib:$LD_LIBRARY_PATH:.
```

- ldd 查看程序使用了哪些动态库文件

## 软件安装格式

### rpm

| 组合                            | 说明                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| rpm -ivh RPM包                  | 安装时显示信息                                               |
| rpm -ivh --force RPM包          | 强制安装                                                     |
| rpm -ivh --nodeps --force RPM包 | 无视依赖，强制安装                                           |
| rpm -qpl RPM包                  | 查看软件包的详细信息                                         |
| rpm -Uvh RPM包                  | 更新已安装的软件包                                           |
| rpm -qa                         | 查看已安装的软件包                                           |
| rpm -e                          | 卸载软件包<br />如果存在依赖关系，需要先卸载需要其依赖的软件包 |
| rpm -qf                         | 查看文件所属软件包                                           |
| rpm -qip                        | 获取说明信息                                                 |

#### yum

### deb

#### apt

```shell
# 由Linux查找相应的软件包，并自动安装（包括依赖）。
sudo apt install <软件名>
```

```shell
# Ubutun apt源
sudo vim /etc/apt/sources.list
```

[清华大学镜像](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/?spm=a2c6h.12873639.article-detail.7.4d0a3d66Nzz2jp)

```shell
# 卸载apt安装的软件
sudo apt purge <软件名>
sudo apt autoremove
```

#### dpkg

```shell
# 安装*.deb，自动安装依赖
sudo dpkg -i *.deb

# 如果仍然需要安装依赖，则在之后输入：
sudo apt-get -f -y install
```

### Flatpak

### Snap

```shell
sudo snap install <app>
```

# 用户管理

| 用户类型 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| 超级用户 | root<br />UID: 0                                             |
| 系统用户 | 正常运行时，系统使用的用户，每个进程在系统中都有一个相应的属主。<br />系统用户不能用来登录（bin、daemon、mail等） |
| 普通用户 | user                                                         |

## 用户管理文件

### /etc/passswd 用户账号文件

> 普通用户的UID默认1000之后。

<img src="../../pictures/Snipaste_2022-11-30_14-12-25.png" width="800"/>

### /etc/shadow  用户密码文件

<img src="../../pictures/Snipaste_2022-11-30_16-35-15.png" width="1000"/>

### /etc/group 用户组文件

- 用户登录时默认的组放在/etc/passwd中。

<img src="../../pictures/Snipaste_2022-11-30_18-52-02.png" width="280"/> 

## 用户管理命令

### 用户增删改查

| 用户管理命令 | 作用     | 说明                                                         |
| ------------ | -------- | ------------------------------------------------------------ |
| useradd      | 添加用户 |                                                              |
| usermod      | 修改用户 | 不允许改变正在线上的使用者帐号名称。<br />改变user id时必须确认该用户没在电脑上执行任何程序。 |
| userdel      | 删除用户 | -r：同时删除该用户的相关任务和文件。                         |
| passwd       | 用户密码 | 设置用户的认证信息，包括用户密码、密码过期时间等。<br />只有管理者可以指定用户名称，一般用户只能变更自己的密码。 |
| id           | 用户信息 | 显示真实有效的用户ID（UID）、组ID（GID）。                   |

### su、sudo 切换用户

| su指令          | 切换用户（不指定用户则默认root）                             |
| :-------------- | :----------------------------------------------------------- |
| su 用户         | 不改变环境变量                                               |
| su - 用户       | 改变环境变量                                                 |
| su -c 命令 用户 | 切换用户执行命令之后，返回原用户                             |
| **sudo指令**    | **普通用户获取超级权限**、以其他身份来执行命令，预设的身份为root。 |
| /etc/sudoers    | 设置可执行sudo指令的用户                                     |

## 用户组命令

- 每个用户都有一个用户组，一个用户可以属于多个用户组，一个用户组可以有多个用户。系统对一个用户组的用户集中管理，赋予用户组的权限可以被该用户获取。用户的权限为所在的所有用户组的权限之和。

| 用户组文件  | 说明                                 |
| ----------- | ------------------------------------ |
| /etc/passwd | 定义的用户组为基本组，其他的为附加组 |
| /etc/group  | 用户组的操作基于对该文件的更新       |

| 用户组命令 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| groupadd   | 添加用户组                                                   |
| groupdel   | 删除用户组（修改的系统文件包括/ect/group和/ect/shadow）<br />若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。 |
| groupmod   | 修改用户组                                                   |
| groups     | 查看用户所在用户组                                           |
