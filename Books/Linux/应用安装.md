# 软件包管理基础

- 各种主流的Linux发行版都使用采用了某种形式的软件包管理系统来控制软件和库的安装。软件包管理系统使用数据库来记录如下内容：Linux系统中已安装的软件包、每个软件包安装了哪些文件、每个已安装的软件包的脚本。
- 软件包存储在被称为仓库（repository）的服务器上，可以利用本地Linux系统中的软件包管理器通过Internet访问，在其中搜索新的软件包，或是更新系统中已安装的软件包。
- 软件包通常存在依赖关系，为了能够正常运行，被依赖的包必须提前安装。软件包管理器会检测这些依赖关系并提前安装好所有额外的软件包。
- 软件包管理器及其相关命令在不同的Linux发行版中差异显著。Linux中广泛使用的两种主要的软件包管理系统基础工具是`dpkg`和`rpm`。

<table>
    <tr>
        <td width="10%">dpkg</td>
        <td width="90%">基于Debian的发行版使用的是dpkg命令，dpkg命令是Debian系的软件包管理系统的底层基础。dpkg会直接和Linux系统中的软件包管理系统交互，用于安装、管理和删除软件包</td>
    </tr>
    <tr>
        <td>rpm</td>
        <td>基于Red Hat的发行版使用的是rpm命令，rmp命令是Red Hat系的软件包管理系统的底层基础。rpm命令也可以安装、管理和删除软件包</td>
    </tr>
</table>

# Debian系发行版

## dpkg

- dpkg命令是基于Debian的软件包管理器的核心，用于在Linux系统中安装、更新、删除DEB包文件。
- dpkg命令假定用户已经将DEB包下载到本地Linux或是以URL的形式提供，但通常情况下，用户更希望从Linux发行版仓库中安装软件包，为此需要使用APT工具集（advanced package tool）。

```shell
# 安装*.deb，自动安装依赖
sudo dpkg -i *.deb

# 如果仍然需要安装依赖，则在之后输入：
sudo apt-get -f -y install
```

## apt

- APT工具集（advanced package tool）涵盖了软件包管理的方方面面，其包括：`apt-cache`、`apt-get`、`apt`。
- `apt`命令（`apt [options] commandapt [options] command`）本质上是`apt-get`和`apt-cache`命令的前端，用于配合基于Debian的dkpg工具。

### 管理软件包

- `apt list`命令会显示仓库中所有可用的软件包。

```shell
# 查看已经安装的软件包
apt --installed list
```

- `apt show`：如果已经知道系统中某个软件包，希望显示其详细信息，可以使用`apt show`命令来操作。但`apt show`命令不会指明该软件是否已经安装，只会显示其详细信息。

```shell
# 查看zsh的详细信息
apt show zsh
```

- `apt search`：自带通配符查找特定的软件包，会返回一个匹配的软件包名和描述的列表。默认情况下，search命令显示的是名称或描述中包含关键字的哪些软件包。可通过`--names-only`选项来指定通过名称搜索软件包。

```shell
# 查找名称或描述中包含acl的软件包
apt search acl

# 仅查找名称中包含acl的软件包
apt search --names-only acl
```

- `dpkg -L`：列出某个软件包安装的所有文件。
- `dpkg --search`：找出特定的文件（绝对路径）属于哪个软件包。

```shell
# 列出acl软件包安装的所有文件
dpkg -L acl

# 找出特定的文件属于哪个软件包
dpkg --search /bin/getfacl
```

### 安装软件包

- `apt install`命令用于安装指定的软件包，会自动解析必要的依赖关系，根据需要安装额外的库和软件包。

```shell
# 由Linux查找相应的软件包，并自动安装（包括依赖）。
sudo apt install <软件名>

# apt下载中断后，试图继续下载安装
sudo apt --fix-missing install python3-smbus
```

### 卸载软件包

<table>
    <tr>
        <td width="25%"><code>apt remove</code></td>
        <td width="75%">可以删除软件包，但同时保留数据和配置文件</td>
    </tr>
    <tr>
        <td><code>apt purge</code></td>
        <td>将软件包以及相关的数据和配置文件全部删除，但不会删除其使用的依赖</td>
    </tr>
    <tr>
        <td><code>apt autoremove</code></td>
        <td>检查所有被标记为存在依赖关系且不再被需要的软件包，并删除这些软件包</td>
    </tr>
</table>

```shell
# 卸载apt安装的软件
sudo apt purge <软件名>
# 自动删除无用依赖
sudo apt autoremove
```

### 更新（升级）软件

#### apt upgrade

- `apt upgrade`命令可以使用仓库中的任何新版本安全地升级系统中所有的软件包。该命令无须使用任何软件包名称作为参数，会将所有已安装的软件包升级为仓库中可用的最新版本，有利于系统的稳定。
- `apt upgrade`命令在升级过程中不会删除任何软件包，如果必须删除某个软件包才能完成升级，则使用`apt full-upgrade`命令。

```shell
# 安全升级
apt upgrade

# 删除软件包后升级
apt full-upgrade
```

#### 自动更新 unattended-upgr

- Waiting for cache lock：在Linux的包管理中，dpkg锁定文件是用来确保在任何给定时间只有一个进程可以对软件包数据库进行写操作，以防止数据不一致或损坏。当unattended-upgr进程正在运行（可能正在进行自动更新或者其他与软件包管理相关的任务），它会锁定这个文件，从而阻止其他apt命令同时进行。

### /etc/apt/source.list apt仓库

- apt默认的软件存储库位置是在安装Linux发行版时设置的，仓库位置保存在文件`/etc/apt/source.list`中。通过仓库安装和升级软件包通常是最安全的。
- apt只会从这些仓库（`/etc/apt/source.list`文件中的仓库）中拉取软件，且在搜索要安装的软件或更新软件是，apt也只检查这些仓库。如果需要加入一些额外的仓库，则需要修改`/etc/apt/source.list`。

```
# 在/etc/apt/source.list中指定仓库源的结构
deb或deb-src address distribution_name package_type_list
```

<table>
    <tr>
        <td width="20%">deb或deb-src</td>
        <td width="80%">deb或deb-src指定了软件包的类型。deb表明这是一个已编译程序的仓库源；deb-src表明这是一个源代码的仓库源</td>
    </tr>
    <tr>
        <td>address</td>
        <td>软件仓库的网址</td>
    </tr>
    <tr>
        <td>distribution_name</td>
        <td>该软件仓库的发行版的版本名称，并不代表当前用户使用的Linux发行版的版本名称</td>
    </tr>
    <tr>
        <td>package_type_list</td>
        <td>表明仓库里面有什么类型的软件包，通常是一个单词列表，包括main、restricted、universe、partner等</td>
    </tr>
</table>

```shell
# Ubutun apt源
sudo vim /etc/apt/sources.list
```

[清华大学镜像](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/?spm=a2c6h.12873639.article-detail.7.4d0a3d66Nzz2jp)

#### apt update

- `apt update`命令的作用是更新本地存储的软件包列表信息，而不是直接升级软件包本身。具体会发生以下步骤：

1. 连接软件源：APT会连接到你在 `/etc/apt/sources.list` 文件中所配置的所有软件源，以及可能存在的其他源列表文件（如`sources.list.d`目录下的额外源文件）。
2. 获取元数据：从软件源获取最新的软件包列表的元数据，这些数据包含了每个软件包的版本号、描述、依赖关系等信息。
3. 更新本地缓存：将从远程源获取的新元数据与本地存储的旧数据进行对比，然后更新本地缓存，即 `/var/lib/apt/lists/` 目录下的文件。
4. 准备升级：完成后，APT知道有哪些软件包有新的版本可更新，哪些依赖关系有所变动。不过，此时还没有实际下载或安装任何更新。

- `apt update`命令并不会直接修改 `/etc/apt/sources.list` 文件，但它确实依赖于这个文件来知道去哪里查找软件包的更新信息。如果用户在此之前修改了`sources.lis`t文件以添加、删除或更改了软件源，那么运行 `apt update` 将会根据新的源配置信息来获取对应软件源的更新列表。

```shell
# 更新apt
sudo apt update
```

# RedHat系发行版

<table>
    <tr>
        <td width="10%">yum</td>
        <td width="90%">Red Hat、CentOS、Fedora</td>
    </tr>
    <tr>
        <td>zypper</td>
        <td>openSUSE</td>
    </tr>
    <tr>
        <td>dnf</td>
        <td>对yum的升级，新增一些特性</td>
    </tr>
</table>
## rpm

### rpm基本命令

```shell
# 安装时显示信息
rpm -ivh RPM包

# 查看软件包的详细信息
rpm -qpl RPM包

# 查看已安装的软件包
rpm -qa

# 卸载软件包，如果存在依赖关系，需要先卸载需要其依赖的软件包
rpm -e

# 查看文件所属软件包
rpm -qf

# 更新已安装的软件包
rpm -Uvh RPM包
```

### RPM仓库

```shell
# 查看当前拉取软件的仓库
dnf repolist
```

- 对RPM仓库的配置方式：

1. `/etc/dnf/dnf.conf`配置文件
2. `/etc/yum.repos.d`目录，该目录下保存着所有的RPM仓库设置
3. 部分的仓库站点会自行提供RPM文件来完成对其RPM仓库的设置

## yum

## zypper

## dnf

- DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。DNF使用 RPM, libsolv 和 hawkey 库进行包管理操作。

### 管理软件包

```shell
# 查看特定软件包的信息
dnf list xterm

# 查看系统中已经安装的软件包
dnf list installed

# 查看某个文件是由哪个软件包安装的
# dnf会分别检查本地系统和默认的Fedora仓库
dnf provides /usr/bin/zip
```

### 安装软件

```shell
# 安装指定名称的软件包
sudo dnf install pack_name
```

### 卸载软件包

```shell
# 卸载软件的同时卸载相应的配置文件与数据文件
sudo dnf remove package_name

# 自动删除无用的、孤立的软件包
sudo dnf autoremove
```

### 更新（升级）软件包

```shell
# 查看已安装软件包的所有可用更新
dnf list upgrades

# 升级所有具有可用更新的软件包（也就是list upgrades列表中的）
sudo dnf upgrade

# 只升级指定名称的软件包
sudo dnf upgrade package_name
```

#### 依赖关系修复

- 依赖关系损坏（broken dependency）：有时在安装多个软件包时，一个软件包的依赖关系可能会被另一个软件包搞乱。
- yum工具的upgrade命令支持`--skip-broken`选项；而dnf工具自动执行该选项。

```shell
# 进行简单的清理与更新，以尝试修复依赖关系损坏
sudo dnf clean all
sudo dnf upgrade

# 如果上述仍然不行，则通过以下方式来获取需要的软件包信息
# 显示指定软件包的所有依赖关系以及哪些软件包提供了这种依赖，以便自行安装
dnf repoquery --deplist package_name
```

# 容器管理软件

- 软件包管理系统不止一种（如 apt、dnf等），且彼此之间相互竞争。开发者必须对使用不同软件包管理系统的Linux发行版（如 Ubuntu、Fedora等）创建对应的软件包。 且，每个应用程序都依赖于某种库函数才能正常使用，开发者必须考虑哪些库文件在大多数Linux发行版中可用，以及库文件的版本。
- 应用程序容器（application container）创建了一个环境，其中包含了应用程序运行时所需的全部文件（包括运行时库文件）。开发者随后可以将应用程序容器作为单个软件包来分发，以确保能够在任何Linux系统中运行。

> 云计算带来了应用程序容器

## Snap

- snap打包系统运行在后台，会将应用程序所需的所有文件集中到单个snap分发文件中。

```shell
# 查看snap的信息
snap version

# 查看当前已安装的snap应用程序列表
snap list

# 在snap仓库中搜索指定程序
snap find snap_name

# 查看snap安装的应用程序的详细信息
snap info snap_name
```

### 安装snap

- 在安装snap时，snapd进程会将其作为驱动器来挂载，可通过<code>mount</code>命令查看。

```shell
# 安装snap应用程序
sudo snap install snap_name
```

### 卸载与禁用snap

```shell
# 删除指定的snap
sudo snap remove snap_name

# 禁用/启用指定snap
sudo snap disable snap_name
sudo snap enable snap_name
```

## Flatpak

