# echo 格式化输出

```shell
echo -e "\e[编码1;编码2;编码3m内容"
# 文字色：
#颜色码：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37
echo -e "\e[1;31m内容\e[0m"
#\e[1;31m 将颜色设置为红色
#\e[0m 将颜色重新置回
# 背景色 ：
#颜色码：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47
echo -e "\e[1;42m内容\e[0m"
# 文字闪动：

# 0 关闭所有属性、1 设置高亮度（加粗）、4 下划线、5 闪烁、7 反显、8 消隐
echo -e "\033[37;31;5mMySQL Server Stop...\033[39;49;0m"
```

# sed 流编辑器

- sed（stream editor，流编辑器）

1. 批量编辑，根据事先设计好的一组规则编辑数据流，执行基本文本输入流（来自管道的文件或输入）上的转换，只对输入进行一次传递。
2. sed处理时，把当前处理的行存储在临时缓冲区（模式空间 pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕；接着处理下一行，这样不断重复，直到文件末尾；除非使用重定向存储输出，否则文件内容并不改变。

```shell
sed [options] 'command' file(s)
sed [options] -f scriptfile file(s)
```

<table><caption>sed选项 options</caption><tbody><tr><td width="5%">-e</td><td width="42.5%">使用指定脚本（命令）处理输入的文本文件</td><td rowspan="4" width="5%">&nbsp;</td><td width="5%">-n</td><td width="42.5%">仅显示脚本处理后的结果</td></tr><tr><td>-f</td><td>使用指定脚本文件处理输入的文本文件</td><td>-r</td><td>支持扩展正则表达式</td></tr><tr><td>-h</td><td>显示帮助信息</td><td>-V</td><td>显示版本信息</td></tr><tr><td>-i</td><td>直接修改文件内容，而不输出到终端</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table>

<table>
    <caption>sed命令 commands</caption>
    <thead>
        <tr>
            <th width="10%">命令</th>
            <th width="90%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>a\</td>
            <td>在当前行下面插入文本。</td>
        </tr>
        <tr>
            <td>i\</td>
            <td>在当前行上面插入文本。</td>
        </tr>
        <tr>
            <td>c\</td>
            <td>替换选定的行，用新的文本代替。</td>
        </tr>
        <tr>
            <td>d</td>
            <td>删除选定的行。</td>
        </tr>
        <tr>
            <td>D</td>
            <td>删除模式空间（即当前行）的第一行。</td>
        </tr>
        <tr>
            <td>s</td>
            <td>替换指定字符。</td>
        </tr>
        <tr>
            <td>h</td>
            <td>拷贝模式空间的内容到内存缓冲区中。</td>
        </tr>
        <tr>
            <td>H</td>
            <td>追加模式空间的内容到内存缓冲区中。</td>
        </tr>
        <tr>
            <td>g</td>
            <td>将内存缓冲区的内容复制回模式空间中，替代当前内容。</td>
        </tr>
        <tr>
            <td>G</td>
            <td>将内存缓冲区的内容追加到模式空间末尾。</td>
        </tr>
        <tr>
            <td>l</td>
            <td>列出不可打印字符的清单。</td>
        </tr>
        <tr>
            <td>n</td>
            <td>读取下一个输入行，并用下一个命令处理新行而不是第一个命令。</td>
        </tr>
        <tr>
            <td>N</td>
            <td>追加下一个输入行到模式空间后面，并在二者间插入一个新行，更新当前行号。</td>
        </tr>
        <tr>
            <td>p</td>
            <td>打印模式空间中的行。</td>
        </tr>
        <tr>
            <td>P</td>
            <td>(大写) 打印模式空间中的第一行。</td>
        </tr>
        <tr>
            <td>q</td>
            <td>退出Sed。</td>
        </tr>
        <tr>
            <td>b label</td>
            <td>分支到脚本中标记的地方，如果标记不存在，则跳转到脚本末尾。</td>
        </tr>
        <tr>
            <td>r file</td>
            <td>从file文件中读取行并添加到输出流中。</td>
        </tr>
        <tr>
            <td>t label</td>
            <td>if分支，从最后一行开始，条件满足时跳转到带标签的命令处，否则跳转到脚本末尾。</td>
        </tr>
        <tr>
            <td>T label</td>
            <td>错误分支，从最后一行开始，一旦发生错误则跳转到带标签的命令处，否则跳转到脚本末尾。</td>
        </tr>
        <tr>
            <td>w file</td>
            <td>写并追加模式空间的内容到file文件末尾。</td>
        </tr>
        <tr>
            <td>W file</td>
            <td>写并追加模式空间的第一行到file文件末尾。</td>
        </tr>
        <tr>
            <td>!</td>
            <td>指示后面的命令对所有未被选择的行生效。</td>
        </tr>
        <tr>
            <td>=</td>
            <td>打印当前行号。</td>
        </tr>
        <tr>
            <td>#</td>
            <td>扩展注释到下一个换行符为止。</td>
        </tr>
    </tbody>
</table>
<table>
    <captionn>sed替换标记</caption>
    <thead>
        <tr>
            <th width="10%">命令</th>
            <th width="90%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>g</td>
            <td>全局替换：表示在当前行内全面替换指定的文本。</td>
        </tr>
        <tr>
            <td>p</td>
            <td>打印：表示打印当前处理的行。</td>
        </tr>
        <tr>
            <td>w file</td>
            <td>写入文件：表示把当前处理的行写入到指定的文件中。</td>
        </tr>
        <tr>
            <td>x</td>
            <td>交换缓冲区：表示互换模式空间（即当前处理的行）中的文本和内存缓冲区中的文本内容。</td>
        </tr>
        <tr>
            <td>y/old/new/</td>
            <td>字符翻译：表示把行内所有'old'字符翻译为'new'字符，但不支持正则表达式匹配。</td>
        </tr>
        <tr>
            <td>\1, \2, ...</td>
            <td>子串匹配标记：在替换命令中使用时，引用之前正则表达式中的分组匹配结果。</td>
        </tr>
        <tr>
            <td>&amp;</td>
            <td>已匹配字符串标记：在替换命令中使用时，代表整个已匹配的子串。</td>
        </tr>
    </tbody>
</table>
<table>
    <caption>sed元字符集</caption>
  <thead>
    <tr>
      <th width="10%">正则表达式符号</th>
      <th width="90%">含义与示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>^</td>
      <td>匹配行开始。例如：/^sed/ 匹配所有以 "sed" 开头的行。</td>
    </tr>
    <tr>
      <td>$</td>
      <td>匹配行结束。例如：/sed$/ 匹配所有以 "sed" 结尾的行。</td>
    </tr>
    <tr>
      <td>.</td>
      <td>匹配一个非换行符的任意字符。例如：/s.d/ 匹配所有以 "s" 后接一个任意字符，最后是 "d" 的字符串。</td>
    </tr>
    <tr>
      <td>*</td>
      <td>匹配0个或多个前面的字符。例如：/*sed/ 匹配所有模板中包含一个或多个空格后紧跟 "sed" 的行。</td>
    </tr>
    <tr>
      <td>[]</td>
      <td>匹配指定范围内的单个字符。例如：/[sS]ed/ 匹配 "sed" 和 "Sed"。</td>
    </tr>
    <tr>
      <td>[^]</td>
      <td>匹配不在指定范围内的单个字符。例如：/[^A-RT-Z]ed/ 匹配不包含 A-R 和 T-Z 范围内字母开头，但以 "ed" 结尾的单词。</td>
    </tr>
    <tr>
      <td>\( .. \)</td>
      <td>匹配子串并保存匹配内容。例如：s/\(love\)able/\1rs，将 "loveable" 替换为 "lovers"。</td>
    </tr>
    <tr>
      <td>&amp;</td>
      <td>在替换命令中使用时，代表整个已匹配的子串。例如：s/love/ **&** /，将 "love" 替换为 " **love** "。</td>
    </tr>
    <tr>
      <td>\<</td>
      <td>匹配单词的开始。例如：/\<love/ 匹配包含以 "love" 开头单词的行。</td>
    </tr>
    <tr>
      <td>\></td>
      <td>匹配单词的结束。例如：/love\>/ 匹配包含以 "love" 结尾单词的行。</td>
    </tr>
    <tr>
      <td>x\{m\}</td>
      <td>重复字符 x 共 m 次。例如：/0\{5\}/ 匹配包含连续 5 个 "0" 的行。</td>
    </tr>
    <tr>
      <td>x\{m,\}</td>
      <td>重复字符 x 至少 m 次。例如：/0\{5,\}/ 匹配至少包含连续 5 个 "0" 的行。</td>
    </tr>
    <tr>
      <td>x\{m,n\}</td>
      <td>重复字符 x 至少 m 次，但不多于 n 次。例如：/0\{5,10\}/ 匹配包含连续 5 到 10 个 "0" 的行。</td>
    </tr>
  </tbody>
</table>

```shell
# 删除第2行
sed '2d' /home/zjk/note-book/ilog/igit_log.csv
```

# sort 文件数据排序

- sort命令默认会将文本中的数据当成字符来排序按照会话指定的默认语言的升序排序顺序输出，包括数字和时间日期等，而不是按照相应的规则来排序。

| 命令                                       | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| sort -n                                    | 将文本识别为数字来排序                                       |
| sort -M                                    | 将文本识别为Mar形式的月份来排序                              |
| sort -t '分隔字符' -k 指定排序的字符段位置 | -t对每行的字符段进行分隔，然后-k选择每行分隔的其中一段字符进行排序 |
| sort -r                                    | 将排序结果降序输出                                           |

```shell
# sort -t '字符' -k  文件
# 将/etc/passwd按uid来排序
[root@bogon ~]# sort -t ':' -k 3  /etc/passwd | head -n 5
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
```

# grep 文本过滤

- grep：默认区分大小写、支持正则。
- 如果把grep命令当作标准搜索命令，那么egrep则是扩展搜索命令，等价于grep -E命令，支持扩展的正则表达式；而fgrep则是快速搜索命令，等价于grep -F命令，不支持正则表达式，直接按照字符串内容进行匹配。

```shell
grep [选项] {"查找目标文本" | 查找目标文本} {被过滤文本}
```

<table><tbody><tr><td>-b</td><td>显示匹配行距文件头部的偏移量</td><td rowspan="6">&nbsp;</td><td>-o</td><td>显示匹配词距文件头部的偏移量</td></tr><tr><td>-c</td><td>只显示匹配的行数</td><td>-q</td><td>静默执行模式</td></tr><tr><td>-E</td><td>支持扩展正则表达式</td><td>-r</td><td>递归搜索模式</td></tr><tr><td>-F</td><td>匹配固定字符串的内容</td><td>-s</td><td>不显示没有匹配文本的错误信息</td></tr><tr><td>-h</td><td>搜索多文件时不显示文件名</td><td>-v</td><td>显示不包含匹配文本的所有行</td></tr><tr><td>-i</td><td>忽略关键词大小写</td><td>-w</td><td>精准匹配整词</td></tr><tr><td>-l</td><td>只显示符合匹配条件的文件名</td><td>&nbsp;</td><td>-x</td><td>精准匹配整行</td></tr><tr><td>-n</td><td>显示所有匹配行及其行号</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table>

# wc 统计文本

- <code>wc</code>会统计数据中的文本，在默认情况下，该命令会输出三个值：文本的行数、文本的单词数、文本的字节数。若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。

<table>
    <thead>
        <tr>
            <th>命令选项</th>
            <th>描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>-c, --bytes</td>
            <td>统计字节数，显示文件中的Bytes总数。</td>
        </tr>
        <tr>
            <td>-l, --lines</td>
            <td>统计行数，显示文件中的行数。</td>
        </tr>
        <tr>
            <td>-m, --chars</td>
            <td>统计字符数，显示文件中字符的总数（不包括换行符）。</td>
        </tr>
        <tr>
            <td>-w, --words</td>
            <td>统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串，显示文件中的单词总数。</td>
        </tr>
        <tr>
            <td>-L, --max-line-length</td>
            <td>打印最长行的长度，显示文件中最长行包含多少个字符（包括换行符）。</td>
        </tr>
        <tr>
            <td>-help</td>
            <td>显示帮助信息，提供关于命令用法和选项的详细说明。</td>
        </tr>
        <tr>
            <td>--version</td>
            <td>显示版本信息，输出命令工具的当前版本号。</td>
        </tr>
    </tbody>
</table>

```shell
wc < /home/zjk/note-book/ilog/*.csv
# 15 165 921
# 分别对应于 l m c，即：行 字符 字节
```

# awk 文本处理

- awk是一种对文本和数据进行处理的编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入（stdin）、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能。

```shell
awk [options] 'script' var=value file(s)
awk [options] -f scriptfile var=value file(s)
```

| 选项         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| -F fs        | fs指定输入分隔符，fs可以是字符串或正则表达式                 |
| -v var=value | 赋值一个用户定义变量，将外部变量传递给awk                    |
| -f scripfile | 从脚本文件中读取awk命令                                      |
| -m[fr] val   | （实验功能）对val值设置内在限制<br />-mf选项限制分配给val的最大块数目<br />-mr选项限制记录的最大数目 |

- awk脚本是由模式和操作组成的：

- 模式可以是以下任意一个：
  - /正则表达式/：使用通配符的扩展集。
  - 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。
  - 模式匹配表达式：用运算符`~`（匹配）和`!~`（不匹配）。
  - BEGIN语句块、pattern语句块、END语句块。
- 操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是：
  - 变量或数组赋值
  - 输出命令
  - 内置函数
  - 控制流语句

## BEGIN-pattern-END

```shell
awk 'BEGIN{ commands } pattern{ commands } END{ commands }'
```

<table>
    <tr>
        <td width="15%">BEGIN语句块</td>
        <td width="5%">可选</td>
        <td width="80%">在awk开始从输入流中<b>读取行之前</b>被执行，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中</td>
    </tr>
    <tr>
        <td>END语句块</td>
        <td>可选</td>
        <td>在awk从输入流中<b>读取完所有的行之后</b>即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成</td>
    </tr>
    <tr>
        <td>pattern语句块</td>
        <td>可选</td>
        <td>该语句块中的通用命令是最重要的部分，awk读取的每一行都会执行该语句块。如果没有提供pattern语句块，则默认执行<code>{ print }</code> 打印每一个读取到的行</td>
    </tr>
</table>

1. 第一步：执行`BEGIN{ commands }`语句块中的语句；
2. 第二步：从文件或标准输入（stdin）读取一行，然后执行`pattern{ commands }`语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。
3. 第三步：当读至输入流末尾时，执行`END{ commands }`语句块。

<img src="../../pictures/Linux-awk-BEGIN-pattern-END.drawio.svg" width="500"/> 

- `{ }`类似一个循环体，会对文件中的每一行进行迭代。

### print

- 拼接符（`""`）：当使用不带参数的`print`时，它就打印当前行；当`print`的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用。

```shell
echo | awk '{ var1="v1"; var2="v2"; var3="v3"; print var1"="var2"="var3; }'
# v1=v2=v3
```

## awk内置变量（预定义变量）

<table>
    <thead>
        <tr>
            <th style="text-align: left;" width="20%">变量名</th>
            <th style="text-align: left;" width="80%">含义</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$n</td>
            <td>当前记录的第n个字段，n为1表示第一个字段，n为2表示第二个字段等。</td>
        </tr>
        <tr>
            <td>$0</td>
            <td>包含执行过程中当前行的完整文本内容。</td>
        </tr>
        <tr>
            <td>ARGC</td>
            <td>命令行参数的数量。</td>
        </tr>
        <tr>
            <td>ARGIND</td>
            <td>命令行中当前文件的位置索引，从0开始计数。</td>
        </tr>
        <tr>
            <td>ARGV</td>
            <td>包含所有命令行参数的数组。</td>
        </tr>
        <tr>
            <td>CONVFMT</td>
            <td>数字转换格式，默认值为 "%.6g"。</td>
        </tr>
        <tr>
            <td>ENVIRON</td>
            <td>环境变量关联数组。</td>
        </tr>
        <tr>
            <td>ERRNO</td>
            <td>最后一个系统错误的描述。</td>
        </tr>
        <tr>
            <td>FIELDWIDTHS</td>
            <td>字段宽度列表，各字段宽度之间用空格分隔。</td>
        </tr>
        <tr>
            <td>FILENAME</td>
            <td>当前正在处理的输入文件名。</td>
        </tr>
        <tr>
            <td>FNR</td>
            <td>同NR，但在当前文件内计数，表示当前文件的行号。</td>
        </tr>
        <tr>
            <td>FS</td>
            <td>字段分隔符，默认为空格字符。</td>
        </tr>
        <tr>
            <td>IGNORECASE</td>
            <td>布尔值，若为真则进行忽略大小写的匹配操作。</td>
        </tr>
        <tr>
            <td>NF</td>
            <td>表示当前记录的字段数，在执行过程中动态变化。</td>
        </tr>
        <tr>
            <td>NR</td>
            <td>全局行号，表示处理过的总行数，在执行过程中对应当前行号。</td>
        </tr>
        <tr>
            <td>OFMT</td>
            <td>数字的输出格式，默认值为 "%.6g"。</td>
        </tr>
        <tr>
            <td>OFS</td>
            <td>输出字段分隔符，默认是一个空格字符。</td>
        </tr>
        <tr>
            <td>ORS</td>
            <td>输出记录分隔符，默认是一个换行符。</td>
        </tr>
        <tr>
            <td>RS</td>
            <td>记录分隔符，默认是一个换行符。</td>
        </tr>
        <tr>
            <td>RSTART</td>
            <td>由match函数匹配到的子串在目标字符串中的起始位置。</td>
        </tr>
        <tr>
            <td>RLENGTH</td>
            <td>由match函数匹配到的子串的长度。</td>
        </tr>
        <tr>
            <td>SUBSEP</td>
            <td>数组下标分隔符，默认值是ASCII码34，即双引号（"）。</td>
        </tr>
    </tbody>
</table>


# yes

- `yes`：重在输出指定的字符串（默认有换行），直到yes进程被杀死

```shell
# 创建test.txt文件，并使用yes输出hello来填充，直到文件到达100MB大小
touch test.txt; yes "hello" | head -c 100MB > test.txt
```