# echo 格式化输出

```shell
echo -e "\e[编码1;编码2;编码3m内容"
# 文字色：
#颜色码：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37
echo -e "\e[1;31m内容\e[0m"
#\e[1;31m 将颜色设置为红色
#\e[0m 将颜色重新置回
# 背景色 ：
#颜色码：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47
echo -e "\e[1;42m内容\e[0m"
# 文字闪动：

# 0 关闭所有属性、1 设置高亮度（加粗）、4 下划线、5 闪烁、7 反显、8 消隐
echo -e "\033[37;31;5mMySQL Server Stop...\033[39;49;0m"
```

# sed 流编辑器

- sed（stream editor）：批量编辑，执行基本文本输入流（来自管道的文件或输入）上的转换，只对输入进行一次传递。
- 处理时，把当前处理的行存储在临时缓冲区（模式空间 pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕；接着处理下一行，这样不断重复，直到文件末尾；除非使用重定向存储输出，否则文件内容并不改变。

```shell
sed [options] 'command' file(s)
sed [options] -f scriptfile file(s)
```

<table><tbody><tr><td width="5%">-e</td><td width="42.5%">使用指定脚本（命令）处理输入的文本文件</td><td rowspan="4" width="5%">&nbsp;</td><td width="5%">-n</td><td width="42.5%">仅显示脚本处理后的结果</td></tr><tr><td>-f</td><td>使用指定脚本文件处理输入的文本文件</td><td>-r</td><td>支持扩展正则表达式</td></tr><tr><td>-h</td><td>显示帮助信息</td><td>-V</td><td>显示版本信息</td></tr><tr><td>-i</td><td>直接修改文件内容，而不输出到终端</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table>

# sort 文件数据排序

- sort命令默认会将文本中的数据当成字符来排序按照会话指定的默认语言的升序排序顺序输出，包括数字和时间日期等，而不是按照相应的规则来排序。

| 命令                                       | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| sort -n                                    | 将文本识别为数字来排序                                       |
| sort -M                                    | 将文本识别为Mar形式的月份来排序                              |
| sort -t '分隔字符' -k 指定排序的字符段位置 | -t对每行的字符段进行分隔，然后-k选择每行分隔的其中一段字符进行排序 |
| sort -r                                    | 将排序结果降序输出                                           |

```shell
# sort -t '字符' -k  文件
# 将/etc/passwd按uid来排序
[root@bogon ~]# sort -t ':' -k 3  /etc/passwd | head -n 5
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
```

# grep 文本过滤

- grep：默认区分大小写、支持正则。
- 如果把grep命令当作标准搜索命令，那么egrep则是扩展搜索命令，等价于grep -E命令，支持扩展的正则表达式；而fgrep则是快速搜索命令，等价于grep -F命令，不支持正则表达式，直接按照字符串内容进行匹配。

```shell
grep [选项] {"查找目标文本" | 查找目标文本} {被过滤文本}
```

<table><tbody><tr><td>-b</td><td>显示匹配行距文件头部的偏移量</td><td rowspan="6">&nbsp;</td><td>-o</td><td>显示匹配词距文件头部的偏移量</td></tr><tr><td>-c</td><td>只显示匹配的行数</td><td>-q</td><td>静默执行模式</td></tr><tr><td>-E</td><td>支持扩展正则表达式</td><td>-r</td><td>递归搜索模式</td></tr><tr><td>-F</td><td>匹配固定字符串的内容</td><td>-s</td><td>不显示没有匹配文本的错误信息</td></tr><tr><td>-h</td><td>搜索多文件时不显示文件名</td><td>-v</td><td>显示不包含匹配文本的所有行</td></tr><tr><td>-i</td><td>忽略关键词大小写</td><td>-w</td><td>精准匹配整词</td></tr><tr><td>-l</td><td>只显示符合匹配条件的文件名</td><td>&nbsp;</td><td>-x</td><td>精准匹配整行</td></tr><tr><td>-n</td><td>显示所有匹配行及其行号</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table>

# awk 文本处理

- awk是一种对文本和数据进行处理的编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入（stdin）、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能。

```shell
awk [options] 'script' var=value file(s)
awk [options] -f scriptfile var=value file(s)
```

| 选项         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| -F fs        | fs指定输入分隔符，fs可以是字符串或正则表达式                 |
| -v var=value | 赋值一个用户定义变量，将外部变量传递给awk                    |
| -f scripfile | 从脚本文件中读取awk命令                                      |
| -m[fr] val   | （实验功能）对val值设置内在限制<br />-mf选项限制分配给val的最大块数目<br />-mr选项限制记录的最大数目 |

- awk脚本是由模式和操作组成的：

- 模式可以是以下任意一个：
  - /正则表达式/：使用通配符的扩展集。
  - 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。
  - 模式匹配表达式：用运算符`~`（匹配）和`!~`（不匹配）。
  - BEGIN语句块、pattern语句块、END语句块。
- 操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是：
  - 变量或数组赋值
  - 输出命令
  - 内置函数
  - 控制流语句

## BEGIN-pattern-END

```shell
awk 'BEGIN{ commands } pattern{ commands } END{ commands }'
```

<table>
    <tr>
        <td width="15%">BEGIN语句块</td>
        <td width="5%">可选</td>
        <td width="80%">在awk开始从输入流中<b>读取行之前</b>被执行，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中</td>
    </tr>
    <tr>
        <td>END语句块</td>
        <td>可选</td>
        <td>在awk从输入流中<b>读取完所有的行之后</b>即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成</td>
    </tr>
    <tr>
        <td>pattern语句块</td>
        <td>可选</td>
        <td>该语句块中的通用命令是最重要的部分，awk读取的每一行都会执行该语句块。如果没有提供pattern语句块，则默认执行<code>{ print }</code> 打印每一个读取到的行</td>
    </tr>
</table>

1. 第一步：执行`BEGIN{ commands }`语句块中的语句；
2. 第二步：从文件或标准输入（stdin）读取一行，然后执行`pattern{ commands }`语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。
3. 第三步：当读至输入流末尾时，执行`END{ commands }`语句块。

<img src="../../pictures/Linux-awk-BEGIN-pattern-END.drawio.svg" width="500"/> 

- `{ }`类似一个循环体，会对文件中的每一行进行迭代。

### print

- 拼接符（`""`）：当使用不带参数的`print`时，它就打印当前行；当`print`的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用。

```shell
echo | awk '{ var1="v1"; var2="v2"; var3="v3"; print var1"="var2"="var3; }'
# v1=v2=v3
```

## awk内置变量（预定义变量）

<table>
    <thead>
        <tr>
            <th style="text-align: left;" width="20%">变量名</th>
            <th style="text-align: left;" width="80%">含义</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$n</td>
            <td>当前记录的第n个字段，n为1表示第一个字段，n为2表示第二个字段等。</td>
        </tr>
        <tr>
            <td>$0</td>
            <td>包含执行过程中当前行的完整文本内容。</td>
        </tr>
        <tr>
            <td>ARGC</td>
            <td>命令行参数的数量。</td>
        </tr>
        <tr>
            <td>ARGIND</td>
            <td>命令行中当前文件的位置索引，从0开始计数。</td>
        </tr>
        <tr>
            <td>ARGV</td>
            <td>包含所有命令行参数的数组。</td>
        </tr>
        <tr>
            <td>CONVFMT</td>
            <td>数字转换格式，默认值为 "%.6g"。</td>
        </tr>
        <tr>
            <td>ENVIRON</td>
            <td>环境变量关联数组。</td>
        </tr>
        <tr>
            <td>ERRNO</td>
            <td>最后一个系统错误的描述。</td>
        </tr>
        <tr>
            <td>FIELDWIDTHS</td>
            <td>字段宽度列表，各字段宽度之间用空格分隔。</td>
        </tr>
        <tr>
            <td>FILENAME</td>
            <td>当前正在处理的输入文件名。</td>
        </tr>
        <tr>
            <td>FNR</td>
            <td>同NR，但在当前文件内计数，表示当前文件的行号。</td>
        </tr>
        <tr>
            <td>FS</td>
            <td>字段分隔符，默认为空格字符。</td>
        </tr>
        <tr>
            <td>IGNORECASE</td>
            <td>布尔值，若为真则进行忽略大小写的匹配操作。</td>
        </tr>
        <tr>
            <td>NF</td>
            <td>表示当前记录的字段数，在执行过程中动态变化。</td>
        </tr>
        <tr>
            <td>NR</td>
            <td>全局行号，表示处理过的总行数，在执行过程中对应当前行号。</td>
        </tr>
        <tr>
            <td>OFMT</td>
            <td>数字的输出格式，默认值为 "%.6g"。</td>
        </tr>
        <tr>
            <td>OFS</td>
            <td>输出字段分隔符，默认是一个空格字符。</td>
        </tr>
        <tr>
            <td>ORS</td>
            <td>输出记录分隔符，默认是一个换行符。</td>
        </tr>
        <tr>
            <td>RS</td>
            <td>记录分隔符，默认是一个换行符。</td>
        </tr>
        <tr>
            <td>RSTART</td>
            <td>由match函数匹配到的子串在目标字符串中的起始位置。</td>
        </tr>
        <tr>
            <td>RLENGTH</td>
            <td>由match函数匹配到的子串的长度。</td>
        </tr>
        <tr>
            <td>SUBSEP</td>
            <td>数组下标分隔符，默认值是ASCII码34，即双引号（"）。</td>
        </tr>
    </tbody>
</table>


# yes

- `yes`：重在输出指定的字符串（默认有换行），直到yes进程被杀死

```shell
# 创建test.txt文件，并使用yes输出hello来填充，直到文件到达100MB大小
touch test.txt; yes "hello" | head -c 100MB > test.txt
```