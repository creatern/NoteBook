# Linux环境变量

- bash shell使用环境变量来存储shell会话和工作环境的相关信息。环境变量允许在内存中存储数据，以便shell中运行的程序或脚本能够轻松访问到这些数据。

<table>
    <tr>
        <th width="15%">变量类型</th>
        <th width="10%">命名规范</th>
        <th width="50%">可见性</th>
        <th width="25%">声明与定义</th>
    </tr>
    <tr>
        <td><a href="#export">全局环境变量</a></td>
        <td>大写</td>
        <td>对于shell会话和其所有生成的子shell都是可见的</td>
        <td>export</td>
    </tr>
    <tr>
        <td>局部环境变量</td>
        <td>小写</td>
        <td>仅创建该局部变量的当前shell可见</td>
        <td>大部分方式</td>
    </tr>
</table>

- 局部变量仅在创建其的shell进程中可见。如果进入到其子shell或父shell，则该局部变量不可见；但如果回到创建其的shell中，则可见。

```shell
zjk@zjk-laptop:~$ ihello="hello linux"
zjk@zjk-laptop:~$ echo $ihello
hello linux
zjk@zjk-laptop:~$ bash
zjk@zjk-laptop:~$ echo $ihello

zjk@zjk-laptop:~$ exit
exit
zjk@zjk-laptop:~$ echo $ihello
hello linux
```

# 查看环境变量

## env

- env：显示系统中已存在的环境变量；如果使用env命令在新环境中执行指令时，会因为没有定义环境变量“PATH”（/etc/profile）而提示错误信息，此时，用户可以重新定义一个新的“PATH”或者使用绝对路径。
- env不对输出结果排序，不输出局部变量和用户定义变量；查看全局变量时，使用env、printenv。

## printenv

- printenv：不对输出结果排序，不输出局部变量和用户定义变量；查看个别环境变量时，使用printenv而不是env。

## [set](#set)

- set：显示当前环境变量的完整列表，包括局部变量、全局变量、用户定义变量；对输出的结果按照字母顺序来排序。

# \$ 变量符

- <span name="变量引用"><code><a href="#用户自定义变量">$</a></code></span>表示对指定变量的引用，可以引用各类环境变量。每次引用变量，输出的都是变量的当前值。

```shell
# 打印当前用户
echo $USER;
```

<table>
    <tr>
        <th width="10%">特殊变量</th>
        <th width="90%">说明</th>
    </tr>
    <tr>
        <td rowspan="2">$n</td>
        <td>位置参数,<Code>$0</Code>通常代表该脚本文件名；$1~$9代表当前脚本shell输入的第1~9个参数</td>
    </tr>
    <tr>
        <td>对于2位数字以上的参数位置，需要使用<code>{}</code>来辅助界定，如<code>${10}</code>表示第10个参数；否则，如<Code>$10</Code>表示第1个参数并在之后输出0</td>
    </tr>
    <tr>
        <td>$#</td>
        <td>获取所有输入参数个数（常用于循环），判断参数的个数是否正确以及加强脚本的健壮性</td>
    </tr>
    <tr>
        <td rowspan="2">$*</td>
        <td>表示输入脚本shell的所有的参数，把所有的参数看成一个整体</td>
    </tr>
    <tr>
        <td>被双引号“”包含时，<code>$*</code>以“$1 $2 …$n”的形式输出所有参数</td>
    </tr>
    <tr>
        <td rowspan="2">$@</td>
        <td>表示输入脚本shell的所有的参数，把每个参数区分对待</td>
    </tr>
    <tr>
        <td>被双引号“”包含时，<code>$@</code>以“$1” “$2”...“$n”的形式输出所有参数</td>
    </tr>
    <tr>
        <td>$?</td>
        <td>最后一次执行的命令的返回状态（退出状态码）</td>
    </tr>
</table> 
## <code>$number</code> 位置参数

- 命令行参数是在命令/脚本名出现的各个单词，而位置参数是用于保存命令行参数（以及函数参数）的变量。bash shell会将所有的命令行参数（包括脚本参数）都指派给称作位置参数（positional parameter）的特殊变量。
- 位置参数的名称都是标准的数字。例如，<code>$0~$9</code>分别对于脚本名及其之后的命令行参数。对于9以后的数字的参数位置，需要使用<code>{}</code>来辅助界定（所有变量都可以使用<code>{}</code>来辅助界定），如<code>${10}</code>表示第10个参数；否则，如<code>$10</code>表示第1个参数并在之后输出0。

### <code>$0</code>

- <code>$0</code>表示的有时候可能不是脚本名

1. <code>$0</code>代表着的通常是脚本路径名。如果运行脚本时使用的是绝对路径，那么<code>$0</code>输出的就是这个绝对路径名；而如果是相对路径，那么<code>$0</code>输出的就是相对路径名。
2. 此外，如果使用<code>.</code>命令或<code>source</code>命令来运行脚本，那么该脚本的<code>$0</code>就有可能会是这个命令对应的shell（bash），而脚本名就读取不到了（并不会跑到<code>$1</code>的位置去）。
3. 使用shell来运行脚本时，不会导致<code>$0</code>的改变，仍然会是该脚本的路径名。

```shell
echo $0
echo $1

# 通过 . 命令或 source 命令来运行脚本
. ShellProjects/test09-position.sh
soruce ShellProjects/test09-position.sh
# bash
# （空格）
```

## <code>$#</code>、<code>${!#}</code> 参数统计

- <code>$#</code>含有脚本运行是携带的命令行参数的个数（不包括<code>$0</code>在内）。
- <code>${!#}</code>是对<code>$#</code>的特殊变换。当命令行参数个数为0时，<code>$#</code>的值为0，但是<code>${!#}</code>的值却和<code>$0</code>的值相同；而其余情况下（命令行参数个数不为0时），<code>${!#}</code>和<code>$#</code>的值是一样的。

## <code>$*</code>、<code>$@</code> 获取所有参数

<table>
    <tr>
        <td rowspan="2">$*</td>
        <td>表示输入脚本shell的所有的参数，把所有的参数看成一个整体</td>
    </tr>
    <tr>
        <td>被双引号“”包含时，<code>$*</code>以“$1 $2 …$n”的形式输出所有参数</td>
    </tr>
    <tr>
        <td rowspan="2">$@</td>
        <td>表示输入脚本shell的所有的参数，把每个参数区分对待</td>
    </tr>
    <tr>
        <td>被双引号“”包含时，<code>$@</code>以“$1” “$2”...“$n”的形式输出所有参数</td>
    </tr>    
</table>

- 也就是说，`$*`和<code>$@</code>在正常情况下（没有被双引号包含时），会是以空格为分隔的一组值；而如果被双引号包含，那么<code>$*</code>会被当作正常的一个字符串值（各个值之间的<a href="./Shell脚本.md#IFS环境变量">IFS变量</a>也会被打印出来）来对待，也就是不进行分隔，而<code>$@</code>则可以保持其原来的特性，即仍然是被一组分隔的值。

<img src="../../pictures/20231219083240.png" width="800"/> 

## <code>$?</code> 退出状态码

- <a href="./Shell脚本.md#退出状态码"><span name="退出状态码1">$?</span></a>代表着最后一次执行的命令的返回状态（退出状态码）

# 变量定义与赋值

## 用户自定义变量

- <span name="用户自定义变量">用户自定义变量</span>：shell允许用户在脚本中定义和使用自己的变量。定义变量允许在脚本中临时存储并使用数据。

1. 变量名区分大小写，bash shell惯例所有的环境变量均使用大写字母，而用户自定义变量或局部变量则使用小写字母命名。
2. 变量名称可以由字母、数字和下划线组成，长度不能超过20个字符；不能以数字开头。
3. 使用等号“=”为变量赋值，变量定义和赋值时，等号两侧不能有空格。如，<code>i=1</code>。
4. 在 bash shell 中，变量的默认类型都是字符串类型，shell脚本会以字符串形式存储所有的变量值。因此，变量通常无法直接进行数值运算。
5. 变量的值内部如果有空格，需要使用双引号或单引号括起来，表示为一个完整的字符串。
6. 在为变量赋值时，只需要使用变量名即可（例如，<code>i=1</code>），不需要使用`$`（<code><a href="#变量引用">$</a></code>表示的是变量引用）。也就是说，`$`可以看作变量的值（引用），而为变量的值赋值是不被允许的（command not found）。

## declare 声明与显示

- declare：声明和显示已存在的shell变量

```shell
变量名=变量值

declare 变量名 = 变量值
```

## set 赋值与显示

- <span name="set">set</span>：显示系统中已经存在的shell变量、设置shell变量的新变量值；不能定义新的shell变量。

```shell
# 可以对现有的变量进行追加或拼接
var=$var"append"
```

### <a href="./Shell脚本.md#替换位置参数"><code>set --</code></a> 替换位置参数

## readonly 只读变量

- readonly：定义只读shell变量和shell函数。

## export 全局环境变量

- <span name="export">export</span>：将shell变量、函数输出为全局环境变量。

1. 在子shell中修改（或删除）全局变量，不会影响到父shell中该全局变量的值，只会影响该子shell以及其创建的子shell的全局变量的值。
2. 一个变量创建时，它不会自动地为在它之后创建的shell进程所知；而export命令可以向后面的shell传递变量的值。即一个shell脚本被调用并执行时，它不会自动得到原为脚本（调用者）定义的变量的访问权，除非这些变量已经被显式地设置为可用。

## unset 删除环境变量

- unset：删除已定义的shell变量（包括环境变量）、shell函数；不能删除具有只读属性的shell变量和环境变量。

#  系统环境变量

- 在默认情况下，bash shell会用一些特定的环境变量（已经设置好的）来定义系统环境。

| 系统变量 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| PATH     | 执行文件查找的路径（/etc/profile 路径文件）；文件查找的顺序与PATH的变量的顺序有关<br />目录与目录中间以:冒号隔开 |
| HOME     | 当前用户主目录                                               |
| USER     | 当前用户                                                     |
| HISTSIZE | 代表可以容纳多少条历史命令                                   |
| LOGNAME  | 当前用户的登录名                                             |
| HOSTNAME | 指主机的名称                                                 |
| SHELL    | 当前用户Shell类型                                            |
| LANG     | 当前的语系类型                                               |
| MAIL     | 当前用户的邮件存放目录                                       |
| PS1      | 基本提示符                                                   |
| RANDOM   | 随机数的变量                                                 |

## PATH环境变量

- PATH环境变量定义了查找命令和程序的目录。当用户在shell CLI中输入一个外部命令时，shell必须搜索系统，从中找到对应的程序。如果命令或程序所在的位置没有包括在PATH变量中，那么在不使用绝对路径的情况小，shell是无法找到的“command not found”。
- PATH环境变量内的目录以冒号（`:`）分隔，shell会在其中查找命令和程序。PATH环境变量无须从头定义，而是在之后追加`:`和需要加入的目录即可。

```shell
# 查看PATH环境变量
zjk@zjk-laptop:~$ echo $PATH
/home/zjk/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/usr/software/idea/bin:/usr/lib/jvm/jdk-17.0.9/bin:/opt/apache-maven-3.9.3/bin:/opt/gradle-8.2.1/bin:/opt/groovy-4.0.13/bin:/opt/node20.10.0/bin

# 临时定义PATH
PATH=$PATH:/opt/mysoft/bin

# 在/etc/profile中永久定义PATH
vim /etc/profile
```

## 语系变量 locale、localectl

| 命令      | 说明                           |
| --------- | ------------------------------ |
| locale    | 当前软件的语系，不修改配置文件 |
| localectl | 当前系统的语系，修改配置文件   |

```shell
# 设置当前系统语系 同时修改配置文件
localectl set-locale LANG=en_US.UTF-8 
```

- `LANG`与`LC_ALL`：设置语系变量时，一般建议更改这两个变量，其他语系变量都会替换成`LANG`与`LC_ALL`这两个变量的值。`LANG`直接用=号赋值即可；而`LC_ALL`需要使用export设置。

```shell
LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
```

# 数组变量

- 环境变量可以作为数组来使用，要为某个环境变量设置多个值，可以把值放在圆括号中，值与值之间以空格分隔。
- Linux数组变量的下标从0开始。

```shell
# 声明数组变量
myarr=(Tom Jack Mac)

# 显示数组的第一个值
echo $myarr
echo ${myarr[0]}

# 通配符显示整个数组变量
echo ${myarr[*]}

# 修改或赋值给数组
myarr[1]=Tim
myarr[11]=Li
```