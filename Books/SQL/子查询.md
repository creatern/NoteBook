# 子查询概述

- 子查询 （内查询） 在主查询之前执行完成，其结果被主查询（外查询）使用。子查询的查询性能通常消耗较大，尽量减少使用子查询。

| 子查询返回       | 说明                     |
| ---------------- | ------------------------ |
| 未返回任何行     | 主查询也不会返回任何结果 |
| 单行结果（标量） | 使用在适用于标量的位置   |
| 多行结果（关系） | 使用在适用于关系的位置   |

# 单行子查询

- 单行子查询只能返回一行结果，不能返回空值、只能使用单行操作符 `=、>、>=、<、<=、<>`。


```sql
-- 显示员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’,其余则 为’USA’。

-- 1.1 case -- 在case中使用单列子查询
select employee_id
      ,last_name
      ,department_id
      ,(case when department_id = (
                                   select department_id
                                   from departments
                                   where location_id = 1800
                                  )
                 then 'Canada'
             else 'USA'
        END) location
from employees
order by department_id;

-- 1.2 case -- 在case中使用单列子查询
select employee_id
      ,last_name
      ,department_id
      ,(case department_id when  (
                                  select department_id
                                  from departments
                                  where location_id = 1800
                                  )
                                then 'Canada'
                           else 'USA'
END) location
from employees
order by department_id;

-- 2. decode
select employee_id
      ,last_name
      ,decode( department_id
              ,(
                select department_id
                from departments
                where location_id = 1800
                )
              ,'Canada'
              ,'USA'
             ) location
from employees
order by location DESC;
```

# 多行子查询

| 多行操作符     | 描述                                           |
| :------------- | :--------------------------------------------- |
| in<br />exists | 等号列表中任意一个/关系中是否存在满足条件的行  |
| any<br />some  | 和子查询返回的任意一个值比较，只要一个满足即可 |
| all            | 和子查询返回的所有值比较，需要满足所有         |


```sql
-- 返回job_id和141号员工相同，salary比143号员工多的姓名，job_id工资
select last_name
      ,salary
      ,job_id
from employees
where job_id = (
                select job_id
                from employees
                where employee_id = 141
                )
and salary > (
              select salary
              from employees
              where employee_id = 143
              );
```

```sql
-- 返回其他部门中比job_id为'IT_PROG'部门任一工资低的员工的员工号，姓名，job_id和salary
select employee_id
      ,last_name
      ,job_id
      ,salary
from employees
where salary < ANY(
                   select salary
                   from employees
                   where job_id = 'IT_PROG'
                   );
```


```sql
-- 查找部门中工资高于部门平均工资的员工
-- 1)
select last_name
      ,department_id
      ,salary
      ,(
        select avg(salary)
        from employees e
        where e1.department_id = e.department_id
        group by department_id
        ) avg_sal
from employees e1
where salary > (
                select avg(salary)
                from employees e2
                where e1.department_id = e2.department_id
                group by department_id
                );

-- 2)
select a.last_name
      ,a.salary
      ,a.department_id
      ,b.avg_sal
from employees a,(
                  select department_id
                        ,avg(salary) avg_sal
                  from employees
                  group by department_id
                  ) b
where a.department_id = b.department_id
and a.salary > b.avg_sal;
```

## in、 exists

| 运算符 | 区别                                                         |
| ------ | ------------------------------------------------------------ |
| in     | 先执行子查询。<br />把外表和内表作hash join。<br />子查询得出的结果集记录较少，主查询中的表较大且又有索引时。<br />不对null进行处理。 |
| exists | 外层表为驱动表，先被访问。<br />对外表作loop，每次loop再对内表进行查询。<br />外层的主查询记录较少，子查询中的表较大且又有索引时。<br />为非关联子查询指定exists子句是不适当的，会产生笛卡乘积。 |

```sql
-- in 以下两个查询等价
select name 
from student 
where name in ('zhang','wang','li','zhao');

select name 
from student 
where name = 'zhang' 
  or name = 'li' 
  or name = 'wang' 
  or name= 'zhao';
```

```sql
-- exists 查询公司管理者的employee_id,last_name,job_id,department_id
select employee_id
      ,last_name
      ,job_id
      ,department_id
from employees outer
where exists(
    select *
    from employees
    where manager_id = outer.employee_id
);
```

```sql
-- not exists 查询departments表中不存在与employees表的部门的department_id,department_name
select department_id
      ,department_name
from departments d
where not exists(
    select 'x'  -- 'x'可以是任何
    from employees
    where department_id = d.department_id
);
```

```sql
-- 带in的关联子查询是多余的，因为in子句和子查询中相关的操作的功能是一样的。

-- 查找员工中在部门的员工姓名
select staff_name 
from staff_member 
where staff_id in (select staff_id 
                   from staff_func 
                   where staff_member.staff_id = staff_func.staff_id
                  );          
-- 修改
select staff_name 
from staff_member 
where staff_id in (select staff_id 
                   from staff_func
                  );
```

```sql
-- 为非关联子查询指定exists子句是不适当的，会产生笛卡乘积。 
select staff_name 
from staff_member 
where staff_id exists (select staff_id 
                       from staff_func
                       );
-- 改为：
select staff_name 
from staff_member 
where staff_id exists (select staff_id 
                       from staff_func 
                       where staff_member.staff_id = staff_func.staff_id
                      );
```

| 运算符     | 对比                                                         |
| ---------- | ------------------------------------------------------------ |
| not in     | 如果查询语句使用了not in，那么内外表都进行全表扫描，而没有用到索引。<br />尽量不要使用not in子句。使用minus 子句都比not in 子句快。 |
| not exists | not extsts 的子查询依然能用到表上的索引。<br />无论哪个表大，用not exists都比not in要快。 |

# 子查询中使用主查询的列

```sql
-- 查询员工中工资大于部门平均工资的员工last_name,salary和department_id
select last_name
      ,salary
      ,department_id
from employees outer
where salary > (
                select avg(salary)
                from employees
                where department_id = out.department_id
                );
```

```sql
-- 若employees表中的employee_id与job_history中employee_Id相同的数目不小于2，输出这些相同的员工的employee_id,job_id
select e.employee_id
      ,last_name
      ,e.job_id
from employees e
where 2 <= (
            select count(*)
            from job_hitoryy
            where employee_id = e.employee_id
            );
```

# 相关子查询

| 相关子查询 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 相关查询   | 在where子句中，可以使用子句中关系的别名。<br />而在from子句中，则不能使用在当前子句中的别名。 |
| 相关更新   | 相关子查询依据一个表中的数据更新/修改另一个表中的数据。      |
| 相关删除   | 相关子查询依据一个表中的数据删除另一个表中的数据。           |

```sql
--  相关更新
update emlpoyees e
set department_name = (
                       select department_name
                       from departments d
                       where e.departmet_id = d.department_id
                       );
```

```sql
--  删除employees表中，基于emp_history表皆有数据
delete from employees e
where (
       select employee_id
       from emp_history
       where employee_id = e.employee_id
       );  
```

# 成对比较 

- 成对比较：多列子查询、主查询与子查询返回的多个列进行比较。

```sql
-- 查询与141号或174号员工的manager_id,department_id相同的其他员工信息

-- 1)成对比较
select employee_id
      ,manager_id
      ,department_id
from employees
where (manager_id,department_id) in (
                                     select manager_id
                                           ,department_id
                                     from employees
                                     where employee_id in (141,174)
                                     )
and employee_id not in  (141,174);

-- 2)不成对比较
select employee_id
      ,manager_id
      ,department_id
from employees
where manager_id in (
                     select manager_id
                     from employees
                     where employee_id in (141,174)
                     )
  and department_id in (
                        select department_id
                        from employees
                        where employee_id in (141,174)
                        )
  and employee_id not in (141,174);
```
