# 注解方式注入

<table>
    <caption>DI依赖注入的方式</caption>
	<tbody>
		<tr>
			<td width="10%">@Value</td>
			<td width="90%">普通数据</td>
		</tr>
		<tr>
			<td>@Autowired</td>
			<td>类型注入，缺省</td>
		</tr>
		<tr>
			<td>@Qualifier</td>
			<td>名称注入，结合@Autowired</td>
		</tr>
		<tr>
			<td>@Resource</td>
			<td>类型/名称注入</td>
		</tr>
	</tbody>
</table>
# @Autowired 类型注入

## 注入的Bean类型实例的情况

- 同一类型的Bean实例只有一个时，直接将该Bean注入。

```java
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;

    @Autowired
    public void show(UserDao userDao) {
        System.out.println("show:" + userDao);
    }
}
```

```java
@Repository
public class UserDaoImpl implements UserDao{}
```

- 同一类型的Bean实例存在多个时：

<table>
    <thead>
        <tr>
            <th width="20%">注入数量</th>
            <th width="80%">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>只注入一个Bean实例</td>
            <td>当容器中同一类型的Bean实例有多个时，会尝试通过被注入属性的参数名称进行二次匹配。如果不存在匹配的beanName，则报错。</td>
        </tr>
        <tr>
            <td>注入多个Bean实例 
                <br>List
                <code>&lt;Bean实例类型&gt;</code>
            </td>
            <td>将通过类型匹配的Bean实例都注入到集合中。</td>
        </tr>
    </tbody>
</table>

```java
@Repository
public class UserDaoImpl implements UserDao{}
@Repository
public class UserDaoImpl2 implements UserDao{}
```

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDaoImpl;

    public UserDao getUserDao() {
        return userDaoImpl;
    }

    @Resource
    public void setUserDao(UserDao userDao) {
        this.userDaoImpl = userDao;
    }
}
```

```java
@Autowired
public void show(List<UserDao> userDaoList){
    userDaoList.forEach(dao -> System.out.println(dao));
}
```

## Setter方法与属性的注入顺序

- Setter方法注入的属性值会覆盖给属性赋值的。

```java
//最终username属性为tom。
@Component
public class UserDaoImpl implements UserDao {
    @Value("zjk")
    private String username;

    @Value("tom")
    public void setUsername(String username) {
        this.username = username;
    }
}
```

## 隐式注入

- 隐式注入：只有一个构造器的，其属性由Spring自动注入。

# @Qualifier 指定名称注入

```java
public @interface Qualifier {
    String value() default "";
}
```

- @Qualifier配合@Autowired根据名称注入Bean实例。

```java
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    @Qualifier("userDaoImpl")
    private UserDao userDao;

    public UserDao getUserDao() {
        return userDao;
    }

    @Autowired
    @Qualifier("userDaoImpl2")
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

# @Resource

- @Resource注解存在于 javax.annotation 包中，Spring对其进行解析。

- @Resource：不指定名称参数name时-->根据类型注入，指定名称参数name时-->根据名称注入。

- 当存在多个相同类型的Bean实例时，不会像@Autowired一样报错。  

```java
@Service
public class UserServiceImpl implements UserService {
    @Resource
    private UserDao userDao;

    public UserDao getUserDao() {
        return userDao;
    }

    @Resource(name="userDaoImpl2")
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

# @PropertySource

1. 加载properties文件到Spring容器。

```java
@Configuration
@PropertySource("classpath:jdbc.properties")
public class SpringConfig{}
```

2. `@Value`在载入properties文件后，SpEL表达式注入properties文件中的属性。

```java
@Component
public class UserDaoImpl implements UserDao {
    @Value("${jdbc.username}")
    private String username;

    public String getUsername() {
        return username;
    }
}
```