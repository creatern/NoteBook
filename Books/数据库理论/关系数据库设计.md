# 良构的关系模式

## 分解

- 对于信息重复问题（“非良构的”），一般来说，可能必须将表现出信息重复的模式分解为几个较小的模式。并非所有的模式分解都是有益的。
- 令R为关系模式，R<sub>1</sub>和R<sub>2</sub>构成R的分解，即在属性集上R=R<sub>1</sub>&cup;R<sub>2</sub>。如果用R<sub>1</sub>和R<sub>2</sub>去替代R时没有信息丢失，则称该分解为无损分解。如果关系r(R)的一个实例所包含的信息无法表示，而必须使用r<sub>1</sub>(R<sub>1</sub>)和r<sub>2</sub>(R<sub>2</sub>)的实例来表示，则为有损分解（拥有更多的元组，却拥有更少的信息）。

<table>
    <tr>
        <td width="30%">有损分解<br />（lossy decomposition）</td>
        <td width="30%">造成信息丢失的分解</td>
        <td width="40%">r&sub;&Pi;<sub>R<sub>1</sub></sub>(r) &bowtie;&Pi;<sub>R<sub>2</sub></sub>(r)</td>
    </tr>
    <tr>
        <td>无损分解<br />（lossless decomposition）</td>
        <td>没有信息丢失的分解</td>
        <td>&Pi;<sub>R<sub>1</sub></sub>(r) &bowtie;&Pi;<sub>R<sub>2</sub></sub>(r)=r</td>
    </tr>
</table>

## 规范化理论

- 规范化（normalization）：用于设计关系数据库的方法是使用一个通常称为规范化的过程。其目标是生成一组关系模式，允许我们存储信息并避免不必要的冗余，以及轻松地检索信息。

1. 确定一个给定的关系模式是否为“良构的”（范式）。通常使用函数依赖（functional dependency）来判断一个关系模式是否符合一种理想的范式。
2. 如果一个给定的关系模式不是“良构的”，则将其无损分解成许多较小的关系模式，使得每个模式都满足适当的范式。

# 函数依赖理论

## 函数依赖

- 合法实例（legal instance）：一个数据库对真实事件中的一组实体和联系进行建模，在真实世界中的数据通常存在各种约束（规则）。一个关系的满足所有这种真实世界约束的实例被称为该关系的合法实例；在一个数据库的合法实例中所有关系实例都是合法实例。
- 符号惯例：

1. 使用小写的希腊字母（&alpha;、&beta;等）来表示[属性集](./ER模型.md#属性集)；使用大写的罗马字母来表示关系模式。
2. 当属性集是一个超码时，可能使用K来表示它。使用术语“K是R的一个超码”。
3. 对关系使用小写的名称。
4. 使用符号`r(R)`来表示模式R是对于关系r而言的，或者说具有模式R的关系r。既是指关系，也是其模式。
5. 在函数依赖的考虑上，使用的是数学意义的“=”，而不是SQL的三值逻辑含义的“=”，即假设没有空值。

### 超码 &alpha;&rarr;&beta;

- 给定r(R)，R的一个子集K是r(R)的[超码](./关系模型.md#超码)的条件是，在r(R)的任意合法实例中，对于r的实例中的所有元组对t<sub>1</sub>和t<sub>2</sub>总满足：<code>若t<sub>1</sub>&ne;t<sub>2</sub>，则t<sub>1</sub>[K]&ne;t<sub>2</sub>[K]</code>。

- 对于关系模式r(R)，令&alpha;&sube;R且&beta;&sube;R

1. 给定r(R)的一个实例，如果对于该实例中的所有元组对t<sub>1</sub>和t<sub>2</sub>，使得若t<sub>1</sub>[&alpha;]=t<sub>2</sub>[&alpha;]，则t<sub>1</sub>[&beta;]=t<sub>2</sub>[&beta;]也成立，那么称该实例满足函数依赖&alpha;&rarr;&beta;（&alpha;函数决定&beta;）（functionally determine）。
2. 如果r(R)的每个合法实例都满足函数依赖&alpha;&rarr;&beta;，则称该函数依赖在模式r(R)上成立。
3. 如果函数依赖K&rarr;R在r(R)上成立，则K是r(R)的一个超码。

### 平凡的函数依赖

- 平凡的（trival）函数依赖：被所有关系满足的函数依赖。一般来说，如果&beta;&sube;&alpha;，则形如&alpha;&rarr;&beta;的函数依赖是平凡的。
- 一个关系的实例可能满足的某些函数依赖并不需要在该关系的模式上成立。

### 无损分解 &alpha;&rarr;&beta;

- R<sub>1</sub>和R<sub>2</sub>构成R的一个无损分解的条件是，以下函数依赖中至少有一个是在F<sup>+</sup>中的：

1. R<sub>1</sub>&cap;R<sub>2</sub>&rarr;R<sub>1</sub>
2. R<sub>1</sub>&cap;R<sub>2</sub>&rarr;R<sub>2</sub>

## 函数依赖集F的闭包 F<sup>+</sup>

- <span name="逻辑蕴涵">逻辑蕴涵</span>（logically imply）：给定一个模式上的函数依赖集F，可以证明其他特定的函数依赖在该模式上也是成立的，则称这种函数依赖被F所逻辑蕴涵。也就是说，给定一个模式r(R)，如果关系r(R)的每一个满足F的实例也满足f，则R上的函数依赖f被R上的函数依赖集F所逻辑蕴涵。

- 函数依赖集F的闭包（closure）：使用符号<code>F<sup>+</sup></code>来表示。能够从给定的集合F推导出的所有函数依赖的集合；或者说，F的闭包是被F所逻辑蕴涵的所有函数依赖的集合。F<sup>+</sup>包含F中所有的函数依赖。
- 给定在关系r(R)上成立的一个函数依赖集F，有可能推断出其他特定的函数依赖也一定在该关系上成立。

### 阿姆斯特朗公理

- 阿姆斯特朗公理（Armstrong's axitom）：用来寻找被逻辑蕴涵的函数依赖，可以找出对于给定F的F<sup>+</sup>中的全部依赖。

<table>
    <tr>
        <td wdith="30%">自反律（reflexivity rule）</td>
        <td width="70%">若&alpha;为一个属性集且&beta;&sube;&alpha;，则&alpha;&rarr;&beta;成立</td>
    </tr>
    <tr>
        <td>增补律（augmentation rule）</td>
        <td>若&alpha;&rarr;&beta;成立且&gamma;为一个属性集，则&gamma;&alpha;&rarr;&gamma;&beta;成立</td>
    </tr>
    <tr>
        <td>传递律（transitivity rule）</td>
        <td>若&alpha;&rarr;&beta;成立且&beta;&rarr;&gamma;成立，则&alpha;&rarr;&gamma;成立</td>
    </tr>
</table>

- 阿姆斯特朗公理是有效的，不会产生任何不正确的函数依赖。这些规则是完备的，对于一个给定的函数依赖集F，这些规则允许产生全部F<sup>+</sup>。
- 从阿姆斯特朗公理中可推导出以下有效的规则：

<table>
    <tr>
        <td wdith="35%">合并律（union rule）</td>
        <td width="65%">若&alpha;&rarr;&beta;成立且&alpha;&rarr;&gamma;成立，则&alpha;&rarr;&beta;&gamma;成立</td>
    </tr>
    <tr>
        <td>分解律（decomposition）</td>
        <td>若&alpha;&rarr;&beta;&gamma;成立，则&alpha;&rarr;&beta;成立且&alpha;&rarr;&gamma;成立</td>
    </tr>
    <tr>
        <td>伪传递律（preudotransitivity rule）</td>
        <td>若&alpha;&rarr;&beta;成立且&gamma;&beta;&rarr;&delta;成立，则&alpha;&gamma;&rarr;&delta;成立</td>
    </tr>
</table>

### 属性集的闭包 &alpha;<sup>+</sup>

- 令&alpha;为一个属性集，将函数依赖集F下被&alpha;决定的所有属性的集合称为F下&alpha;的闭包，即 &alpha;<sup>+</sup>。

### 无关属性

- 假设在一个关系模式上有一个函数依赖集F，每当用户在该关系上执行更新时，数据库系统必须确保此更新不破坏任何函数依赖。即，F中的所有函数依赖在新的数据库状态下仍然被满足。如果更新违背了集合F中的任意函数依赖，则系统必须回滚该更新。可以通过测试与给定函数依赖集具有相同闭包的一个简化集来减小花费在违反检测方面的开销。

- 无关属性（extraneous attribute）：去除函数依赖的一个属性而不改变该函数依赖的闭包，则称该属性是无关的。

- 如果去除的不是无关属性，则可能导致以下两种情况：

1. 从一个函数依赖的左侧删除一个属性，可以使其成为更强的约束。如，AB&rarr;CD，若删除了B，则可能得到更强的A&rarr;CD，因为A&rarr;CD逻辑蕴涵AB&rarr;CD。
2. 从一个函数依赖的右侧删除一个属性，可以使其成为更弱的约束。如，AB&rarr;CD，若CD删除了D属性，则可能仅使用AB&rarr;C无法推出AB&rarr;D。

- 对无关属性的形式化定义：给定一个函数依赖集F以及F中的函数依赖&alpha;&rarr;&beta;

1. 从左侧移除，如果A&isin;&alpha;并且F[逻辑蕴涵](#逻辑蕴涵)(F&minus;\{&alpha;&rarr;&beta;\})&cup;\{(&alpha;&minus;A)&rarr;&beta;\}，则属性A在&alpha;中是无关的。
2. 从右侧移除，如果A&isin;&beta;并且函数依赖集(F&minus;\{&alpha;&rarr;&beta;\})&cup;{&alpha;&rarr;(&beta;&minus;A)\}逻辑蕴涵F，则属性A在&beta;中是无关的。

- 检验一个属性是否无关的有效方式：令R为一个关系模式，且F是在R上成立的给定函数依赖集，考虑&alpha;&rarr;&beta;的一个属性A，根据以下两种情况来检验A是否无关

<table>
    <tr>
        <td width="20%">A&isin;&alpha;（左侧移除）</td>
        <td width="80%">令&gamma;=&alpha;&minus;{A}，检查&gamma;&rarr;&beta;是否可以由F推出。计算F下的闭包&gamma;<sup>+</sup>，如果&gamma;<sup>+</sup>包含&beta;中的所有属性，则A在&alpha;中是无关的</td>
    </tr>
    <tr>
        <td>A&isin;&beta;（右侧移除）</td>
        <td>F'=(F-{&alpha;&rarr;&beta;})&cup;{&alpha;&rarr;(&beta;&minus;A)}。计算F'下的闭包&alpha;<sup>+</sup>，如果&alpha;<sup>+</sup>包含A，则A在&beta;中是无关的</td>
    </tr>
</table>

### 正则覆盖 F<sub>c</sub>

- F的正则覆盖（canonical cover）F<sub>c</sub>是这样的一个依赖集，F逻辑蕴涵F<sub>c</sub>中的所有依赖，并且F<sub>c</sub>逻辑蕴涵F中的所有依赖。即，验证是否满足F<sub>c</sub>等价于验证是否满足F。此外F<sub>c</sub>必须具备如下性质：

1. F<sub>c</sub>中任何函数依赖都不包含无关属性。
2. F<sub>c</sub>中每个函数依赖的左侧都是唯一的。即，在F<sub>c</sub>中不存在&alpha;<sub>1</sub>=&alpha;<sub>2</sub>的情况下的&alpha;<sub>1</sub>&rarr;&beta;<sub>1</sub>且&alpha;<sub>2</sub>&rarr;&beta;<sub>2</sub>。

<pre>
<code>F<sub>c</sub>=F
repeat
	使用合并律将F<sub>c</sub>中任何形如&alpha;<sub>1</sub>&rarr;&beta;<sub>1</sub>和&alpha;<sub>1</sub>&rarr;&beta;<sub>2</sub>的依赖替换为&alpha;<sub>1</sub>&rarr;&beta;<sub>1</sub>&beta;<sub>2</sub>
	在F<sub>c</sub>中寻找一个函数依赖&alpha;&rarr;&beta;，该函数依赖要么在&alpha;中要么在&beta;中具有一个无关属性
	如果找到一个无关属性（使用F<Sub>c</Sub>来检验无关属性，而不是F），则将它从F<sub>c</sub>中的&alpha;&rarr;&beta;中删除
until(F<sub>c</sub>不再改变)</code>
</pre>

- 对于一个给定的F，可以存在多个可能的F<sub>c</sub>，且任何这样的F<sub>c</sub>都是同等可接受的。从某种意义上，F<sub>c</sub>是最小的，不含任何无关属性，并且合并了具有相同左侧的函数依赖。

### 保持依赖

- 令F为模式R上的一个依赖集，并令R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>n</sub>为R的一个分解。F对R<sub>i</sub>的限定是F<sup>+</sup>中只包含R<sub>i</sub>中属性的所有函数依赖的集合F<sub>i</sub>。
- 保持依赖的分解（dependency-preserving decomposition）：令F'=F<sub>1</sub>&cup;F<sub>2</sub>&cup;...&cup;F<sub>n</sub>，F'是模式R上的一个函数依赖集，通常F'&ne;F。如果F'<sup>+</sup>=F<sup>+</sup>，则F中的每个依赖都被F'逻辑蕴涵，且如果证明F'是被满足的，则也就证明了F是被满足的。称具有性质F'<sup>+</sup>=F<sup>+</sup>的分解为保持依赖的分解。

<pre><code>result=&alpha;
repeat
    for each 分解后的R<sub>i</sub>
        t=(result&cap;R<sub>1</sub>)<sup>+</sup>&cap;R<sub>i</sub>
        result=result &cup; t
until(result没有变化)</code></pre>

# 范式

## 1NF

- E-R模型允许实体集和联系集的属性具有某种程度的子结构；而在关系模型中，属性不具有任何子结构。
- 1NF（First Normal Form，第一范式）：如果一个域的元素被认为是不可再分的单元，则称这个域是原子的（atomic）。如果一个关系模式R的所有属性的域都是原子的，则称R属于1NF。
- 对于值为类似于标识号（“CS-1001”）之类的域，即，值可以拆分为多种结构的（CS-计算机科学系，1001-编号），只要数据库应用没有尝试将标识号拆开并将标识号的一部分解析为另一个意思，就仍然将该域视为原子的。

## 3NF

- 3NF（Third Normal Form，第三范式）允许存在左侧不是超码的特定的非平凡函数依赖。
- 关系模式R是关于函数依赖集F的第三范式的条件是，对于F<sup>+</sup>中所有形如&alpha;&rarr;&beta;的函数依赖（其中&alpha;&sube;R且&beta;&sube;R），以下至少有一项成立：

1. &alpha;&rarr;&beta;是一个平凡的函数依赖。
2. &alpha;是R的一个超码。
3. &beta;&rarr;&alpha;中的每个属性A都被包含于R的一个候选码中。（并不是要求单个候选码包含所有每个属性A，而是每个属性A被包含在某个候选码即可）

### BCNF 和 3NF 的比较

- 应用函数依赖进行数据库设计的目标是：

1. BCNF
2. 无损性
3. 依赖保持性

<table>
    <tr>
        <td width="10%" rowspan="2">BCNF</td>
        <td width="90%">BCNF是比3NF更严格的范式，任何满足BCNF的模式也满足3NF</td>
    </tr>
    <tr>
        <td>BCNF是非保持依赖的，不允许在没有连接的情况下实施这种函数依赖</td>
    </tr>
    <tr>
        <td rowspan="2">3NF</td>
        <td>总可以在不牺牲无损性或依赖保持性的前提下得到3NF的设计</td>
    </tr>
    <tr>
        <td>3NF可能不得不用空值来表示数据项之间的某些可能有意义的联系，并且存在信息重复的问题</td>
    </tr>
</table>

- 虽然在分解并非保持依赖的情况下，对函数依赖的检查可能会用到连接，但如果数据库支持物化视图（只有数据库系统支持物化视图上的主码约束或唯一性约束时），原则上可以通过将连接结果存储为物化视图的方式来降低成本。

### 3NF分解算法

<pre><code>令F<sub>c</sub>为F的一个正则覆盖;
i:=0;
for each F<sub>c</sub>中的函数依赖&alpha;&rarr;&beta;
    i:=i+1;
    R<sub>i</sub>:=&alpha;&beta;
if 没有一个模式R<sub>j</sub>(j=1,2,...,i)包含R的一个候选码 then
    i:=i+1;
    R<sub>i</sub>:=R的任一候选码;
/*可选地删除冗余关系*/
repeat
    if 任意模式R<sub>j</sub>包含于另一个模式R<sub>k</sub>中 then
        /*删除R<sub>j</sub>*/
        R<sub>j</sub>:=R<sub>i</sub>;
        i:=i-1;
until 不再有可以被删除的R<sub>j</sub>
return(R<sub>1</sub>,R<sub>2</sub>,...,R<sub>i</sub>)</code></pre>

### 3NF合成算法

- 3NF合成算法（3NF synthesis algorithm）通过为正则覆盖中的每个依赖显式地构造一个模式而确保了依赖的保持性，保证至少有一个模式包含了被分解模式的候选码。该算法接受一个依赖集合，并每次添加一个模式，而不是对初始的模式反复地分解。算法的结果不唯一（一个函数依赖集可能有多个正则覆盖），可能会分解一个属于3NF的模式，但其结果一定是属于3NF的。

## BCNF

- BCNF（Boyce-Codd Normal Form，Boyce-Codd范式）：消除了基于函数依赖能够发现的所有冗余，尽管可能存在其他类型的冗余。

- 关于函数依赖集F的关系模式R属于BCNF的条件是，对于F<sup>+</sup>中所有形如&alpha;&rarr;&beta;的函数依赖（其中&alpha;&sube;R且&beta;&sube;R），以下至少有一项成立：

1. &alpha;&rarr;&beta;是平凡的函数依赖（&beta;&sube;&alpha;）。
2. &alpha;是模式R的一个超码（&alpha;&rarr;R在R上成立）。

- 一个数据库设计属于BCNF的条件是，构成该设计的关系模式集中的每个模式都属于BCNF。

- 对于不属于BCNF的模式进行分解的通用规则，在分解一个不属于BCNF的模式时，可能会有一个或多个结果模式不属于BCNF，则继续进一步的分解，使得最终结果为一个BCNF模式的集合。令R为不属于BCNF的一个模式，那么存在至少一个非平凡的函数依赖&alpha;&rarr;&beta;，使得&alpha;不是R的超码。可以使用以下两个模式来取代R：

1. (&alpha;&cup;&beta;)
2. (R&minus;(&beta;&minus;&alpha;))

### BCNF检测

- 对于函数依赖集F的关系模式R是否满足BCNF的验证方法：

1. 对于一个函数依赖&alpha;&rarr;&beta;是否满足BCNF，验证&alpha;<sup>+</sup>是否包含R的所有属性（&alpha;是否为R的超码）
2. 对于一个关系模式R是否满足BCNF，验证F中的依赖是否满足BCNF即可，可以不去验证F<sup>+</sup>（该方法不适用于被分解的关系模式）
3. 为了检查R分解后的一个关系模式R<sub>i</sub>是否属于BCNF。对于R<sub>i</sub>中的每个子集&alpha;，检查&alpha;<sup>+</sup>（F下&alpha;的属性闭包）要么不包含R<sub>i</sub>&minus;&alpha;的任何属性，要么包含R<sub>i</sub>的所有属性。如果R<sub>i</sub>中的某个属性集&alpha;违背了该条件，则&alpha;&rarr;(&alpha;<sup>+</sup>&minus;&alpha;)&cap;R<sub>i</sub>。

### BCNF分解算法

<pre><code>result:={R};
done:=false;
while(not done) do
    if(在result中存在一个模式R<sub>i</sub>不属于BCNF)
        then begin
            令&alpha;&rarr;&beta;在R<sub>i</sub>上成立的一个非平凡函数依赖，使得&alpha;<sup>+</sup>并不包含R<sub>i</sub>，并且&alpha;&cap;&beta;=&empty;;
            result:=(result&minus;R<sub>i</sub>)&cup;(R<sub>i</sub>&minus;&beta;)&cup;(&alpha;, &beta;)
        end
    else done:=true;</code></pre>

## 4NF

### 多值依赖

- 多值依赖（multivalued dependency）并不排除特定元组的存在，而是要求具有特定形式的其他元组存在于关系中。

<table>
    <tr>
        <td>函数依赖</td>
        <td>相等产生依赖（equality-generating dependency）</td>
    </tr>
    <tr>
        <td>多值依赖</td>
        <td>元组产生依赖（tuple-generating dependency）</td>
    </tr>
</table>

- 令r(R)为一个关系模式，并令&alpha;&sube;R且&beta;&sube;R。多值依赖&alpha;&rarr;&rarr;&beta;在R上成立的条件是：在关系r(R)的任意合法实例中，对于r中满足t<sub>1</sub>[a]=t<sub>2</sub>的所有元组对t<sub>1</sub>和t<sub>2</sub>，在r中都存在元组t<sub>3</sub>和t<sub>4</sub>，使得：
    - t<sub>1</sub>[&alpha;]=t<sub>2</sub>[&alpha;]=t<sub>3</sub>[&alpha;]=t<sub>4</sub>[&alpha;]
    - t<sub>3</sub>[&beta;]=t<sub>1</sub>[&beta;]
    - t<sub>3</sub>[R&minus;&beta;]=t<sub>2</sub>[R&minus;&beta;]
    - t<sub>4</sub>[&beta;]=t<sub>2</sub>[&beta;]
    - t<sub>4</sub>[R&minus;&beta;]=t<sub>1</sub>[R&minus;&beta;]

<table>
    <tr>
        <th width="10%"></th>
        <th width="30%">&alpha;</th>
        <th width="30%">&beta;</th>
        <th width="30%">R&minus;&alpha;&minus;&beta;</th>
    </tr>
    <tr>
        <th>t<sub>1</sub></th>
        <td>a<sub>1</sub> ... a<sub>i</sub></td>
        <td>a<sub>i+1</sub> ... a<sub>j</sub></td>
        <td>a<sub>j+1</sub> ... a<sub>n</sub></td>
    </tr>
    <tr>
        <th>t<sub>2</sub></th>
        <td>a<sub>1</sub> ... a<sub>i</sub></td>
        <td>b<sub>i+1</sub> ... b<sub>j</sub></td>
        <td>b<sub>j+1</sub> ... b<sub>n</sub></td>
    </tr>
    <tr>
        <th>t<sub>3</sub></th>
        <td>a<sub>1</sub> ... a<sub>i</sub></td>
        <td>a<sub>i+1</sub> ... a<sub>j</sub></td>
        <td>b<sub>j+1</sub> ... b<sub>n</sub></td>
    </tr>
    <tr>
        <th>t<sub>4</sub></th>
        <td>a<sub>1</sub> ... a<sub>i</sub></td>
        <td>b<sub>i+1</sub> ... b<sub>j</sub></td>
        <td>a<sub>j+1</sub> ... a<sub>n</sub></td>
    </tr>
</table>

- 多值依赖&alpha;&rarr;&rarr;&beta;指的是&alpha;和&beta;之间的联系独立与&alpha;和R&minus;&beta;之间的联系。
- 平凡的多值依赖：若模式R上的所有关系都满足多值依赖&alpha;&rarr;&rarr;&beta;，则&alpha;&rarr;&rarr;&beta;在模式R上是平凡的多值依赖。因此，如果&beta;&sube;&alpha;或&beta;&cup;&alpha;=R，则&alpha;&rarr;&rarr;&beta;是平凡的。
- 若一个关系r不满足一个给定的多值依赖，则可以通过向r中增加元组的方式来构造出一个确实满足多值依赖的关系r'。
- 令D表示一个函数依赖和多值依赖的集合，D的闭包D<sup>+</sup>是由D逻辑蕴涵的所有函数依赖和多值依赖的集合。
- 根据多值依赖的定义，对于&alpha;, &beta;&sube;R，可推导出以下规则：

1. 若&alpha;&rarr;&beta;，则&alpha;&rarr;&rarr;&beta;。即，每一个函数依赖也是一个多值依赖。
2. 若&alpha;&rarr;&rarr;&beta;，则&alpha;&rarr;&rarr;R&minus;&alpha;&minus;&beta;。

### 4NF

- 4NF（Fourth Normal Form，第四范式）：利用多值依赖定义的范式，比BCNF更严格。每个4NF模式都属于BCNF，而存在不属于4NF的BCNF模式。
- 一个关系模式R是关于一个函数依赖和多值依赖的集合D的第四范式的条件是：对于D<sup>+</sup>中所有形如&alpha;&rarr;&rarr;&beta;的多值依赖（其中，&alpha;&sube;R且&beta;&sube;R），至少有以下之一成立：

1. &alpha;&rarr;&rarr;&beta;是一个平凡的多值依赖。
2. &alpha;是R的一个超码。

- 一个数据库设计属于4NF的条件是，构成该设计的关系模式集合中的每个模式都属于4NF。
- 令R为一个关系模式，并且令R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>n</sub>为R的一个分解。为了验证一个关系模式R<sub>i</sub>是否属于4NF，需要找到在每个R<sub>i</sub>上成立的多值依赖是什么。对于既有函数依赖又有多值依赖的集合D，D在R<sub>i</sub>上的限定是集合D<sub>i</sub>，包含：

1. D<sup>+</sup>中只含R<sub>i</sub>中属性的所有函数依赖。
2. 所有形如&alpha;&rarr;&rarr;&beta;&cap;R<sub>i</sub>的多值依赖，其中&alpha;&sube;R<sub>i</sub>且&alpha;&rarr;&rarr;&beta;属于D<sup>+</sup>。

### 4NF分解

<pre><code>result:={R};
done:=false;
计算D<sup>+</sup>;给定模式R<sub>i</sub>，令D<sub>i</sub>表示D<sup>+</sup>在R<sub>i</sub>上的限定
while(not done) do
    if (在result中存在一个模式R<sub>i</sub>;，它对于D<sub>i</sub>来说不属于4NF) 
      then begin
            令&alpha;&rarr;&rarr;&beta;为R<sub>i</sub>上的一个非平凡多值依赖
            使得&alpha;&rarr;R<sub>i</sub>不属于D<sub>i</sub>，并且&alpha;&cap;&beta;=&empty;
            result:=(result&minus;R<sub>i</sub>)&cup;(R<sub>i</sub>&minus;&beta;)&cup;(&alpha;, &beta;);
        end
    else done:=true;</code></pre>

- 令r(R)为一个关系模式，并令D为R上的函数依赖和多值依赖的集合。令r<sub>1</sub>(R<sub>1</sub>)和r<sub>2</sub>(R<sub>2</sub>)为R的一个分解。当且仅当下面的多值依赖中至少有一个属于D<sup>+</sup>，这个分解是R的无损分解：

1. R<sub>1</sub>&cap;R<sub>2</sub>&rarr;&rarr;R<sub>1</sub>
2. R<sub>1</sub>&cap;R<sub>2</sub>&rarr;&rarr;R<sub>2</sub>

#### 嵌入多值依赖

- 嵌入多值依赖（embedded multicalued dependency）：一个多值依赖有可能仅在给定模式的一个真子集上成立，而无法再该给定模式上表达这个多值依赖。

## PJNF

- PJNF（Project-Join Normal Form，投影-连接范式，第五范式）

### 连接依赖

- 连接依赖（join dependency）

## DKNF

- DKNF（Domain-Key Normal Form，域-码范式）

# 数据库设计过程

- 给定关系模式r(R)，并且对它进行规范化。可以采用以下几种方式来得到r(R)的模式：

1. r(R)可以是由E-R图向关系模式集转换时所生成的。
2. r(R)可以是包含所有有意义的属性的单个关系模式，然后由规范化过程将R分解成一些更小的模式。
3. r(R)可以是对关系即席设计的结果，然后检验它是否满足一种期望的范式。

## E-R模型和规范化

- 关系数据库的泛关系方法：从一种假设开始，假定存在单个关系模式包含所有有意义的属性，该单个模式定义了用户和应用程序如何与数据库进行交互。

## 属性和联系的密码

- 唯一角色假设（unique-role assumption）：数据库设计的一个期望的特性是唯一角色假设，意味着每个属性名在数据库中只有唯一的含义，也就是说，不能使用同一个属性名在不同的模式中表示不同的东西。
- 虽然对不相容的属性保持名称的区别是好的设计，但如果不同关系的属性具有相同的含义，则使用相同的属性名可能也是好的设计。
- 习惯上将主码属性列在前面。
- 在大型数据库模式中，联系集（以及由此导出的模式）常常以相关实体集名称的拼接来命名，可能带有连字符或下划线。
- 对于命名实体集，使用单数或复数形式都是可以的，只要在所有实体集之间都一致地使用该习惯即可（统一单数或统一复数形式）。

## 去规范化

- 去规范化（denormalization）：把一个规范化的模式变成非规范化的过程，设计者通过使用去规范化来调整系统的性能以支持响应时间苛刻的操作。（牺牲空间来换取时间）
- 大部分的数据库都提供了物化视图（将结果存储在数据库中的视图，且当视图中使用的关系被更新时也相应更新），以保持在使用规范化模式的基础上，通过物化视图获取类似于去规范化的效果。

## 交叉表

- 交叉表（crosstab）：一个属性的每一个值作为一列。

# 时态数据建模

## 时态数据

- 时态数据（temporal data）是具有关联的时间区间的数据，时间区间内的数据是有效的（valid）。
- 一种常用的方法是忽略时态的变化来设计整个数据库（E-R设计和关系设计），之后再决定对哪些关系进行时态变化跟踪。将开始时间和结束时间作为属性添加到每个这样的关系中来增加有效时间的信息。
- SQL:2011标准增加了对时态数据的支持，允许声明现有的属性来指定一个元组的有效时间区间。如`period of validtime(start, end)`。
- SQL:2011标准 `[start, end)`：时间区间左侧是闭的，右侧是开的。即元组在start时间是有效的，而在end时间内是无效的。这样，允许一个元组的开始时间与另一个元组的结束时间相同，而不会重叠。

## 时态函数依赖

- 时态函数依赖（temporal functional dependency）：在某个特定时刻成立的函数依赖。使用数据快照（snapshot）来表示特定时刻的数据值。
- 形式化地，时态函数依赖<img src="../../pictures/20240304185145.png" width="50"/>在关系模式r(R)上成立的条件是，对于r(R)的所有合法实例，r的所有快照都满足函数依赖&alpha;&rarr;&beta;。


## 时态主码

- 时态主码（temporal primary key）：一个时态关系的原始主码无法再唯一地标识一个元组。主码约束的时态版本必须确保：如果任何两个元组具有相同的主码值，则它们的有效时间区间不会重叠。
- 形式化地，如果r.A是关系r的时态主码，那么只要r中的两个元组t<sub>1</sub>和t<sub>2</sub>使得t<sub>1</sub>.A=t<sub>2</sub>.A，则它们的有效时间区间t<sub>1</sub>和t<sub>2</sub>必然不会重叠。
- SQL:2011标准同样支持时态主码。如使用扩展的`primary key(course_id, validtime without overlaps)`。

## 时态外码

- 时态外码（temporal foreign-key）不仅要确保引用关系中的每个元组（如r）在被引用关系中具有匹配的元组（如s），而且还要考虑它们的时间区间。但并不要求s中的匹配元组具有完全相同的时间间隔，不要求s中的单个元组具有包含r时间区间的时间区间；允许r元组的时间区间被一个或多个s元组覆盖。
- 形式化地，从r.A到s.B的时态外码约束确保了以下内容：对于r中具有有效时间区间（l, u）的每个元组t，在s中存在一个或多个元组构成的一个子集s<sub>t</sub>，使得每个元组s<sub>i</sub>&isin;s<sub>t</sub>都有s<sub>i</sub>.B&isin;t.A，并且保证所有s<sub>i</sub>的时间区间的并集包含(l, u)。
- SQL:2011还支持时态外码约束，允许随引用关系属性以及被引用关系属性一起指定一个周期（period）。
- 某些不直接支持实体主码约束的数据库允许使用变通的方法来强制实施此类约束。

## 时态连接

- 时态连接（temporal join）：在连接结果中一个元组的有效时间被定义为派生该元组的输入元组的有效时间的交集。如果有效时间并不相交，则从结果中丢弃该元组。
