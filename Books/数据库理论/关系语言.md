# 关系模型

## 术语

<table>
    <tr>
        <td width="30%">关系（relation）</td>
        <td width="15%">表（table）</td>
        <td width="55%">关系数据库由表的集合构成，每张表被赋予唯一的名称</td>
    </tr>
    <tr>
        <td>元组（tuple）</td>
        <td>行（row）</td>
        <td>表示表中的一组值之间的某种联系；关系是元组的集合</td>
    </tr>
    <tr>
        <td>属性（attribute）</td>
        <td>列（col）</td>
        <td></td>
    </tr>
    <tr>
        <td>关系实例（relation instance）</td>
        <td></td>
        <td>指代一个关系的特定实例，包含一组特定的行</td>
    </tr>
    <tr>
        <td>域（domain）</td>
        <td></td>
        <td>对于关系的每个属性都存在一个允许取值的集合（该属性的域）；对于所有关系r而言，r的所有属性的域都是原子的（atomic）</td>
    </tr>
    <tr>
        <td>空值（null value）</td>
        <td></td>
        <td>表示值未知或不存在</td>
    </tr>
</table>

<img src="../../pictures/20240225160444.png" width="500"/> 

## 模式与实例

<table>
    <tr>
        <td width="15%">数据库模式（databasse schema）</td>
        <td width="30%">数据库的逻辑设计</td>
        <td width="2%"></td>
        <td width="15%">关系模式（relation schema）</td>
        <td width="38%">类似于类型定义；一个关系模式由一个属性列表及各属性所对应的域组成</td>
    </tr>
    <tr>
        <td>数据库实例（database instance）</td>
        <td>在给定时刻数据库中数据的一个快照</td>
        <td></td>
        <td>关系实例（relation instance）</td>
        <td>类似于变量的值</td>
    </tr>
</table>

## 码 key

- <span name="码">码（key）</span>：一个元组的所有属性值必须能唯一标识元组，即必然存在超码。

<table>
    <tr>
        <td rowspan="2" width="25%"<span name="超码">超码（superkey）</span></td>
        <td width="75%">一个或多个属性的集合，通过这些属性的组合可以在一个关系中唯一地标识出一个元组</td>
    </tr>
    <tr>
        <td>形式化地，令R表示关系r模式中的属性集合，R的一个子集K是r的一个超码。若元组t<sub>1</sub>和t<sub>2</sub>在r中，且t<sub>1</sub>≠t<sub>2</sub>，则t<sub>1</sub>K≠t<sub>2</sub>.K。</td>
    </tr>
    <tr>
        <td>候选码（candidate key）</td>
        <td>超码中可能存在无关紧要的属性，如果K是一个超码，则K的任意超集也是超码。而，如果K的任意真子集都不是超码，则K称为候选码（最小超码）</td>
    </tr>
    <tr>
        <td>主码（primary key）</td>
        <td>数据库设计者选中来作为在一个关系中区分不同元组的候选码，即主码约束（primary key constraint）</td>
    </tr>
</table>

<img src="../../pictures/数据库系统概念-码key.drawio.svg" width="350"/>  

### 外码

- 外码约束（foreign-key constraint）：从r<sub>1</sub>关系的A属性（集）到r<sub>2</sub>关系的主码B的外码约束表明，在任何数据库实例中，r<sub>1</sub>中每个元组对A的取值也必须是r<sub>2</sub>中某个元组对B的取值。A属性集被称为从r<sub>1</sub>引用r<sub>2</sub>的外码（foreign key）。r<sub>1</sub>被称为此外码约束的引用关系（referencing  key），r<sub>2</sub>被称为被引用关系（referenced  key）。
- 被引用属性集必须是被引用关系的主码，而更泛化的情况是引用完整性约束，放松了该要求。
- 引用完整性约束（referential integrity constraint）：要求引用关系中的任意元组在指定属性上出现的取值也必然出现在被引用关系中至少一个元组的指定属性上。当前大部分的数据库只实现了被引用属性集必须是被引用关系的主码的外码约束。

## 模式图

- 模式图（schema diagram）：一个带有主码和外码约束的数据库模式可以用模式图来表示。
- 主码属性用下划线标注，外码约束用从引用关系的外码属性指向被引用关系的主码属性的箭头来表示。

<img src="../../pictures/数据库系统概念-模式图.drawio.svg" width="400"/> 

## 关系查询语言

- 查询语言（query language）：用户用来从数据库中请求获取信息的语言，比标准的程序设计语言的层次更高。查询语言分为命令式、函数式以及声明式的。

<table>
    <tr>
        <td width="30%">命令式查询语言<br/>（imperative query language）</td>
        <td width="70%">用户指导系统在数据库上执行特定的运算序列以计算出所需的结果；这类语言通常由一个状态变量在计算的过程中被更新</td>
    </tr>
    <tr>
        <td rowspan="2">函数式查询语言<br/>（functional query language）</td>
        <td>计算被表示为对函数的求值，这些函数可以在数据库中的数据上运行或在其他函数给出的结果上运行</td>
    </tr>
    <tr>
        <td>函数没有副作用，不更新程序的状态</td>
    </tr>
    <tr>
        <td>声明式查询语言<br/>（declarative query language）</td>
        <td>用户只需描述所需信息，而不用给出获取该信息的具体步骤序列或函数调用，所需的信息通常使用某种形式的数学逻辑来描述</td>
    </tr>
</table>

# SQL

<table>
    <tr>
        <td width="35%">数据定义语言<br/>（Data-Definition Language，DDL）</td>
        <td width="65%">SQL DDL提供定义关系模式、删除关系以及修改关系模式的命令</td>
    </tr>
    <tr>
        <td>数据操纵语言<br/>（Data-Manipulation Language，DML）</td>
        <td>SQL DML提供从数据库中查询信息以及在数据库中插入元组、删除元组、修改元组的能力</td>
    </tr>
</table>

## DDL

<table>
    <tr>
        <td width="30%">完整性（integrity）</td>
        <td width="70%">SQL DDL包括定义完整性约束的命令，保存在数据库中的数据必须满足所定义的完整性约束。破坏完整性约束的更新是不允许的。</td>
    </tr>
    <tr>
        <td>视图定义（view definition）</td>
        <td>SQL DDL包括定义视图的命令</td>
    </tr>
    <tr>
        <td>事务控制（transaction control）</td>
        <td>SQL包括定义事务的开始点和结束点的命令</td>
    </tr>
    <tr>
        <td>嵌入式SQL（embedded SQL）</td>
        <td></td>
    </tr>
    <tr>
        <td>动态SQL（dynamic SQL）</td>
        <td></td>
    </tr>
    <tr>
        <td>授权（authorization）</td>
        <td>SQL DDL包括定义对更新和视图的访问权限的命令</td>
    </tr>
</table>

- SQL DDL不仅能够定义关系的集合，还能够定义有关每个关系的信息，包括每个更新的模式、每个属性的取值类型、完整性约束、为每个更新维护的索引集合、每个关系的安全性和权限信息、每个关系在磁盘上的物理存储结构。

### 基本类型

<table>
    <tr>
        <td width="20%" rowspan="2">char(n)</td>
        <td width="80%">具有用户指定长度n的固定长度的字符串（character）</td>
    </tr>
    <tr>
        <td>char类型会在字符串的内容长度未达到n时，追加适当的空格来补全以达到n长度；且在比较两个不同长度的char类型时，会在短值char后追加空格以使得长度相等</td>
    </tr>
    <tr>
        <td>varchar(n)</td>
        <td>具有用户指定的最大长度n的可变长度的字符串（character varying）</td>
    </tr>
    <tr>
        <td>int</td>
        <td>整数（依赖于机器的整数的有限子集），integer</td>
    </tr>
    <tr>
        <td>smallint</td>
        <td>小整数（依赖于机器的整数类型的子集）</td>
    </tr>
    <tr>
        <td>numeric(p,d)</td>
        <td>具有用户指定精度的定点数。该数有p为数学（加上一位符号位），并且小数点右边有p位中的d位数字</td>
    </tr>
    <tr>
        <td>real</td>
        <td rowspan="2">浮点数与双精度浮点数，精度依赖于机器</td>
    </tr>
    <tr>
        <td>double precision</td>
    </tr>
    <tr>
        <td>float(n)</td>
        <td>精度至少为n位数字的浮点数</td>
    </tr>
</table>

### 基本模式定义

# 形式化关系查询语言

## 关系代数

- 关系代数由一组运算组成，这些运算接受一个或两个关系作为输入（一元运算、二元运算），并生成一个新的关系作为它们的结果。

### 选择运算 &sigma;

- 选择运算（select）选出满足给定谓词的元组，&sigma;表示选择。
1. 谓词写在&sigma;的下标中，作为参数的关系写在&sigma;后的括号内。

2. 允许在选择谓词中使用=、&ne;、&lt;、&le;、&gt;、&ge;来进行比较。

3. 可以通过使用连接词and（&and;）、or（&or;）、not（&not;）将几个谓词组合成一个更长的谓词。
- &sigma;<sub>dep_name="Physics" &and; salary&ge;8500</sub>(instructor)：查询教师表（instructor）中属于物理系（dep_name="Physics"）且工资（salary）大于等于8500的教师。

### 投影运算 &Pi;

- 投影运算（project）是一种一元运算，返回它的参数关系，但滤掉了特定的属性。

- &Pi;表示投影，将希望出现在结果中的属性作为&Pi;的下标列出。

- &Pi;<sub>id,name,salary</sub>(instructor)：查询教师表（intructor）生成属性包括id、name、salary的投影。

### 关系运算的复合

- 关系代数表达式（relational-algebra expression）：由于关系代数运算的结果与其输入具有相同的类型（关系），因此，可将关系代数运算复合为一个关系代数表达式。

- &Pi;<sub>id,name,salary</sub>(&sigma;<sub>dep_name="Physics" &and; salary&ge;8500</sub>(instructor))：查询教师表（instructor）中属于物理系（dep_name="Physics"）且工资（salary）大于等于8500的教师，之后生成属性包括id、name、salary的投影。

### 笛卡尔积 &times;

- 笛卡尔积运算（Cartesian-product）：允许结合来自任意两个关系的信息，将关系r<sub>1</sub>和r<sub>2</sub>的笛卡尔积记为 r<sub>1</sub> &times; r<sub>2</sub>。r<sub>1</sub> &times; r<sub>2</sub> 并非将来自r<sub>1</sub>和r<sub>2</sub>的元组生成元组对 (t<sub>1</sub>, t<sub>2</sub>) ，而是将t<sub>1</sub>和t<sub>2</sub>拼接为单个元组。

- 存在关系r<sub>1</sub>(R<sub>1</sub>)和r<sub>2</sub>(R<sub>2</sub>)，r = r<sub>1</sub> &times; r<sub>2</sub> ： 生成的r关系包含所有满足以下条件的元组t，对于t存在r<sub>1</sub>中的一个元组t<sub>1</sub>和r<sub>2</sub>中的一个元组t<Sub>2</sub>，满足t和t<sub>1</sub>在R<Sub>1</sub>中的属性上取值相同，并且t和t<sub>2</sub>在R<Sub>2</sub>中的属性上取值相同。

### 连接运算 &bowtie;

- 连接运算（join），&bowtie;表示自然连接。若存在关系r(R)和s(S)，并令&theta;为R&cup;S模式的属性上的一个谓词，则 r&bowtie;<sub>&theta;</sub>s  = &sigma;<sub>&theta;</sub>(r &times; s)。

### 集合运算

- 进行集合运算的两个关系必须是相容关系（compatible）：
1. 元数（arity）相同，即关系的属性数量相同。
2. 当属性有关联的类型时，对于每个i，两个输入关系的第i个属性的类型必须相同。

<table>
    <tr>
        <td width="30%">并运算（union）</td>
        <td width="70%">∪</td>
    </tr>
    <tr>
        <td>交运算（intersection）</td>
        <td>∩</td>
    </tr>
    <tr>
        <td>集差运算（set-difference）</td>
        <td>−</td>
    </tr>
</table>

### 赋值运算 &larr;

- 赋值运算（assignment）使用&larr;来表示，将查询结果赋值给一个临时关系，而不会向用户展示任何关系，但可以作为一个顺序程序的一部分来编写。对于关系代数查询，必须始终赋值给临时的关系变量，向永久关系赋值会造成数据库修改。

- r &larr; r<sub>1</sub> ： 将关系r<sub>1</sub>赋值给关系r。

### 更名运算 &rho;

- 更名运算（rename）使用&rho;来表示，为关系或关系表达式的结果命名。

- &rho;<sub>x</sub>(E) ： 返回以x命名的表达式E的结果。

- &Pi;<sub>id,name,salary</sub>(&sigma;<sub>i.salary &ge; w.salary</sub>(&rho;<sub>i</sub>(instructor) &times; &sigma;<sub>w.id = 1201</sub>(&rho;<sub>w</sub>(instructor)))) ：查询教师表（instructor）中工资（salary）大于等于编号（id）为1201的教师的所有教师的id、name、salary。

- 位置标记（`$1, $2 ...`）：使用位置标记来隐式地命名关系的属性，即`$1`引用第一个属性，以此类推。

### 等价查询

- 数据库系统中的查询优化器通常会查看表达式所计算的结果是什么，并找到计算该结果的高效方式，而不是严格按照查询中指定的步骤序列来执行。

## 元组关系演算

- 元组关系演算（tuple relational calculus）是非过程化的（nonprocedural）查询语言，描述了所需信息，而不用给出用于获得该信息的具体过程。

- 元组关系演算表达式：`{t|P(t)}` 表示使谓词P为真的所有元组t的集合，其中P是一个公式（formula），公式中可以出现多个元组变量。`t[A]`表示元组t在属性A上的取值。<code>t&isin;r</code>表示元组t在关系r中。

- 自由变量：如果元组变量不被&exist;或&forall;量化，则称为自由变量。与之相对的是受限变量。

- 元组关系演算的公式是由原子（atom）构成的，原子（也是公式）可以具有如下形式之一：

<table>
    <tr>
        <td width="15%">s∈r</td>
        <td width="85%">s是元组变量，且r是关系。不允许使用∉</td>
    </tr>
    <tr>
        <td>s[x]θu[y]</td>
        <td>s和u是元组变量，x是定义s的关系模式中的一个属性，y是定义u的关系模式的一个属性，且θ是一个比较运算符</td>
    </tr>
    <tr>
        <td>s[x]θc</td>
        <td>s是元组变量，x是定义s的关系模式中的一个属性，θ是一个比较运算符，且c是属性x所属域的一个常量</td>
    </tr>
</table>

- 元组关系演算表达式的等价性：
1. P<sub>1</sub>&and;P<sub>2</sub> 等价于 &not;(&not;(P<sub>1</sub>) &or; &not;(P<sub>2</sub>))

2. &forall;t&isin;r(P<sub>1</sub>(t)) 等价于 &not;&exist;t&isin;r(&not;P<sub>1</sub>(t))

3. P<sub>1</sub> &rArr; P<sub>2</sub> 等价于 &not;(P<sub>1</sub>)&or;P<sub>2</sub>
- 表达式的安全性：若出现在表达式`{t|P(t)}`结果中的所有值均来自于`dom(P)`，则认为表达式`{t|P(t)}`是安全的（保证具有有限的结果）。其中，P的域用`dom(P)`来表示，是P所引用的所有值的集合，即在P中显示出现的所有值、或者其名称出现在P中的一个或多个关系中出现的所有值的集合。

<table>
    <tr>
        <td width="40%">dom(t∈instructor∧t[salary]>8000) </td>
        <td width="60%">安全。包括8000以及出现在instructor关系的任意元组的任意属性的所有值的集合</td>
    </tr>
    <tr>
        <td>dom(¬(t∈instructor))</td>
        <td>不安全。包括出现在instructor中的所有值的集合；但是，可能有一个不在instructor中的元组t，其包含的值没有在instructor中出现</td>
    </tr>
</table>

## 域关系演算

- 域关系演算（domain relational calculus）使用从属性域中取指的域（domain）变量，而不是对整个元组的值。

> 域关系演算是QBE语言的基础

- 域关系演算表达式： <code>{&lt;x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>&gt;|P(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>)}</code> 。其中，x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>代表域变量，P代表由原子构成的公式。

<table>
    <tr>
        <td width="20%"><x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>>∈r</td>
        <td width="80%">r是在n个属性上的关系，且x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>是域变量或域常量</td>
    </tr>
    <tr>
        <td>xθy</td>
        <td>x和y是域变量，且θ是比较运算符</td>
    </tr>
    <tr>
        <td>xθc</td>
        <td>x是域变量，θ是比较运算法，且c是在x作为域变量的那个属性域中的常量</td>
    </tr>
</table>

- 符号简写： <code>&exist;a,b,c(P(a,b,c))</code> 等价于 <code>&exist;a(&exist;b(&exist;c(P(a,b,c))))</code>

<table>
    <tr>
        <td width="45%">{<i,n,d,s>|∃n,d,s(<i,n,d,s>∈instructor∧s>80000)}</td>
        <td width="55%">查询工资在80000元以上的教师的ID</td>
    </tr>
    <tr>
        <td>{<i>|∈n,d,tc(<i,n,d,tc>)∃student ∧ <br />∀ci,ti,dn,cr(<ci,ti,dn,cr>∈course∧dn="Biology"<br />⇒<br />∃si,se,y,g(<i,ci,si,se,y,g>∈takes))}</td>
        <td>查询选修了生物系中开设的全部课程的学生</td>
    </tr>
</table>

- 表达式的安全性：
1. 在表达式的元组中出现的所有值均是来自dom(P)的值。
2. 对于每个形如<code>&exist;x(P<sub>1</sub>(x))</code>的“存在”子公式而言，当且仅当在dom(P<sub>1</sub>)中存在一个值x使P<sub>1</sub>(x)为真的情况下，该公式为真。
3. 对于每个形如<code>&forall;x(P<sub>1</sub>(x))</code>的“对于所有的”子公式而言，当且仅当P<sub>1</sub>(x)对于来自dom(P<sub>1</sub>)的所有值均为真的情况下，该公式为真。

## 纯关系查询语言的表达能力

- 以下三种是等价的：
1. 基本关系代数
2. 限制在安全表达式范围内的元组关系演算
3. 限制在安全表达式范围内的域关系演算
