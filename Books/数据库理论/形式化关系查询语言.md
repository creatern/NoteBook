# 关系代数

- 关系代数由一组运算组成，这些运算接受一个或两个关系作为输入（一元运算、二元运算），并生成一个新的关系作为它们的结果。

## 选择运算 &sigma;

- 选择运算（select）选出满足给定谓词的元组，&sigma;表示选择。

1. 谓词写在&sigma;的下标中，作为参数的关系写在&sigma;后的括号内。

2. 允许在选择谓词中使用=、&ne;、&lt;、&le;、&gt;、&ge;来进行比较。

3. 可以通过使用连接词and（&and;）、or（&or;）、not（&not;）将几个谓词组合成一个更长的谓词。

- &sigma;<sub>dep_name="Physics" &and; salary&ge;8500</sub>(instructor)：查询教师表（instructor）中属于物理系（dep_name="Physics"）且工资（salary）大于等于8500的教师。

## 投影运算 &Pi;

- 投影运算（project）是一种一元运算，返回它的参数关系，但滤掉了特定的属性。

- &Pi;表示投影，将希望出现在结果中的属性作为&Pi;的下标列出。

- &Pi;<sub>id,name,salary</sub>(instructor)：查询教师表（intructor）生成属性包括id、name、salary的投影。

## 关系运算的复合

- 关系代数表达式（relational-algebra expression）：由于关系代数运算的结果与其输入具有相同的类型（关系），因此，可将关系代数运算复合为一个关系代数表达式。

- &Pi;<sub>id,name,salary</sub>(&sigma;<sub>dep_name="Physics" &and; salary&ge;8500</sub>(instructor))：查询教师表（instructor）中属于物理系（dep_name="Physics"）且工资（salary）大于等于8500的教师，之后生成属性包括id、name、salary的投影。

## 笛卡尔积 &times;

- 笛卡尔积运算（Cartesian-product）：允许结合来自任意两个关系的信息，将关系r<sub>1</sub>和r<sub>2</sub>的笛卡尔积记为 r<sub>1</sub> &times; r<sub>2</sub>。r<sub>1</sub> &times; r<sub>2</sub> 并非将来自r<sub>1</sub>和r<sub>2</sub>的元组生成元组对 (t<sub>1</sub>, t<sub>2</sub>) ，而是将t<sub>1</sub>和t<sub>2</sub>拼接为单个元组。

- 存在关系r<sub>1</sub>(R<sub>1</sub>)和r<sub>2</sub>(R<sub>2</sub>)，r = r<sub>1</sub> &times; r<sub>2</sub> ： 生成的r关系包含所有满足以下条件的元组t，对于t存在r<sub>1</sub>中的一个元组t<sub>1</sub>和r<sub>2</sub>中的一个元组t<Sub>2</sub>，满足t和t<sub>1</sub>在R<Sub>1</sub>中的属性上取值相同，并且t和t<sub>2</sub>在R<Sub>2</sub>中的属性上取值相同。

## 连接运算 &bowtie;

- 连接运算（join），&bowtie;表示自然连接。若存在关系r(R)和s(S)，并令&theta;为R&cup;S模式的属性上的一个谓词，则 r&bowtie;<sub>&theta;</sub>s  = &sigma;<sub>&theta;</sub>(r &times; s)。

## 集合运算

- 进行集合运算的两个关系必须是相容关系（compatible）：

1. 元数（arity）相同，即关系的属性数量相同。
2. 当属性有关联的类型时，对于每个i，两个输入关系的第i个属性的类型必须相同。

<table>
    <tr>
        <td width="30%">并运算（union）</td>
        <td width="70%">∪</td>
    </tr>
    <tr>
        <td>交运算（intersection）</td>
        <td>∩</td>
    </tr>
    <tr>
        <td>集差运算（set-difference）</td>
        <td>−</td>
    </tr>
</table>

## 赋值运算 &larr;

- 赋值运算（assignment）使用&larr;来表示，将查询结果赋值给一个临时关系，而不会向用户展示任何关系，但可以作为一个顺序程序的一部分来编写。对于关系代数查询，必须始终赋值给临时的关系变量，向永久关系赋值会造成数据库修改。

- r &larr; r<sub>1</sub> ： 将关系r<sub>1</sub>赋值给关系r。

## 更名运算 &rho;

- 更名运算（rename）使用&rho;来表示，为关系或关系表达式的结果命名。

- &rho;<sub>x</sub>(E) ： 返回以x命名的表达式E的结果。

- &Pi;<sub>id,name,salary</sub>(&sigma;<sub>i.salary &ge; w.salary</sub>(&rho;<sub>i</sub>(instructor) &times; &sigma;<sub>w.id = 1201</sub>(&rho;<sub>w</sub>(instructor)))) ：查询教师表（instructor）中工资（salary）大于等于编号（id）为1201的教师的所有教师的id、name、salary。

- 位置标记（`$1, $2 ...`）：使用位置标记来隐式地命名关系的属性，即`$1`引用第一个属性，以此类推。

## 等价查询

- 数据库系统中的查询优化器通常会查看表达式所计算的结果是什么，并找到计算该结果的高效方式，而不是严格按照查询中指定的步骤序列来执行。

# 元组关系演算

- 元组关系演算（tuple relational calculus）是非过程化的（nonprocedural）查询语言，描述了所需信息，而不用给出用于获得该信息的具体过程。

- 元组关系演算表达式：`{t|P(t)}` 表示使谓词P为真的所有元组t的集合，其中P是一个公式（formula），公式中可以出现多个元组变量。`t[A]`表示元组t在属性A上的取值。<code>t&isin;r</code>表示元组t在关系r中。

- 自由变量：如果元组变量不被&exist;或&forall;量化，则称为自由变量。与之相对的是受限变量。

- 元组关系演算的公式是由原子（atom）构成的，原子（也是公式）可以具有如下形式之一：

<table>
    <tr>
        <td width="15%">s∈r</td>
        <td width="85%">s是元组变量，且r是关系。不允许使用∉</td>
    </tr>
    <tr>
        <td>s[x]θu[y]</td>
        <td>s和u是元组变量，x是定义s的关系模式中的一个属性，y是定义u的关系模式的一个属性，且θ是一个比较运算符</td>
    </tr>
    <tr>
        <td>s[x]θc</td>
        <td>s是元组变量，x是定义s的关系模式中的一个属性，θ是一个比较运算符，且c是属性x所属域的一个常量</td>
    </tr>
</table>

- 元组关系演算表达式的等价性：

1. P<sub>1</sub>&and;P<sub>2</sub> 等价于 &not;(&not;(P<sub>1</sub>) &or; &not;(P<sub>2</sub>))

2. &forall;t&isin;r(P<sub>1</sub>(t)) 等价于 &not;&exist;t&isin;r(&not;P<sub>1</sub>(t))

3. P<sub>1</sub> &rArr; P<sub>2</sub> 等价于 &not;(P<sub>1</sub>)&or;P<sub>2</sub>

- 表达式的安全性：若出现在表达式`{t|P(t)}`结果中的所有值均来自于`dom(P)`，则认为表达式`{t|P(t)}`是安全的（保证具有有限的结果）。其中，P的域用`dom(P)`来表示，是P所引用的所有值的集合，即在P中显示出现的所有值、或者其名称出现在P中的一个或多个关系中出现的所有值的集合。

<table>
    <tr>
        <td width="40%">dom(t∈instructor∧t[salary]>8000) </td>
        <td width="60%">安全。包括8000以及出现在instructor关系的任意元组的任意属性的所有值的集合</td>
    </tr>
    <tr>
        <td>dom(¬(t∈instructor))</td>
        <td>不安全。包括出现在instructor中的所有值的集合；但是，可能有一个不在instructor中的元组t，其包含的值没有在instructor中出现</td>
    </tr>
</table>

# 域关系演算

- 域关系演算（domain relational calculus）使用从属性域中取指的域（domain）变量，而不是对整个元组的值。

> 域关系演算是QBE语言的基础

- 域关系演算表达式： <code>{&lt;x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>&gt;|P(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>)}</code> 。其中，x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>代表域变量，P代表由原子构成的公式。

<table>
    <tr>
        <td width="20%"><x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>>∈r</td>
        <td width="80%">r是在n个属性上的关系，且x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>是域变量或域常量</td>
    </tr>
    <tr>
        <td>xθy</td>
        <td>x和y是域变量，且θ是比较运算符</td>
    </tr>
    <tr>
        <td>xθc</td>
        <td>x是域变量，θ是比较运算法，且c是在x作为域变量的那个属性域中的常量</td>
    </tr>
</table>

- 符号简写： <code>&exist;a,b,c(P(a,b,c))</code> 等价于 <code>&exist;a(&exist;b(&exist;c(P(a,b,c))))</code>

<table>
    <tr>
        <td width="50%">{&lt;i,n,d,s&gt;|&exist;n,d,s(&lt;i,n,d,s&gt;&in;instructor&and;s&gt;80000)}</td>
        <td width="50%">查询工资在80000元以上的教师的ID</td>
    </tr>
    <tr>
        <td>{&lt;i&gt;|&in;n,d,tc(&lt;i,n,d,tc&gt;)&exist;student &and; <br />&forall;ci,ti,dn,cr(&lt;ci,ti,dn,cr&gt;&in;course&and;dn="Biology"<br />&rArr;<br />&exist;si,se,y,g(&lt;i,ci,si,se,y,g&gt;&in;takes))}</td>
        <td>查询选修了生物系中开设的全部课程的学生</td>
    </tr>
</table>

- 表达式的安全性：

1. 在表达式的元组中出现的所有值均是来自dom(P)的值。
2. 对于每个形如<code>&exist;x(P<sub>1</sub>(x))</code>的“存在”子公式而言，当且仅当在dom(P<sub>1</sub>)中存在一个值x使P<sub>1</sub>(x)为真的情况下，该公式为真。
3. 对于每个形如<code>&forall;x(P<sub>1</sub>(x))</code>的“对于所有的”子公式而言，当且仅当P<sub>1</sub>(x)对于来自dom(P<sub>1</sub>)的所有值均为真的情况下，该公式为真。

# 纯关系查询语言的表达能力

- 以下三种是等价的：

1. 基本关系代数
2. 限制在安全表达式范围内的元组关系演算
3. 限制在安全表达式范围内的域关系演算
