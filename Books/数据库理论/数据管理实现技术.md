# 存储管理

- 尽管数据库系统提供了数据的高级视图，但最终必须将数据以位的形式存储在一个或多个存储设备上。数据库系统将数据提取到主存中进行处理，并将数据写回存储器以保持持久性。数据也被复制到磁带和其他备份设备以进行归档存储。

## [物理存储介质](../Computer/Memory.md)

## 记录

- 一个数据库被映射为多个不同的文件，这些文件由底层的操作系统来维护，并永久地驻留在磁盘（块）上。
- 一个文件在逻辑上被组织为记录的一个序列，每个文件还从逻辑上被分成定长的存储单元，也就是<b>块（block）</b>。块是存储分配和数据传输的单位，大多数数据库默认使用4KB至8KB的块规模。
- 一个块可能包含多条记录，要求每条记录被完全地包含在单个块中；一个块所包含的确切的数据集合是由所使用的物理数据组织形式来决定的。
- 对于一些可能比块要大的大数据项，通过存储其指针来处理。

### 定长记录

- 在关系数据库中，不同关系的元组通常具有不同的规模。把数据库映射到文件的一种方法是使用多个文件（定长记录文件），在任意给定的文件中只存储一种固定长度的记录（<b>定长记录</b>）。另一种方法是构造自己的文件（变长记录文件）。

1. 一个块只分配它能完整容纳的最多记录的数目，余下的字节不使用。以此来避免有的记录被分为两个块来存储，而导致对一条记录需要进行两次访问。
2. 在文件的开头分配特定数量的字节作为<b>文件头（file header）</b>。文件头中包含有关文件的各种信息，其中存储着的包括内容被删除的第一条记录的地址（指针，pointer），并在这个被删除内容的记录位置存放下一个被删除内容的记录的地址，从而形成了一条<b>自由链表（free list）</b>。在插入一条新记录时，使用文件头所指向的记录，并改变文件头的指针以指向下一条可用（被删除内容的）记录，如果没有可用的空间，就把新记录加到文件末尾。

<img src="../../pictures/数据库系统概念-定长记录文件.drawio.svg" width="450"/> 

### 变长记录

#### 变长记录

- <b>变长记录（variable-length record）</b>通常是为了处理变长域（字符串等）、包含重复域的记录类型（数组、多重集合等）、文件中多种记录类型的出现等。

- 具有变长属性的记录通常包含两个部分：

1. 首先是带有定长信息的初始部分。定长属性以正常形式存储；而变长属性在记录的初始部分中被表示为一个`(偏移量, 长度)`对，其中偏移量表示在记录中该属性的数据开始的部分，而长度表示变长属性的字节长度。
2. 紧接着变长属性的内容，被分配存储这些属性的值所需的字节数。多个变长属性的值是连续存储的。

<img src="../../pictures/数据库系统概念-变长记录文件.drawio.svg" width="700"/> 

- <b>空位图（null bitmap）</b>表示记录的哪个属性是空值，对于取空值的属性根本不存储数据（值、偏移量、长度）。该方式以提取记录属性的额外工作为代价来节省存储空间。

#### 分槽的页结构

- <b>分槽的页结构（slotted-page structure）</b>一般用于在块中组织记录。每个块的开始处有一个块头，其中包含以下信息：

1. 块中记录项的数量。
2. 块中自由空间的末尾处。
3. 一个由包含每条记录的位置和大小的项组成的数组。

<img src="../../pictures/数据库系统概念-分槽的页结构.drawio.svg" width="700"/> 

- 实际记录从块的末尾处开始在块中连续分配空间。块中的自由空间是连续的，位于块头数组的最后一项和第一条记录之间。如果插入一条记录，在自由空间的尾部给这条记录分配空间，并且将包含这条记录的大小和位置的项加到块头中。
- 如果一条记录被删除，其所占用的空间被释放，并且它的项被置为`deleted`；此外，块中位于被删除记录之前的记录将被移动（防止在块的内部存在碎片空间），使得由删除而产生的自由空间能被重新使用，并且所有自由空间仍然位于块头数组的最后一项和第一条记录之间；块头中的自由空间末尾指针也要适当修改。（移动记录的代价并不太高，因为块的大小是有限的）
- 分槽的页结构要求没有指针直接指向记录，而是让指针必须执行块头中记有记录实际位置的项（间接指针），从而允许移动记录。

### 大对象存储

- SQL支持二进制大对象数据类型（blob）、字符大对象数据类型（clob）。大部分的数据库限制一条记录的规模不能大于一个块的规模（以简化缓冲区管理），但允许记录在逻辑上包含大对象。一个指向大对象的（逻辑）指针被存储到包含该大对象的记录中。

- 大对象（large object）可以以文件形式存储在被数据库管理的一个文件系统区域中，或者作为文件结构（<a href="#B+树文件组织">B<sup>+</sup>树文件组织</a>）存储在数据库中并被数据库管理。

<table>
    <tr>
        <td rowspan="2" width="10%">存储在数据库内部</td>
        <td width="90%">存储在数据库中的大对象可以选用B<sup>+</sup>树文件组织来表示。B<sup>+</sup>树文件组织允许读取一个完整的对象、或对象中指定的字节范围，以及插入和删除对象的一部分</td>
    </tr>
    <tr>
        <td>通过数据库接口访问对象的效率是一个需要关注的问题；在数据库中存储大对象会导致数据库转储规模的大量增长</td>
    </tr>
    <tr>
        <td rowspan="3">存储在数据库之外</td>
        <td>应用程序可以将文件名（文件系统中的路径）存储为数据库中记录的一个属性。</td>
    </tr>
    <tr>
        <td>如果存储在数据库外部的文件并不存在（例如被删除），则会导致某种形式的外码约束冲突。此外，数据库授权不适用于存储在文件系统中的数据</td>
    </tr>
    <tr>
        <td>一些数据库支持文件系统和数据库的集成，以此满足约束（例如阻止文件的错误删除），并且确保访问授权被执行；文件能够通过文件系统接口和数据库SQL接口进行访问。Oracle通过SecureFiles和数据库文件系统特性来支持这种集成</td>
    </tr>
</table>

## 文件组织

### 堆文件组织

- 在<b>堆文件组织（heap file organization）</b>中，记录可以存储在对应于一个关系的文件中的任何位置。记录一旦被放在特定位置，通常不会被移动。
- 大多数数据库使用一种名为<b>自由空间图（free-space map）</b>的数据结构，以便跟踪具有自由空间来存储记录的块。

1. 自由空间图通常被表示成一个数组，对关系的每个块，该数组都包含一个项。每个项表示一个比例f，即在块中至少有比例为f的空间是自由的。数组（自由空间图）被存储在文件中，在需要时数组被读进内存。
2. 只要记录被插入、删除或者改变大小，如果占用比例的变化足以影响项的值，那么项必须在自由空间图中被更新。
3. 为了找到一个可以存储给定大小的新记录的块，数据库可以扫描自由空间图以找到一个具有足够空间的块来存储那条记录。如果不存在那样的块，则将给关系分配一个新块。
4. 自由空间图被周期性地写入磁盘，因此，磁盘上的自由空间图可能是过时的。当数据库启动时，可能会得到关于自由空间的过时数据。

- 为了进一步加速定位具有足够自由空间的块的任务，可以创建<b>二级自由空间图</b>。二级自由空间图的每个项表示主自由空间图的n个项，每个项存储了其对应的主自由空间图中n个项之内的最大值。

<img src="../../pictures/数据库系统概念-自由空间图.drawio.svg" width="600"/> 

### 顺序文件组织

- <b>顺序文件组织（sequential file organization）</b>是为了高效处理按某个搜索码的顺序排序的记录而设计的。<b>搜索码（serch key）</b>是任意的属性或者属性的集合。

1. 为了能够按搜索码的顺序快速检索记录，通过指针把记录链接起来。每条记录的指针执行按搜索码顺序排列的下一条记录。
2. 为了最大限度地减少顺序文件处理中的块访问数量，按搜索码的顺序或者尽可能地接近搜索码的顺序物理地存储记录。

- 顺序文件组织允许记录按排列的顺序读取，但在插入和删除时维护记录的物理顺序是困难的。因此，对于插入操作，应用如下两条规则：

1. 在文件中定位按搜索码顺序位于待插入记录之前的那条记录。
2. 如果在这条记录所在块中有一条自由的记录（删除后留下来的空间），就在这里插入新的记录。否则，将新的记录插入一个<b>溢出块（overflow block）</b>中。无论哪种情况，都要调整指针，使其能按搜索码顺序把记录链接在一起。

- 如果需要存储在溢出块中的记录相对较少，以上方式会工作地很好。但一段时间后，搜索码顺序和物理顺序之间的相似性最终可能会完全丧失，顺序处理将变得十分低效。此时，文件应该被<b>重组（reorganized）</b>，使得它再次在物理上按顺序存放。重组的代价很高，并且必须在系统负载低的时候执行。

<img src="../../pictures/数据库系统概念-顺序文件组织.drawio.svg" width="500"/> 

- 在插入很少发生的极端情况下，使文件在物理上总保持有序是可能的，这种情况下也就不需要指针域了。

### 多表聚簇文件组织

- <b>多表聚簇文件组织（multitable clustering file organization）</b>是一种在每个块中存储两个或更多关系的相关记录的文件组织形式。
- <b>聚簇码（cluster key）</b>是一种属性，定义了哪些记录被存储在一起。通常是用于连接的属性作为聚簇码。
- 尽管多表聚簇文件组织可以加快特定的连接查询，但也会导致对其他类型的查询的处理变慢。

### B<sup>+</sup>树文件组织

- <span name="B+树文件组织">B<sup>+</sup>树文件组织</span>（B<sup>+</sup>-tree file organization）

### 散列文件组织

- 散列文件组织（hashing file organization）

##  数据字典存储

- <b>元数据（metadata）</b>是“关于数据”的数据，例如关系的模式等。关系模式和关于关系的其他元数据存储在<b>数据字典（data dictionary）（系统目录，system catalog）</b>。

1. 所有这些元数据信息组成了一个微型数据库（数据字典），通常使用<b>数据库关系</b>来存储元数据。
2. 数据字典通常存储为非规范的形式，以便快速存取。
3. 系统元数据被频繁访问，所以大多数数据库将其从数据库读入内存数据结构中，作为数据库启动的一部分来完成的。

<b>元数据包括：</b>

- 系统必须存储的信息类型：

1. 关系的名称
2. 每个关系中属性的名称
3. 属性的域和长度
4. 在数据库上定义的视图的名称，以及这些视图的定义
5. 完整性约束

- 很多系统为用户保存了下列数据：

1. 用户的名称、用户的缺省模式、用于认证用户的密码或其他信息
2. 关于每个用户的授权信息

- 数据库可能还会存储关于关系和属性的统计数据和描述数据
- 数据字典也可能记录关系的存储组织（堆、顺序、散列等），以及每个关系的存储位置：

1. 如果关系被存储在操作系统文件中，数据字典将会记录包含每个关系的单个文件（或多个文件）的名称
2. 如果数据库把所有关系存储在单个文件中，数据字典可能将包含每个关系的记录的块记在例如链表那样的数据结构中

- 数据库有必要存储关于每个关系的每个索引的信息：

1. 索引的名称
2. 被索引的关系的名称
3. 在其上定义索引的属性
4. 构造的索引的类型

## 数据库缓冲区

### 缓冲区

- 在多数数据库中，数据库数据仍主要存放在磁盘上，并且这些数据必须被存入内存以进行读取或更新；更新过的数据块必须随后写回磁盘。
- 数据库系统的一个主要目标就是减少在磁盘和内存之间传输的块数量，以最大化要访问的块已经在主存中的概率（命中）。
- <b>缓冲区（buffer）</b>是主存中用于存储磁盘块的拷贝的那部分。每个块总有一份拷贝存放在磁盘上，但是磁盘上的拷贝可能比缓冲区的版本旧。
- <b>缓冲区管理器（buffer manager）</b>是用于管理缓冲区空间分配的子系统。

### 缓冲区管理器

1. 当数据库系统中的程序需要磁盘上的块时，它向缓冲区管理器发出请求（调用）。
2. 如果这个块已经在缓冲区中，则缓冲区管理器将这个块在主存中的地址传给请求者。
3. 如果这个块不在缓冲区中，则缓冲区管理器首先在缓冲区中为这个块分配空间。
4. 如果空间不足，可能会把一些其他块移出主存（缓冲区替换策略），为这个新块腾出空间。被移出的块仅当它在最近一次写回磁盘后被修改过才被写回磁盘。
5. 然后，缓冲区管理器把被请求的块从磁盘读入缓冲区，并将这个块在主存中的地址传给请求者。

- 缓冲区管理器的内部动作对发出磁盘块请求的程序是透明的。

#### <a href="#缓冲区替换策略">缓冲区替换策略</a>

#### 钉住块 pin

- 多个进程能从缓冲区中的一个块中读取数据，要求每个进程在访问数据前执行<b>钉住（pin）</b>操作，并在完成访问后执行<b>解除钉住（pin）</b>操作。直到所有对块执行了钉住操作的进程都解除钉住后，该块才能被移出。

1. 在一个进程从缓冲块中读取数据之前，进程在该块上执行钉住（pin）操作，缓冲区管理器绝不会移出一个被钉住的块。
2. 当进程完成数据读取后，会执行解除钉住（unpin）操作，允许该块在必要时被移出。

- 通过对每个缓冲块维护<b>钉住计数（pin count）</b>，对每个钉住操作增加该计数，且对每个解除钉住操作减少该计数。仅当一个页面的钉住次数为0时，其才能被移出。

#### 共享排他锁

- 数据库缓冲区管理器允许进程获取缓冲区上的<b>共享排他锁</b>。由缓冲区管理区提供的封锁系统允许数据库进程在访问一个块之前，以共享模式或者排他模式封锁该缓冲块，并且在访问完成之后释放封锁。
- 用于封锁的规则保证了缓冲区访问的安全。确保当另外的进程在读块时，该块不能被更新；反过来说，当另外的进程正在更新块的时候，此块不能被读取。

1. 任意数量的进程可以在一个块上同时拥有共享锁。
2. 每次只允许一个进程获得排他锁，并且当一个进程执有排他锁时，其他进程不能执有此块上的共享锁。因此，只有当没有其他进程在缓冲块上执有封锁的时候，排他锁才能被授予。
3. 如果一个进程请求块上的排他锁，但此块已经以共享或者排他模式被封锁，那么在早期封锁被释放之前，该请求一直处于等待状态。
4. 如果一个进程请求块上的共享锁，而且此块没有被封锁或者已经被共享锁封锁，则此锁可以被授予；但是，如果另一个进程持有该块的排他锁，则共享锁只有在排他锁被释放后才能被授予。

- 按如下方式获得并释放封锁:

1. 在一个块上执行任何操作之前，进程必须钉住这个块。随后获得封锁，且必须在对块解除钉住之前释放封锁。
2. 在从缓冲块读数据之前，进程必须获取此块上的共享锁。当完成数据读取时，进程必须释放此锁。
3. 在更新缓存块内容之前，进程必须获取此块上的排他锁；该锁必须在更新完成后释放。

#### 块写出

- 仅当另一个块需要缓冲空间时才写出一个块是可能的。但是，更期待于不用等到需要缓冲空间时，而是在产生这种需求之前，就写出更新过的块。之后，当需要缓冲区中的空间时，一个已经被写出过的块可以被移出，只要它当前没有被钉住。
- 大多数数据库有一个进程，其可以连续监测更新过的块并将块写回磁盘。为了数据库系统能够从崩溃中恢复，有必要限制一个块能被写回磁盘的时间。例如，大多数恢复系统要求，当块上正在进行更新时，该块不能被写回磁盘。为了满足这个要求，希望将块写回磁盘的进程必须获取块上的共享锁。

#### 块的强制写出

- 某些情况下，需要把块写回磁盘，以确保磁盘上的数据处于一致性状态；这样的写操作称为<b>块的强制写出（forced output）</b>。
- 主存的内容乃至缓冲区的内容会在崩溃时丢失，然而磁盘上的数据（通常）在崩溃时得以幸免。将强制写出与日志机制一起使用，以确保当执行更新的事务被提交时，有足够的数据写回磁盘，从而保证事务的更新不会丢失。

### <span name="缓冲区替换策略">缓冲区替换策略</span>

- 当缓冲区中没有剩余空间时，一个块必须被移出（evicted)，即在新块读入缓冲区之前，必须把一个块从缓冲区中去除。而<b>缓冲区替换策略</b>的目标是减少对磁盘的访问。

#### LRU 最近最少使用策略

- 多数操作系统使用<b>LRU（Least Recently Used，最近最少使用）</b>策略，即最近最少访问的块被写回磁盘，并从缓冲区中移走。
- 数据库系统能够比操作系统更准确地预测未来的访问模式。用户对数据库系统的请求包括若干步，通过查看执行用户请求的操作所需的每一步，数据库系统通常可以预先确定哪些将是需要的。因此，对于数据库而言，尽管绝大多数数据库系统都使用LRU策略，但LRU策略有其缺点。

#### 立即丢弃策略

- <b>立即丢弃策略（toss-immediate）</b>：一旦关系中的一个元组被处理过，那么就不再需要这个元组了。因此，如果一个块中的最后一个元组被处理完毕，就应该命令缓冲区管理器释放这个块所占用的空间。

#### MRU 最近最常使用策略

- 如果必须从缓冲区中移出一个块，<b>MRU（Most Recently Used，最近最常使用）策略</b>将选择最近最常使用的块（正在被使用的块则不能被替换）。要使MRU策略正确工作，系统必须把当前正在处理的块钉住。在块中最后一个元组处理完毕后，这个块就被解除钉住，并成为最近最常使用的块。

#### 影响缓冲区替换策略的其他因素

- 除了使用系统所拥有的关于被处理的请求的知识，缓冲区管理器还可以使用有关一个请求将访问特定关系的概率的统计信息。

1. 缓冲区管理器应尽量不把数据字典从主存中移出，除非有其他因素决定了它非这样做不可。
2. 对文件索引的访问可能比文件本身更频繁，所以除非迫不得已，缓冲区管理器一般不会把索引块从主存中移出。

- 除了块被再次访问的时间以外，缓冲区管理器所使用的块替换策略还受其他因素的影响。如果系统并发地处理来自多个用户的请求，<q>并发控制子系统</q>可能需要延迟某些请求，以保证数据库的一致性。如果缓冲区管理器从并发控制子系统获得了关于哪些请求被延迟的信息，它就可以使用这些信息来改变它的块替换策略。具体地说，活跃的（非延迟的）请求所需要的块可以保留在缓冲区中、以牺牲被延迟的请求所需要的块为代价。
- <q>崩溃-恢复子系统</q>对块替换施加了严格的约束。如果一个块被修改过，则不允许缓冲区管理器将这个块在缓冲区中的新版本写回磁盘；因为这将破坏旧的版本。取而代之的做法是，块管理器在写出块之前，必须向崩溃一恢复子系统寻求许可。崩溃一恢复子系统在允许缓冲区管理器写出所需的块之前，可能要求将另一些特定的块强制写出

### 写操作的重排序与恢复

- 数据库缓冲区允许在内存中执行写操作，并在以后将其输出到磁盘，输出的顺序可能与执行写出的顺序不同。文件系统也经常对写操作重新排序。但是，这种重新排序可能会导致在发生系统崩溃时磁盘上的数据不一致。

1. 早期的文件系统必须在系统重新启动时执行文件系统一致性检查，以确保数据结构是一致的。如果不一致，就必须采取额外的措施把它们恢复到一致状态。这些检查会导致崩溃后系统重启的长时间延迟，随着磁盘系统容量的增加，这种延迟会变得更长。
2. 如果文件系统按精心选择的顺序更新元数据，那么在许多情况下，它可以避免不一致的问题。但是这样做意味着诸如磁盘臂调度之类的优化无法完成，从而影响更新的效率。
3. 如果有可用的非易失性写缓冲区，可以用它来对非易失性RAM执行顺序的写操作，然后在写人磁盘时再重新排序。

- 现代文件系统分配一个磁盘（日志磁盘，log  disk），用于按执行顺序存储写操作的日志。对于每次写操作，日志都包含待写入的块的编号和要写入的数据，日志的顺序与执行写操作的顺序一致。在执行写操作后，记录将从日志磁盘中删除。

1. 对日志磁盘的所有访问都是顺序的，基本上消除了寻道时间，并且多个连续的块可以一次性写入，使得写人日志磁盘的速度比随机写入快好几倍。
2. 和以前一样，数据还必须写到它们在磁盘上的实际位置，但是对实际位置的写操作可以之后完成；<u>可以对写操作进行重新排序，以最小化磁盘臂的移动</u>。
3. 如果在对实际磁盘位置的某些写操作完成之前系统崩溃，当系统恢复时，它会读取日志磁盘，以找到尚未完成的那些写操作，然后执行这些操作。

- 支持上述日志磁盘的文件系统称为<a href="../Linux/FileSystem.md#日志文件系统">日志文件系统（journaling file system）</a>。即使没有单独的日志避盘，也可以通过将数据和日志保存在同一个磁盘上来实现日志文件系统。但这样做会以更低性能为代价来降低资金成本。

1. 大多数现代文件系统在写入诸如文件分配信息那样的文件系统元数据时实现日志并使用日志磁盘。
2. 日志文件系统允许快速重启，无须进行此类文件系统的一致性检查。
3. 应用程序执行的写操作通常不会被写入日志磁盘。相反，数据库系统实现了自己的日志形式，以确保在发生故障时，即使对写操作进行了重新排序，也可以安全地恢复出数据库的内容。

# <span name="索引">索引</span>

## 索引概述

- 索引（index）对数据库中查询的高效处理至关重要，如果没有索引，每个查询最终都将读取它所使用的每个关系的全部内容。


1. 索引是记录域（查找码、搜索码）取值到记录的物理地址间的映射关系。搜索码是用于在文件中查找记录的属性或属性集，可以不是主键。索引建立在搜索码上，如果一个文件有多个索引，那么该文件就有多个搜索码。
2. 索引加快了数据查询速度，却减慢了数据更新速度（数据更新时需要维护索引），索引本身还会占用一定的存储空间。

<table>
    <caption>基本的索引类型</caption>
    <tr>
        <td width="25%">顺序索引（ordered index）</td>
        <td width="75%">基于值的顺序排序</td>
    </tr>
    <tr>
        <td>散列索引（hash index）</td>
        <td>基于将值平均分布到若干桶中，一个值所属的桶是由一个散列函数（hash function）决定的</td>
    </tr>
</table>

<table>
    <caption>对每种索引技术的评价都必须基于以下元素</caption>
    <tr>
        <td width="25%">访问类型（access type）</td>
        <td width="75%">能有效支持的访问类型，包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录</td>
    </tr>
    <tr>
        <td>访问时间（access time）</td>
        <td>在查询中使用该技术找到一个特定数据项或数据项集所花费的时间</td>
    </tr>
    <tr>
        <td>插入时间（insertion time）</td>
        <td>插入一个新数据项所花费的时间，包括找到插入者这个数据项的正确位置所花费的时间，以及更新索引结构所花费的时间</td>
    </tr>
    <tr>
        <td>删除时间（deletion time）</td>
        <td>删除一个数据项所花费的时间，包括找到待删除项所花费的时间，以及更新索引结构所花费的时间</td>
    </tr>
    <tr>
        <td>空间开销（space overhead）</td>
        <td>索引结构所占用的额外空间。如果这种额外空间的规模适度，则通常值得牺牲一定的空间来换取性能的提升</td>
    </tr>
</table>

## 顺序索引

### 顺序索引和索引文件机制

-  顺序索引（ordered index）或索引文件机制（有序索引技术，Ordered Index）依照排好的顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。

1. 索引文件机制利用索引文件（Index File）实现记录域（查找码、排序域）到记录物理地址间的映射关系。通常情况下，数据库会采用顺序文件结构，此时，使用顺序索引能极大地提升查询的效率。
2. 索引文件由索引记录（Index Record）组成，每个记录中记载着一个索引项（Index Entry），索引项记录了某个特定的查找码值和具有该值的数据文件记录的物理地址。
3. 一个数据库文件上可以建立多个索引文件，数据文件和每个索引文件都根据各自的查找码有序地组织为顺序文件。

- 索引项（index entry）或索引记录（ index record）由一个搜索码值和指针构成，这些指针指向具有该搜索码值的一条或多条记录。指向一条记录的指针由磁盘块的标识和标识出块内记录的磁盘块内偏移量所组成。

### 聚集索引和非聚集索引

- 对数据文件和它的一个特定的索引文件，如果数据文件中数据记录的排序顺序与索引文件中索引项的排序顺序一致，就称该索引文件为聚集索引（clustering index）或主索引（primary index）；否则为非聚集索引（non-clustering index）或辅助索引（secondary index）。也就是，<q>聚集的（clustered）</q>与<q>非聚集的（nonclustered）</q>。（主索引可以建立在任何索引码上，不仅仅是主码）
- 一个基本表上除了可以建立一个聚集索引外，还可以建立多个非聚集索引。

> 对于主索引和辅索引的另一种解释：
>
> 1. 在数据文件的主码属性集上建立的索引被称为主索引（Primary Key），而在其他属性集上建立的索引被称为辅索引（Secondary Key）。
> 2. 在RDBMS中，通常按照主码值的顺序将元组有序存储在数据文件中，并以主码作为查找码建立索引文件（即是主索引，也是聚集索引）。

#### 顺序索引文件

- 索引顺序文件（index-sequence file）是按照某个查找码组织为顺序文件，且建有聚集索引的数据文件；是针对既需要顺序处理整个文件又需要随机访问单条记录的应用而设计的。假定所有文件都按照某种搜索码顺序存储，而在这种搜索码上有聚集索引的文件被称为索引顺序文件。

### 稠密索引和稀疏索引

- 如果数据文件中的每个搜索码值在索引文件中都对应一个索引记录（或索引项），则该索引被称为稠密索引（Dense Index）；如果只有一部分对应，则称为稀疏索引（Sparse Index）。

1. 在稠密聚集索引中，索引记录包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针。具有相同搜索码值的其余记录会顺序地存储在第一条记录之后，且由于是聚集索引，记录还会根据相同的搜索码值进行排序。
2. 在稠密非聚集索引中，索引必须存储指向具有相同搜索码值的所有记录的指针列表。

- 稀疏索引只会为一部分搜索码值建立索引项，只有索引是聚集索引时才会使用稀疏索引。基于此，为了定位一条记录，需要进行如下步骤：

1. 找到所具有的最大搜索码值小于或等于所记录的搜索码值的索引项。
2. 从该索引项指向的记录开始，沿着文件的指针查找（因此需要索引项和数据项的次序一致，也就是聚集索引），直到找到索引记录为止。

- 稀疏索引占用的空间较小，所需的插入和删除时的维护开销也较小。

### 唯一索引

- 唯一索引可以确保索引列不包含重复的值。在多列唯一索引的情况下，可以确保索引列中的每个值的组合都是唯一的。

### 多级索引

- 单层索引（线性索引）根据键值在索引文件中顺序排列，组织成一堆线性结构，每个索引项直接指向数据文件的数据记录。（之前的索引都是单层索引）
- 多级索引（ multilevel indices）是具有两级或两级以上的索引，是对索引文件中的索引项本身再建立一级或多级的稀疏索引。像对待其他任何顺序文件一样对待索引（索引项总是有序的），并在原始的索引上（内层索引）构造一个稀疏的外层索引。
- 系统设计者必须在存取时间和空间开销之间进行权衡。尽管具体应用具体分析，但为每个块建立一个索引项的稀疏索引（多级索引）是一种较好的折中方案。因为处理一个数据库查询的开销主要是把块从磁盘读到主存中所花费的时间来决定，而一旦将块放入主存中，扫描整个块的时间就是可以忽略的。通过使用多级索引（在索引项上建立的稀疏索引），可以定位到包含所要查找的记录的块。只要记录不在一个溢出块中，就能使块访问次数最小，同时能保持索引的规模（以及空间开销）尽可能小。

### 索引的更新算法

- 在文件中的记录被更新的情况下，其搜索码值受更新影响的任何索引也必须更新。如果一个文件有多个索引，则无论何时修改该文件，都必须更新每个索引。
- 对于索引的更新算法，多级索引和单级索引的本质是一样的。多级索引只不过是在内层索引执行完更新算法后，再将内层索引当作数据文件，继续让外层索引执行更新算法，以此向外一级级地更新。

#### 插入

- 系统首先用出现在待插入记录中的搜索码值执行查找，系统根据索引是稠密的还是稀疏的来进行下一步操作。
- 稠密索引：

1. 如果该搜索码值并未出现在索引中，系统就在索引中适当的位置插入带有该搜索码值的索引项。否则执行如下操作。
2. 如果索引项存储的是指向具有相同搜索码值的所有记录的指针，那么系统就在索引项中增加一个指向新记录的指针。
3. 否则，索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，系统把待插入的记录放到具有相同搜索码值的其他记录之后。

- 稀疏索引：假设索引为每个块保存一个索引项。

1. 如果系统创建了一个新的块，那么它会将出现在新块中的第一个搜索码值（按照搜索码的次序）插入索引中。
2. 如果这条新插入的记录具有它所在块中的最小搜索值，那么系统就更新指向该块的索引项；否则，系统对索引不做任何改动。

#### 删除

- 为了删除一条记录，系统首先要找到待删除的记录。系统下一步要执行的操作取决于索引是稠密的还是稀疏的。
- 稠密索引：

1. 如果待删除的记录是具有这个特定搜索码值的唯一的一条记录，则系统就从索引中删除相应的索引项。否则执行如下操作。
2. 如果索引项存储的是指向具有相同搜索码值的所有记录的指针，那么系统就从索引项中删除指向待删除记录的指针。
3. 否则，索引项存储一个仅指向具有该搜索码值的第一条记录的指针。在这种情况下，如果待删除的记录是具有该搜索码值的第一条记录，系统就更新索引项，使其指向下一条记录

- 稀疏索引:

1. 如果索引中并不包含具有待删除记录搜索码值的索引项，则索引不必做任何改动。否则系统执行如下操作。
2. 如果待删除记录是具有该搜索码值的唯一记录，则系统用下一个搜索码值（按搜索码次序）的索引记录来替换相应的索引记录。如果下一个搜索码值已经有了一个索引项，则删除而不是替换该索引项。
3. 否则，如果该搜索码值的索引项指向待删除的记录，系统就更新索引项，使其指向具有相同搜索码值的下一条记录。

### 辅助索引

- 辅助索引（非聚集索引）必须是稠密的，对每个搜索码值都有一个索引项，并且对文件中的每条记录都有一个指针。

1. 聚集索引可以是稀疏的，只存储部分搜索码值，通过顺序访问文件的一部分，总可以找到带有中间搜索码值的记录。但如果辅助索引只存储部分搜索码值，则具有中间搜索码值的记录可能存在于文件中的任何位置，通常只能通过扫描整个文件才能找到它们。
2. 也就是说，如果辅助索引的搜索码不是候选码，则仅仅指向具有每个搜索码值的第一条记录是不够的。具有相同搜索码值的其余记录可能分布在文件的任何位置（非顺序存放），因为记录是按聚集索引用搜索码而不是按辅助索引的搜索码次序存放的。因此，辅助索引必须包含指向所有记录的指针。

- 非唯一性搜索码（nonunique search key）：如果一种关系可以有不止一条包含相同搜索码值的记录（即两条或多条记录对于索引算性可以具有相同的值），则搜索码被称为非唯一性搜索码（nonunique search key）。
- 在非唯一性搜索码上实现辅助索引的一种方式如下，与主索引的情况不同，这种辅助索引中的指针并不直接指向记录。相反，索引中的每个指针都指向一个桶（附加的间接指针层），该桶继而又包含指向文件的指针。

1. 由于附加的间接指针层可能需要随机I/O操作，因此，索引访问需要花费更长的时间。
2. 如果一个码很少或没有重复，那么将整个块分配给其关联的桶会浪费大量的空间。

- 对于聚集索引的更新算法也适用于辅助索引。
- 辅助索引提高了使用除了聚集索引的搜索码外的码的查询性能，但是会给修改数据库带来很大的开销。

### 多码索引

- 一个搜索码可以有多个属性，而包含多个属性（属性列表）的搜索码被称为复合搜索码（composite search key）。

1. 复合搜索码可以表示为形如<code>(a<sub>1</sub>,..., a<sub>n</sub>) </code>的值的元组，其中索引属性是<code>A<sub>1</sub>, ..., A<sub>n</sub>。
2. 搜索码值按照字典序（lexicographic ordering）排列，字典序和单词的字母次序基本一致。例如，对于具有两个属性的搜索码的情况，如果<code>a<sub>1</sub>&lt;b<sub>1</sub>，或a<sub>1</sub>=b<sub>1</sub>且a<sub>2</sub>&lt;b<sub>2</sub>，则(a<sub>1</sub>, a<sub>2</sub>)&lt;(b<sub>1</sub>, b<sub>2</sub>)</code>。

## B<sup>+</sup>树索引文件



## 哈希索引机制

- 哈希(Hash)索引机制（散列技术）利用<b>散列函数（Hash Function）</b>实现记录域（查找码、散列域、排序域）到记录物理地址间的直接映射关系。
- 当需要访问数据文件中查找码值为s<sub>i</sub>的某个或某些目标记录时，将s<sub>i</sub>作为散列函数h的输入，计算得出的散列函数输出值h(s<sub>i</sub>)就是目标记录在数据文件中的物理地址。