# 存储管理

- 尽管数据库系统提供了数据的高级视图，但最终必须将数据以位的形式存储在一个或多个存储设备上。数据库系统将数据提取到主存中进行处理，并将数据写回存储器以保持持久性。数据也被复制到磁带和其他备份设备以进行归档存储。

## [物理存储介质](../Computer/Memory.md)

## 记录

- 一个数据库被映射为多个不同的文件，这些文件由底层的操作系统来维护，并永久地驻留在磁盘（块）上。
- 一个文件在逻辑上被组织为记录的一个序列，每个文件还从逻辑上被分成定长的存储单元，也就是块（block）。块是存储分配和数据传输的单位，大多数数据库默认使用4KB至8KB的块规模。
- 一个块可能包含多条记录，要求每条记录被完全地包含在单个块中；一个块所包含的确切的数据集合是由所使用的物理数据组织形式来决定的。

> 对于一些大数据项可能比块要大的，通过存储其指针来处理。

### 定长记录

- 在关系数据库中，不同关系的元组通常具有不同的规模。把数据库映射到文件的一种方法使用多个文件（定长记录文件），在任意给定的文件中只存储一种固定长度的记录（定长记录）。另一种方法是构造自己的文件（变长记录文件）。

1. 一个块只分配它能完整容纳的最多记录的数目，余下的字节不使用。以避免有的记录被分为两个块来存储，而导致对一条记录需要进行两次访问。
2. 文件头（file header）：在文件的开头分配特定数量的字节作为文件头。文件头中包含有关文件的各种信息，其中存储着的包括内容被删除的第一条记录的地址（指针，pointer），并在这个被删除内容的记录位置存放下一个被删除内容的记录的地址，从而形成了一条自由链表（free list）。在插入一条新记录时，使用文件头所指向的记录，并改变文件头的指针以指向下一条可用（被删除内容的）记录，如果没有可用的空间，就把新记录加到文件末尾。

<img src="../../pictures/数据库系统概念-定长记录文件.drawio.svg" width="450"/> 

### 变长记录

#### 变长记录

- 变长记录（variable-length record）通常是为了处理变长域（字符串等）、包含重复域的记录类型（数组、多重集合等）、文件中多种记录类型的出现等。

- 具有变长属性的记录通常包含两个部分：

1. 首先是带有定长信息的初始部分。定长属性以正常形式存储；而变长属性在记录的初始部分中被表示为一个`(偏移量, 长度)`对，其中偏移量表示在记录中该属性的数据开始的部分，而长度表示变长属性的字节长度。
2. 紧接着变长属性的内容，被分配存储这些属性的值所需的字节数。多个变长属性的值是连续存储的。

<img src="../../pictures/数据库系统概念-变长记录文件.drawio.svg" width="700"/> 

- 空位图（null bitmap）表示记录的哪个属性是空值，对于取空值的属性根本不存储数据（值、偏移量、长度）。该方式以提取记录属性的额外工作为代价来节省存储空间。

#### 分槽的页结构

- 分槽的页结构（slotted-page structure）一般用于在块中组织记录。每个块的开始处有一个块头，其中包含以下信息：

1. 块中记录项的数量。
2. 块中自由空间的末尾处。
3. 一个由包含每条记录的位置和大小的项组成的数组。

<img src="../../pictures/数据库系统概念-分槽的页结构.drawio.svg" width="700"/> 

- 实际记录从块的末尾处开始在块中连续分配空间。块中的自由空间是连续的，位于块头数组的最后一项和第一条记录之间。如果插入一条记录，在自由空间的尾部给这条记录分配空间，并且将包含这条记录的大小和位置的项加到块头中。
- 如果一条记录被删除，其所占用的空间被释放，并且它的项被置为`deleted`；此外，块中位于被删除记录之前的记录将被移动（防止在块的内部存在碎片空间），使得由删除而产生的自由空间能被重新使用，并且所有自由空间仍然位于块头数组的最后一项和第一条记录之间；块头中的自由空间末尾指针也要适当修改。（移动记录的代价并不太高，因为块的大小是有限的）
- 分槽的页结构要求没有指针直接指向记录，而是让指针必须执行块头中记有记录实际位置的项（间接指针），从而允许移动记录。

### 大对象存储

- SQL支持二进制大对象数据类型（blob）、字符大对象数据类型（clob）。大部分的数据库限制一条记录的规模不能大于一个块的规模（以简化缓冲区管理），但允许记录在逻辑上包含大对象。一个指向大对象的（逻辑）指针被存储到包含该大对象的记录中。

- 大对象（large object）可以以文件形式存储在被数据库管理的一个文件系统区域中，或者作为文件结构（<a href="#B+树文件组织">B<sup>+</sup>树文件组织</a>）存储在数据库中并被数据库管理。

<table>
    <tr>
        <td rowspan="2" width="10%">存储在数据库内部</td>
        <td width="90%">存储在数据库中的大对象可以选用B<sup>+</sup>树文件组织来表示。B<sup>+</sup>树文件组织允许读取一个完整的对象、或对象中指定的字节范围，以及插入和删除对象的一部分</td>
    </tr>
    <tr>
        <td>通过数据库接口访问对象的效率是一个需要关注的问题；在数据库中存储大对象会导致数据库转储规模的大量增长</td>
    </tr>
    <tr>
        <td rowspan="3">存储在数据库之外</td>
        <td>应用程序可以将文件名（文件系统中的路径）存储为数据库中记录的一个属性。</td>
    </tr>
    <tr>
        <td>如果存储在数据库外部的文件并不存在（例如被删除），则会导致某种形式的外码约束冲突。此外，数据库授权不适用于存储在文件系统中的数据</td>
    </tr>
    <tr>
        <td>一些数据库支持文件系统和数据库的集成，以此满足约束（例如阻止文件的错误删除），并且确保访问授权被执行；文件能够通过文件系统接口和数据库SQL接口进行访问。Oracle通过SecureFiles和数据库文件系统特性来支持这种集成</td>
    </tr>
</table>

## 文件组织

### 堆文件组织

- 堆文件组织（heap file organization）：在堆文件组织中，记录可以存储在对应于一个关系的文件中的任何位置。记录一旦被放在特定位置，通常不会被移动。
- 自由空间图（free-space map）：大多数数据库使用一种名为自由空间图的数据结构，以便跟踪具有自由空间来存储记录的块。

1. 自由空间图通常被表示成一个数组，对关系的每个块，该数组都包含一个项。每个项表示一个比例f，即在块中至少有比例为f的空间是自由的。数组（自由空间图）被存储在文件中，在需要时数组被读进内存。
2. 只要记录被插入、删除或者改变大小，如果占用比例的变化足以影响项的值，那么项必须在自由空间图中被更新。
3. 为了找到一个可以存储给定大小的新记录的块，数据库可以扫描自由空间图以找到一个具有足够空间的块来存储那条记录。如果不存在那样的块，则将给关系分配一个新块。
4. 自由空间图被周期性地写入磁盘，因此，磁盘上的自由空间图可能是过时的。当数据库启动时，可能会得到关于自由空间的过时数据。

- 二级自由空间图：为了进一步加速定位具有足够自由空间的块的任务，可以创建二级自由空间图。二级自由空间图的每个项表示主自由空间图的n个项，每个项存储了其对应的主自由空间图中n个项之内的最大值。

<img src="../../pictures/数据库系统概念-自由空间图.drawio.svg" width="600"/> 

### 顺序文件组织

- 顺序文件组织（sequential file organization）是为了高效处理按某个搜索码的顺序排序的记录而设计的。搜索码（serch key）是任意的属性或者属性的集合。

1. 为了能够按搜索码的顺序快速检索记录，通过指针把记录链接起来。每条记录的指针执行按搜索码顺序排列的下一条记录。
2. 为了最大限度地减少顺序文件处理中的块访问数量，按搜索码的顺序或者尽可能地接近搜索码的顺序物理地存储记录。

- 顺序文件组织允许记录按排列的顺序读取，但在插入和删除时维护记录的物理顺序是困难的。因此，对于插入操作，应用如下两条规则：

1. 在文件中定位按搜索码顺序位于待插入记录之前的那条记录。
2. 溢出块（overflow block）：如果在这条记录所在块中有一条自由的记录（删除后留下来的空间），就在这里插入新的记录。否则，将新的记录插入一个溢出块中。无论哪种情况，都要调整指针，使其能按搜索码顺序把记录链接在一起。

- 文件的重组（reorganized）：如果需要存储在溢出块中的记录相对较少，以上方式会工作地很好。但一段时间后，搜索码顺序和物理顺序之间的相似性最终可能会完全丧失，此时，顺序处理将变得十分低效。此时，文件应该被重组，使得它再次在物理上按顺序存放。重组的代价很高，并且必须在系统负载低的时候执行。

<img src="../../pictures/数据库系统概念-顺序文件组织.drawio.svg" width="500"/> 

- 在插入很少发生的极端情况下，使文件在物理上总保持有序是可能的，这种情况下也就不需要指针域了。

### 多表聚簇文件组织

- 多表聚簇文件组织（multitable clustering file organization）是一种在每个块中存储两个或更多关系的相关记录的文件组织形式。
- 聚簇码（cluster key）是一种属性，定义了哪些记录被存储在一起。通常是用于连接的属性作为聚簇码。
- 尽管多表聚簇文件组织可以加快特定的连接查询，但也会导致对其他类型的查询的处理变慢。

### B<sup>+</sup>树文件组织

- <span name="B+树文件组织">B<sup>+</sup>树文件组织</span>（B<sup>+</sup>-tree file organization）

### 散列文件组织

- 散列文件组织（hashing file organization）

##  数据字典存储

- 元数据（metadata）是“关于数据”的数据，例如关系的模式等。
- 关系模式和关于关系的其他元数据存储在<b>数据字典（data dictionary）（系统目录，system catalog）</b>。

1. 所有这些元数据信息组成了一个微型数据库（数据字典），通常使用<b>数据库关系</b>来存储元数据。
2. 数据字典通常存储为非规范的形式，以便快速存取。
3. 系统元数据被频繁访问，所以大多数数据库将其从数据库读入内存数据结构中，作为数据库启动的一部分来完成的。

<b>元数据包括：</b>

- 系统必须存储的信息类型：

1. 关系的名称
2. 每个关系中属性的名称
3. 属性的域和长度
4. 在数据库上定义的视图的名称，以及这些视图的定义
5. 完整性约束

- 很多系统为用户保存了下列数据：

1. 用户的名称、用户的缺省模式、用于认证用户的密码或其他信息
2. 关于每个用户的授权信息

- 数据库可能还会存储关于关系和属性的统计数据和描述数据
- 数据字典也可能记录关系的存储组织（堆、顺序、散列等），以及每个关系的存储位置：

1. 如果关系被存储在操作系统文件中，数据字典将会记录包含每个关系的单个文件（或多个文件）的名称
2. 如果数据库把所有关系存储在单个文件中，数据字典可能将包含每个关系的记录的块记在例如链表那样的数据结构中

- 数据库有必要存储关于每个关系的每个索引的信息：

1. 索引的名称
2. 被索引的关系的名称
3. 在其上定义索引的属性
4. 构造的索引的类型

## 数据库缓冲区

### 缓冲区

- 在多数数据库中，数据库数据仍主要存放在磁盘上，并且这些数据必须被存入内存以进行读取或更新；更新过的数据块必须随后写回磁盘。
- 数据库系统的一个主要目标就是减少在磁盘和内存之间传输的块数量，以最大化要访问的块已经在主存中的概率（命中）。
- <b>缓冲区（buffer）</b>是主存中用于存储磁盘块的拷贝的那部分。每个块总有一份拷贝存放在磁盘上，但是磁盘上的拷贝可能比缓冲区的版本旧。
- <b>缓冲区管理器（buffer manager）</b>是用于管理缓冲区空间分配的子系统。

### 缓冲区管理器

1. 当数据库系统中的程序需要磁盘上的块时，它向缓冲区管理器发出请求（调用）。
2. 如果这个块已经在缓冲区中，则缓冲区管理器将这个块在主存中的地址传给请求者。
3. 如果这个块不在缓冲区中，则缓冲区管理器首先在缓冲区中为这个块分配空间。
4. 如果空间不足，可能会把一些其他块移出主存（缓冲区替换策略），为这个新块腾出空间。被移出的块仅当它在最近一次写回磁盘后被修改过才被写回磁盘。
5. 然后，缓冲区管理器把被请求的块从磁盘读入缓冲区，并将这个块在主存中的地址传给请求者。

- 缓冲区管理器的内部动作对发出磁盘块请求的程序是透明的。

#### <a href="#缓冲区替换策略">缓冲区替换策略</a>

#### 钉住块 pin

- 多个进程能从缓冲区中的一个块中读取数据，要求每个进程在访问数据前执行<b>钉住（pin）</b>操作，并在完成访问后执行<b>解除钉住（pin）</b>操作。直到所有对块执行了钉住操作的进程都解除钉住后，该块才能被移出。

1. 在一个进程从缓冲块中读取数据之前，进程在该块上执行<b>钉住（pin）</b>操作，缓冲区管理器绝不会移出一个被钉住的块。
2. 当进程完成数据读取后，会执行<b>解除钉住（unpin）</b>操作，允许该块在必要时被移出。

- 通过对每个缓冲块维护<b>钉住计数（pin count）</b>，对每个钉住操作增加该计数，且对每个解除钉住操作减少该计数。仅当一个页面的钉住次数为0时，其才能被移出。

#### 共享排他锁

- 数据库缓冲区管理器允许进程获取缓冲区上的<b>共享排他锁</b>。由缓冲区管理区提供的封锁系统允许数据库进程在访问一个块之前，以共享模式或者排他模式封锁该缓冲块，并且在访问完成之后释放封锁。
- 用于封锁的规则保证了缓冲区访问的安全。确保当另外的进程在读块时，该块不能被更新；反过来说，当另外的进程正在更新块的时候，此块不能被读取。

1. 任意数量的进程可以在一个块上同时拥有共享锁。
2. 每次只允许一个进程获得排他锁，并且当一个进程执有排他锁时，其他进程不能执有此块上的共享锁。因此，只有当没有其他进程在缓冲块上执有封锁的时候，排他锁才能被授予。
3. 如果一个进程请求块上的排他锁，但此块已经以共享或者排他模式被封锁，那么在早期封锁被释放之前，该请求一直处于等待状态。
4. 如果一个进程请求块上的共享锁，而且此块没有被封锁或者已经被共享锁封锁，则此锁可以被授予；但是，如果另一个进程持有该块的排他锁，则共享锁只有在排他锁被释放后才能被授予。

- 按如下方式获得并释放封锁:

1. 在一个块上执行任何操作之前，进程必须钉住这个块。随后获得封锁，且必须在对块解除钉住之前释放封锁。
2. 在从缓冲块读数据之前，进程必须获取此块上的共享锁。当完成数据读取时，进程必须释放此锁。
3. 在更新缓存块内容之前，进程必须获取此块上的排他锁；该锁必须在更新完成后释放。

#### 块写出

- 仅当另一个块需要缓冲空间时才写出一个块是可能的。但是，更期待于不用等到需要缓冲空间时，而是在产生这种需求之前，就写出更新过的块。之后，当需要缓冲区中的空间时，一个已经被写出过的块可以被移出，只要它当前没有被钉住。
- 大多数数据库有一个进程，其可以连续监测更新过的块并将块写回磁盘。为了数据库系统能够从崩溃中恢复，有必要限制一个块能被写回磁盘的时间。例如，大多数恢复系统要求，当块上正在进行更新时，该块不能被写回磁盘。为了满足这个要求，希望将块写回磁盘的进程必须获取块上的共享锁。

#### 块的强制写出

- 某些情况下，需要把块写回磁盘，以确保磁盘上的数据处于一致性状态；这样的写操作称为<b>块的强制写出（forced output）</b>。
- 主存的内容乃至缓冲区的内容会在崩溃时丢失，然而磁盘上的数据（通常）在崩溃时得以幸免。将强制写出与日志机制一起使用，以确保当执行更新的事务被提交时，有足够的数据写回磁盘，从而保证事务的更新不会丢失。

### <span name="缓冲区替换策略">缓冲区替换策略</span>

- 当缓冲区中没有剩余空间时，一个块必须被移出（evicted)，即在新块读入缓冲区之前，必须把一个块从缓冲区中去除。而<b>缓冲区替换策略</b>的目标是减少对磁盘的访问。

#### LRU 最近最少使用策略

- 多数操作系统使用<b>LRU（Least Recently Used，最近最少使用）</b>策略，即最近最少访问的块被写回磁盘，并从缓冲区中移走。
- 数据库系统能够比操作系统更准确地预测未来的访问模式。用户对数据库系统的请求包括若干步，通过查看执行用户请求的操作所需的每一步，数据库系统通常可以预先确定哪些将是需要的。因此，对于数据库而言，尽管绝大多数数据库系统都使用LRU策略，但LRU策略有其缺点。

#### 立即丢弃策略

- <b>立即丢弃策略（toss-immediate）</b>：一旦关系中的一个元组被处理过，那么就不再需要这个元组了。因此，如果一个块中的最后一个元组被处理完毕，就应该命令缓冲区管理器释放这个块所占用的空间。

#### MRU 最近最常使用策略

- 如果必须从缓冲区中移出一个块，<b>MRU（Most Recently Used，最近最常使用）策略</b>将选择最近最常使用的块（正在被使用的块则不能被替换）。要使MRU策略正确工作，系统必须把当前正在处理的块钉住。在块中最后一个元组处理完毕后，这个块就被解除钉住，并成为最近最常使用的块。

#### 影响缓冲区替换策略的其他因素

- 除了使用系统所拥有的关于被处理的请求的知识，缓冲区管理器还可以使用有关一个请求将访问特定关系的概率的统计信息。

1. 缓冲区管理器应尽量不把数据字典从主存中移出，除非有其他因素决定了它非这样做不可。
2. 对文件索引的访问可能比文件本身更频繁，所以除非迫不得已，缓冲区管理器一般不会把索引块从主存中移出。

- 除了块被再次访问的时间以外，缓冲区管理器所使用的块替换策略还受其他因素的影响。如果系统并发地处理来自多个用户的请求，<b>并发控制子系统</b>可能需要延迟某些请求，以保证数据库的一致性。如果缓冲区管理器从并发控制子系统获得了关于哪些请求被延迟的信息，它就可以使用这些信息来改变它的块替换策略。具体地说，活跃的（非延迟的）请求所需要的块可以保留在缓冲区中、以牺牲被延迟的请求所需要的块为代价。
- <b>崩溃一恢复子系统</b>对块替换施加了严格的约束。如果一个块被修改过，则不允许缓冲区管理器将这个块在缓冲区中的新版本写回磁盘；因为这将破坏旧的版本。取而代之的做法是，块管理器在写出块之前，必须向崩溃一恢复子系统寻求许可。崩溃一恢复子系统在允许缓冲区管理器写出所需的块之前，可能要求将另一些特定的块强制写出

### 写操作的重排序与恢复

- 数据库缓冲区允许在内存中执行写操作，并在以后将其输出到磁盘，输出的顺序可能与执行写出的顺序不同。文件系统也经常对写操作重新排序。但是，这种重新排序可能会导致在发生系统崩溃时磁盘上的数据不一致。

1. 早期的文件系统必须在系统重新启动时执行文件系统一致性检查，以确保数据结构是一致的。如果不一致，就必须采取额外的措施把它们恢复到一致状态。这些检查会导致崩溃后系统重启的长时间延迟，随着磁盘系统容量的增加，这种延迟会变得更长。
2. 如果文件系统按精心选择的顺序更新元数据，那么在许多情况下，它可以避免不一致的问题。但是这样做意味着诸如磁盘臂调度之类的优化无法完成，从而影响更新的效率。
3. 如果有可用的非易失性写缓冲区，可以用它来对非易失性RAM执行顺序的写操作，然后在写人磁盘时再重新排序。

- 现代文件系统分配一个磁盘（<b>日志磁盘，log  disk</b>），用于按执行顺序存储写操作的日志。对于每次写操作，日志都包含待写入的块的编号和要写入的数据，日志的顺序与执行写操作的顺序一致。在执行写操作后，记录将从日志磁盘中删除。

1. 对日志磁盘的所有访问都是顺序的，基本上消除了寻道时间，并且多个连续的块可以一次性写入，使得写人日志磁盘的速度比随机写入快好几倍。
2. 和以前一样，数据还必须写到它们在磁盘上的实际位置，但是对实际位置的写操作可以之后完成；<u>可以对写操作进行重新排序，以最小化磁盘臂的移动</u>。
3. 如果在对实际磁盘位置的某些写操作完成之前系统崩溃，当系统恢复时，它会读取日志磁盘，以找到尚未完成的那些写操作，然后执行这些操作。

- 支持上述日志磁盘的文件系统称为<a href="../Linux/FileSystem.md#日志文件系统">日志文件系统（journaling file system）</a>。即使没有单独的日志避盘，也可以通过将数据和日志保存在同一个磁盘上来实现日志文件系统。但这样做会以更低性能为代价来降低资金成本。

1. 大多数现代文件系统在写入诸如文件分配信息那样的文件系统元数据时实现日志并使用日志磁盘。
2. 日志文件系统允许快速重启，无须进行此类文件系统的一致性检查。
3. 应用程序执行的写操作通常不会被写入日志磁盘。相反，数据库系统实现了自己的日志形式，以确保在发生故障时，即使对写操作进行了重新排序，也可以安全地恢复出数据库的内容。

# 索引