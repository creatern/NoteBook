# 查询处理和查询优化概述

- 查询处理（query processing）是指从数据库中提取数据所涉及的一系列活动。这些活动包括：将用高层数据库语言表示的查询语句翻译为能在文件系统的物理层上使用的表达式、各种查询优化转换、以及查询的实际执行。
- 查询处理的基本步骤包括：语法分析与翻译、优化、执行。

 <img src="../../pictures/数据库系统概念-查询处理的步骤.drawio.svg" width="600"/>

1. 在查询处理开始之前，系统必须将查询语句翻译成可使用的形式（系统的内部表示形式）。
2. 在产生查询语句的系统内部表示形式的过程中，语法分析器检查用户查询的语法，验证出现在查询中的关系名就是数据库中的关系名等。
3. 系统构造该查询的语法分析树表示形式，然后将之翻译成[关系代数表达式](./形式化关系查询语言.md)。
4. 如果查询是用视图形式来表示的，在翻译阶段还要用定义该视图的关系代数表达式来替换所有对该视图的引用。
5. 如果物化视图，则定义视图的表达式已经执行并存储了结果。因此，可以使用存储的关系，而不是使用由定义视图的表达式来替换的视图。
6. 如果是递归视图，则通过不动点过程来处理。

> 一些数据库系统并不使用关系代数表示形式，而是采用基于给定的SQL查询结构、带注释的语法分析树表示形式。

- 给定一个查询，通常会有多种用于计算结果的方法。

1. 一个查询能够用几种不同的方式来表示，可以用其中的一种方式来将每条SQL查询本身翻译成关系代数表达式。
2. 此外，一个查询的关系代数表达式仅仅部分指定了如何执行查询；通常有多种方式来执行关系代数表达式。

- 为了全面说明如何执行一个查询，不仅要提供关系代数表达式，还要对表达式加上带指令的注释来说明如何执行每种运算。这些注释可以说明为一种具体运算所采用的算法，或要使用的一个具体索引或多个索引。

1. 带有“如何执行”注释的关系代数运算称为<b>执行原语（evaluation primitive）</b>。
2. 用于执行一个查询的原语操作序列称为<b>查询执行计划（query-execution plan、query-evaluation plan）</b>。
3. <b>查询执行引擎（query-execution engine）</b>接受一个查询执行计划，执行该计划并把结果返回给查询。

- 对于给定查询的不同执行计划会有不同的代价。而构造具有最小查询执行代价的查询执行计划应当是系统的责任，这也就是<b>查询优化（query optimization）</b>。一旦选定了查询计划，就用该计划来执行查询并输出查询的结果。

# 查询代价的度量

- 为了优化一个查询，查询优化器必须知晓每种运算的代价（尽管大多数只能是粗略的估计），以此来根据不同的代价来选择最佳的执行计划。
- 查询执行的代价可以以不同资源的形式来进行度量，这些资源包括产品存取、执行一个查询所用的CPU时间、并行和分布式数据库系统中的通信代价。

## 磁盘访问

1. 对于驻留在磁盘上的大型数据库，从磁盘访问数据的I/O代价通常是最主要的代价。
2. 当数据驻留在内存或SSD中时，I/O代价并不总是最主要的代价，并且在计算查询执行代价时，必须包括CPU代价。CPU代价可以通过简单的估计来近似得出。数据库具有每种类似于PostgreSQL的代价模型中的代价的缺省值，这些缺省值可以分别乘以被处理元组的数量、被处理索引项的数量以及被执行算子和函数的数量等。缺省值可以作为配置参数被更改。

- 通常使用<q>从存储中传输的块数</q>以及<q>随机I/O访问数</q>作为估计查询执行计划的代价的两个重要因素，因为二者都需要在磁盘存储器上进行磁盘寻道。

1. 如果磁盘子系统传输一个数据块平均要花费t<sub>T</sub>秒，并且平均的块访问时间（磁盘寻道时间+旋转延迟）为t<sub>s</sub>秒，那么一个传输b个块并执行S次随机I/O访问的运算将要花费<code>b\*t<sub>T</sub> + S\*t<sub>S</sub></code>秒。
2. t<sub>T</sub>和t<sub>S</sub>的值必须针对所使用的磁盘系统进行标定。
   1. t<sub>T</sub> = 块规模 / 传输率
   2. t<sub>S</sub> = (1/N) - t<sub>T</sub> ，其中，N是设备所支持的每秒随机I/O操作数。一次随机I/O操作执行一次随机I/O访问，后接一个块的数据传输。

- 尽管SSD并不执行物理寻道操作，但SSD在启动I/O操作时有一个开销，因此，将从发出I/O请求到返回第一个字节的延迟作为t<sub>S</sub>。
- 对于已经存在于主存中的数据，读操作是以<q>高速缓存行</q>为单元的，而不是磁盘块。
- 在理想情况下，数据库系统在软件安装的过程中，必须执行测试寻道和块传输来估计特定系统/存储设备的t<sub>S</sub>和t<sub>T</sub>。而不能自动推断这些数值的数据库通常允许用户将这些数值指定为配置文件的一部分。
- 在磁盘上块写的代价通常是块读代价的两倍，磁盘系统在写操作之后要读回扇区以验证写操作是否成功。此外，读/写吞吐量并不能反映当块被重写时所需的擦除代价。

## 缓冲区规模

- 假定考虑的所有算法的代价都取决于主存中的缓冲区规模，在最佳情况下，如果数据能放入缓冲区中，则可以将数据读入缓冲区中，而不需要再访问磁盘。通常假定代价估计使用一个运算M可用的内存量作为参数。

1. 在PostgreSQL中，出于代价估计的目的，一个查询可用的总内存被称为有效缓存规模。假定在缺省情况下的有效缓存规模为4GB，如果一个查询有多个并发运行的算子，则必须将可用内存在这些算子之间进行划分。
2. 为了（或者部分地）计算缓冲区驻留，PostgreSQL的方法如下。随机页面读取的代价被假定为实际随机页面读取代价的1/10,以模拟90%的读取块被发现驻留在高速缓存中的情况。
3. 此外，为了模拟B<sup>+</sup>树索引的内部节点经常被遍历的情况，大多数数据库系统假设所有内部节点都存在于内存缓冲区中，并且假设索引的遍历只会导致对于叶节点的单次随机I/O的开销。

## 响应时间

- 假设计算机中没有其他活动在进行，一个查询执行计划的<b>响应时间（response time）</b>（即执行该计划所需的壁钟时间/挂钟时间 wall-clock time）就是所有这些代价的总和，并可用作计划代价的度量。但如果不实际执行计划，很难估计计划的响应时间。

1. 响应时间依赖于当查询开始执行时缓冲区的内容；但在对查询进行优化时，这样的信息是无法或很难获取与用于计算的。
2. 在具有多个磁盘的系统中，响应时间依赖于访问在磁盘之间是如何分布的，如果没有对分布在磁盘上的数据的详细了解，那么这是很难估计的。

- 查询器通常努力地去将查询计划的总的<b>资源消耗（resource consumption）</b>降到 最低，而不是努力将响应时间降到最低。

# 关系代数运算的执行

## 选择运算

### 文件扫描与索引

- 在查询处理中，<b>文件扫描（file scan）</b>是数据访问的最低级别的运算。文件扫描是用于定位和检索满足选择条件的记录的搜索算法。在关系系统中，若关系保存在一个单独的专用文件中，则采用文件扫描就可以读取整个关系。

<table>
    <caption>选择算法的代价估计</caption>
    <tr>
        <th width="5%"></th>
        <th width="20%">算法</th>
        <th width="20%">代价</th>
        <th width="55%">原因</th>
    </tr>
    <tr>
        <td><a href="#A1"><span name="a1">A1</span></a></td>
        <td>线性搜索</td>
        <td>t<sub>S</sub>+b<sub>r</sub>*t<sub>T</sub></td>
        <td>一次初始搜索加上b<sub>r</sub>次块传输，其中b<sub>r</sub>表示文件中的块数量</td>
    </tr>
    <tr>
        <td>A1</td>
        <td>线性搜索，码上的等值比较</td>
        <td>平均情形<br/>t<sub>S</sub>+(b<sub>r</sub>/2)*t<sub>T</sub></td>
        <td>最多有一条记录满足条件，一旦找到所需的记录，扫描就可以终止。但在最坏的情形下，仍需要b<sub>r</sub>次块传输</td>
    </tr>
    <tr>
        <td><a href="#A2"><span name="a2">A2</span></a></td>
        <td>B<sup>+</sup>树聚集索引，码上的等值比较</td>
        <td>(h<sub>i</sub>+1)*(t<sub>T</sub>+t<sub>S</sub>)</td>
        <td>h<sub>i</sub>表示索引的高度。索引搜索遍历树的高度，再加上一次I/O来获取记录；每个这样的I/O操作需要一次寻道和一次块传输</td>
    </tr>
    <tr>
        <td><a href="#A3"><span name="a3">A3</span></a></td>
        <td>B<sup>+</sup>树聚集索引，非码上的等值比较</td>
        <td>h<sub>i</sub>*(t<sub>T</sub>+t<sub>S</sub>)+t<sub>S</sub>+b*t<sub>T</sub></td>
        <td>树的每一层有一次寻道，第一个块有一次寻道。b是包含具有指定搜索码记录的块数，所有这些记录都是要读取的。假定这些块是顺序存储的（聚集索引）的叶子块并且不想要额外的寻道</td>
    </tr>
    <tr>
        <td><a href="#A4"><span name="a4">A4</span></a></td>
        <td>B<sup>+</sup>树辅助索引，码上的等值比较</td>
        <td>(h<sub>i</sub>+1)*(t<sub>T</sub>+t<sub>S</sub>)</td>
        <td>和聚集索引类似</td>
    </tr>
    <tr>
        <td>A4</a></td>
        <td>B<sup>+</sup>树辅助索引，非码上的等值比较</td>
        <td>(h<sub>i</sub>+n)*(t<sub>T</sub>+t<sub>S</sub>)</td>
        <td>n是所获取记录的数量。此处的索引遍历代价和A3一样，但是每条记录可能存储在不同的块上，需要对每条记录进行一次寻道。如果n值比较大，代价可能会非常昂贵</td>
    </tr>
    <tr>
        <td><a href="#A5"><span name="a5">A5</span></a></td>
        <td>B<sup>+</sup>树聚集索引，比较</td>
        <td>h<sub>i</sub>*(t<sub>T</sub>+t<sub>S</sub>)+t<sub>S</sub>+b*t<sub>T</sub></td>
        <td>和A3、非码上的等值比较的情形一致</td>
    </tr>
    <tr>
        <td><a href="#A6"><span name="a6">A6</span></a></td>
        <td>B<sup>+</sup>树辅助索引，比较</td>
        <td>(h<sub>i</sub>+n)*(t<sub>T</sub>+t<sub>S</sub>)</td>
        <td>和A4、非码上的等值比较的情形一致</td>
    </tr>
</table>

#### <a href="#a1"><span name="A1">A1</span></a>（线性搜索）

- 在线性搜索中，系统扫描每一个文件块，并对所有记录都进行测试，查看是否满足选择条件。

1. 需做一次初始搜索来访问文件的第一个块。
2. 如果文件的块不是连续存储的，则可能需要额外的搜索。

- 线性搜索算法虽然比实现选择运算的其他算法速度要慢，但可以用于任何文件，而不用管文件的顺序、索引的可用性，以及选择算法的性质。

#### 索引扫描

- 索引结构称为<b>存取路径（access path）</b>，因为其提供了定位和存取数据的一条路径。
- 使用索引的搜索算法称为<b>索引扫描（index scan）</b>，通过选择谓词来指导查询处理中要使用的索引。

##### <a href="#a2"><span name="A2">A2</span></a>（聚集索引，码上的等值比较）

- 对于具有等值比较的码属性上的等值比较，可以使用该索引来检索出满足相应等值条件的单条记录。
- 为了模拟索引的内部节点位于内存缓冲区中的常见情况，通常将h<sub>i</sub>（索引的高度）设置为1。

##### <a href="#a3"><span name="A3">A3</span></a>（聚集索引，非码上的等值比较）

- 当选择条件指定的是基于一个非码属性A的等值比较时，可以通过使用聚集索引来检索到多条记录。在这种情况下，可能需要获取多条记录，但因为文件是依据搜索码进行排序的，所以这些记录在文件中必然是连续存储的。

##### <a href="#a4"><span name="A4">A4</span></a>（辅助索引，等值比较）

- 指定等值条件的选择可以使用一个辅助索引。若等值条件是在一个码上的，则该策略可检索到单条记录；若索引字段不是码，则可能检索到多条记录。

1. 第一种情况下，只有一条记录检索到，代价和聚集索引类似。
2. 第二种情况下，每条记录可能驻留在不同的块上，可能导致每检索到一条记录就需要一次I/O操作，且每次I/O操作都需要一次寻道和一个块的参数。如果每条记录位于不同的磁盘块中并且块的获取是随机排序的，那么在这种情况下，最坏情形的代价是(h<sub>i</sub>+n)*(t<sub>T</sub>+t<sub>S</sub>)。如果检索大量记录（n&uarr;），最坏情形下的代价可能会大于线性搜索。

- 如果内存缓冲区较大，那么包含记录的块可能已经在缓冲区中了。通过考虑包含在记录中的块已经位于缓冲区的概率，可以构建对选择运算的平均或期望代价的估计。对于大型缓冲区，该估计值会远低于最坏情形下的估计值。

##### 辅助索引与B<sup>+</sup>树文件组织

- 在包括A2在内的某些算法中，因为记录存储在树的叶子层，所以使用B<sup>+</sup>树文件组织可以节省一次存取。
- 当记录以B<sup>+</sup>树文件组织或可能需要重新配置记录的其他文件组织的方式存储时，辅助索引通常不存储指向记录的指针。相反，辅助索引存储的是B<sup>+</sup>树文件组织中用作搜索码值的属性值。通过这种辅助索引存取一条记录的代价会更昂贵，如果使用这种索引，为辅助索引描述的代价公式必须进行适当的修改。
- 辅助索引存取一条记录的过程：

1. 首先搜索辅助索引以找到B<sup>+</sup>树文件组织的搜索码值。
2. 然后查找B<sup>+</sup>树文件组织来找到这些记录。

### 涉及比较的选择

#### <a href="#a5"><span name="A5">A5</span></a>（聚集索引，比较）

- 当选择条件是比较表达式时，可以使用有序的聚集索引（例如B<sup>+</sup>树聚集索引）。

1. 对于形如A&gt;v或A&ge;v的比较条件，可按以下方式使用A上的聚集索引来引导对元组的检索：
   1. 对于A&ge;v，在索引中寻找值v，以检索出文件中满足值A&ge;v的首个元组。
   2. 从该元组开始直到文件末尾进行一次文件扫描就可返回满足该条件的所有元组。
   3. 对于A&gt;v，文件扫描从第一个满足A&gt;v的元组开始。

   - 代价估计和A3是一样的。

2. 对于形如A&lt;v或A&ge;v的比较条件，一次索引查找都不需要。

   1. 对于A&lt;v，只是从文件头开始使用简单的文件扫描，一直到遇上（但不包含）首个满足A=v的元组为止。
   2. 对于A&le;v，只是继续扫描到遇上（但不包含）首个满足A&gt;v的元组位置。

#### <a href="#a6"><span name="A6">A6</span></a>（辅助索引，比较）

- 可以使用有序的辅助索引来指导涉及&lt;、&le;、&ge;、&gt;的比较条件的检索。扫描最低层的索引要么从最小值开始直到v为止（对于&lt;、&le;情形），要么从v开始直到最大值为止（对于&ge;、&gt;情形)。
- 辅助索引提供了指向记录的指针，但为了得到实际的记录，还需要通过使用指针来获取记录。由于连续的记录可能位于不同的磁盘块上，此时，每获取一条记录都可能需要一次I/O操作。每次I/O操作都需要一次磁盘寻道和一次块传输。如果检索到的记录的数量很多，那么使用辅助索引的代价甚至可能比使用线性搜索还要大；因此，辅助索引应该仅在选择得到的记录非常少时使用。

#### 位图索引扫描

- 只要提前知道匹配元组的数量，查询优化器就可以根据代价估计在使用辅助索引和使用线性搜索之间进行选择。但是，如果在编译时无法准确知道匹配元组的数量，则这两种选择都可能导致糟糕的性能，具体取决于匹配元组的实际数量。为了解决该情况，当辅助索引可用但匹配记录的数量无法精确知晓时，PostgreSQL使用了一种称为<b>位图索引扫描（bitmap index scan）</b>的混合算法。

1. 位图索引扫描算法首先创建一个位图，其位数与关系中的块数相同，所有位都初始化为0。
2. 之后，该算法使用辅助索引来查找匹配元组的索引项，但其不会立即获取这些元组，而是执行下一步操作。
3. 当找到每个索引项时，该算法从索引项中获得块号，并将位图中的相应位设置为1。
4. 一旦处理完所有的索引项之后，将扫描位图以找出位被设置为1的那些块，也就是包括匹配记录的块。
5. 接着对关系进行线性扫描，但跳过那些未被设置为1的那些块，只获取位被设置为1的那些块。
6. 之后，在每个块内部使用扫描来检索出块中的所有匹配记录。

- 在最坏情况下，位图索引扫描算法比线性扫描的代价稍高，比使用辅助索引扫描来直接获取元组的代价稍高；但在最好情况下，比线性扫描的代价低得多，也比辅助索引扫描的代价低得多。以此来保证其性能绝不会比数据库实例的最佳计划差得太多。
- 位图索引扫描的一种变体是，收集所有的索引项，并对这些索引项进行排序，之后执行关系扫描，跳过没有任何匹配项的块。

### 复杂选择的实现

#### 更复杂的选择谓词：合取、析取、否定

<table>
    <tr>
        <td width="20%">合取（conjunction）</td>
        <td width="80%"><code>&sigma;<sub>&theta;<sub>1</sub>&and;&theta;<sub>2</sub>&and;...&and;&theta;<sub>n</sub></sub>(r)</code></td>
    </tr>
    <tr>
        <td>析取（disjunction）</td>
        <td><code>&sigma;<sub>&theta;<sub>1</sub>&or;&theta;<sub>2</sub>&or;...&or;&theta;<sub>n</sub></sub>(r)</code>。满足单个简单条件&theta;<sub>i</sub>的所有记录的并集满足析取条件</td>
    </tr>
    <tr>
        <td>否定（negation）</td>
        <td>选择操作<code>&sigma;<sub>&not;&theta;<sub>1</sub></sub>(r)</code>的结果就是对条件&theta;取值为假的r的元组的集合。如果没有空值，该集合就只是r中不在&sigma;<sub>&theta;<sub>i</sub></sub>(r)的那些元组的集合</td>
    </tr>
</table>

#### A7（使用一个索引的合取选择）

1. 首先判断对于其中一个简单条件中的一个属性是否存在一条存取路径可用。
2. 若存在，则可以用从A2到A6的一种选择算法来检索满足该条件的记录。
3. 然后在内存缓冲区中，通过测试每条检索到的记录是否满足其余的简单条件来最终完成这个运算。

- 为了减少代价，选择一个&theta;<sub>i</sub>以及从A1到A6的一种算法和A7进行组合，使得&sigma;<sub>&theta;<sub>i</sub></sub>(r)的代价最小。因此，A7算法的代价取决于其选择组合的算法。

#### A8（使用组合索引的合取选择）

1. 对于某些合取选择可能可以使用合适的<b>组合索引（composite inde）</b>（多个属性上的一个索引）。
2. 如果选择指定的是两个或多个属性上的等值条件，并且在这些属性字段的组合上又存在组合索引，那么可以直接搜索该索引。
3. 索引的类型将决定使用A2、A3、A4算法中的哪一个。

#### A9（使用标识交集的合取选择）

- A9也是可选的用于实现合取选择运算的方法，涉及利用记录指针或记录标识。

1. 要求在各个条件所涉及的字段上都有带记录指针的索引。
2. 对每个索引进行扫描，以获取那些指向满足单个条件的元组的指针。
3. 所有检索到的指针的交集就是那些满足合取条件的元组的指针集合。
4. 然后利用这些指针来获取实际的记录。
5. 如果并非所有单个条件上均有索引可用，则该算法要用剩余条件对检索到的记录进行测试。

- 算法A9的代价是扫描各个索引的代价的总和，再加上对检索到的指针列表的交集中的记录进行获取的代价（通过对指针列表进行排序并按序检索记录能够减少此代价）。减少代价的方法如下：

1. 把指向一个块中记录的所有指针归并到一起，就只需通过单次I/O操作就可以获取该块中被选出的所有记录。
2. 并且按序读取块，使磁盘臂的移动最少。

- 则扫描 际的记录。 描来找出满足 最少。12.3.2 然而， 价。因此，（1） 每 的存取方法就是线性扫描， 集中的记录进行获取的代价。 个索引以  节将

####  A10（使用标识并集的析取选择）

1. 如果析取选择的所有条件均有可用的存取路径，则扫描每个索引以获取单个条件的元组的指针。检索到的所有指针的并集就产生出指向满足析取条件的所有元组的指针的集合，然后利用这些指针去检索实际的记录。
2. 然而，即使只有其中一个条件不存在存取路径，就也不得不对关系进行线性扫描来找出满足条件的元组。因此，如果在析取式中存在一个这样的条件，那么最有效的存取方法就是线性扫描，在扫描的过程中对每个元组进行析取条件的测试。

## 排序

### 排序的意义

- 数据排序在数据库系统中的重要作用：

1. SQL查询会指明对输出进行排序。
2. 对于查询处理而言同等重要的是，有几种关系运算（例如，连接运算），如果对输入关系先进行排序，能够得到高效的实现。