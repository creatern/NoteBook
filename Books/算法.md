# 算法分析

## 算法定义

- 算法：有限的操作序列。

- 算法的五大特性：有穷性、确定性、可行性、输入、输出。

- 好算法的目标要求：正确性、可读性、健壮性、高效率、低存储量。

## 时间复杂度

- 事后统计方法、事前分析估算方法。
- 语句频度：语句的重复执行次数。
- 时间复杂度：语句总的执行次数T(n)关于问题规模n的函数：$T(n)=O(f(n))$。

- 时间复杂度耗费时间排序：

$$
O(1) < O(log_2n) < O(n) < O(n^2) < O(n^3) < O(2^n) < O(n!)
$$

## 空间复杂度

- 空间复杂度：算法所需存储空间的量度，$S(n)=O(f(n))$。
- 原地工作：若算法执行时所需的辅助空间相对于输入数据量是常数，空间复杂度为O(1)。

# 稀疏数组

- 一个数组中大部分元素为０，或同一个值时（大多数的数据是重复的、无意义的），应该转换为稀疏数组。

- 稀疏数组记录数组一共有几行几列，有多少个不同的值，并把具有不同值的元素的行、列、值记录在一个小规模的数组。

<img src="../pictures/Snipaste_2022-11-24_20-47-39.png" width="600"/>  

<img src="../pictures/Snipaste_2022-11-24_20-56-14.png" width="800"/>  

```java
public class SparseArray {

    public static void main(String[] args) {
        // 原始的二维数组 11*11 （棋盘）
        // 0 没有棋子 ； 1 白子 ；2 黑子
        int[][] chessboardArr = new int[11][11];
        chessboardArr[1][1] = 1;
        chessboardArr[5][4] = 2;
        for (int[] chessArr : chessboardArr) {
            for (int chess : chessArr) {
                System.out.print(chess + "\t");
            }
            System.out.println();
        }

        // 转为稀疏数组：
        // 1. 先遍历二维数组，得到非大量重复的元素个数
        int sum = 0;
        for (int[] chessArr : chessboardArr) {
            for (int chess : chessArr) {
                if (chess != 0) {
                    sum++;
                }
            }
        }
        // 2. 创建对应的稀疏数组，第一行留给统计行、列、不同值元素个数
        int[][] sparseArray = new int[sum + 1][3];
        sparseArray[0][0] = chessboardArr.length;
        sparseArray[0][1] = chessboardArr[0].length;
        sparseArray[0][2] = sum;
        int counter = 1;
        // 3. 给稀疏数组赋值
        for (int i = 0; i < chessboardArr.length; i++) {
            for (int j = 0; j < chessboardArr[i].length; j++) {
                if (chessboardArr[i][j] != 0) {
                    sparseArray[counter][0] = i;
                    sparseArray[counter][1] = j;
                    sparseArray[counter][2] = chessboardArr[i][j];
                    counter++;
                }
            }
        }

        for (int[] chessArr : sparseArray) {
            for (int chess : chessArr) {
                System.out.print(chess + "\t");
            }
            System.out.println();
        }

        // 稀疏数组-->原始二维数组
        // 1. 先读取稀疏数组的第一行，创建原始二维数组
        int[][] newChessboardArr = new int[sparseArray[0][0]][sparseArray[0][1]];
        // 2. 读取稀疏数组后几行的数据，并赋给原始二维数组 （如果需要可以先赋重复的、无意义的值）
        for (int i = 1; i < sparseArray.length; i++) {
            newChessboardArr[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
        }

        for (int[] chessArr : newChessboardArr) {
            for (int chess : chessArr) {
                System.out.print(chess + "\t");
            }
            System.out.println();
        }
    }

}
```

# 穷举算法

- 穷举：在明确知道问题的答案范围时，从所有的可能中搜索正确的。

## 鸡兔同笼

- 今有鸡兔同笼，上有三十五头，下有九十四足，问鸡兔几何？

```java
package exhaustive;

public class JiTu {
    public static void main(String[] args) {
        count(35,94);
    }

    public static void count(int head, int foot) {
        for (int i = 0; i < head; i++) { //i 为鸡头数量
            if ((i * 2 + (head - i) * 4) == foot) {
                System.out.println("鸡：" + i + "兔：" + (head - i));
            }
        }
    }
}
```

# 贪心算法

- 局部最优解，即：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的时候使用贪心算法。贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（某个状态以后的过程不会影响以前的状态，只与当前状态有关）。

1. 建立数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。

# 递归算法

- 递归是自己调用自己，可以被栈替代。

- 递归的重点在于对子问题的处理。递归通常不在意具体操作，只关心初始条件、结束条件和上下层的变化关系。
- 递归函数需要有临界停止点（结束条件）（递归不能无限制的执行下去）， 通常这个点为必须经过的一个数。

<img src="../pictures/Snipaste_2023-02-21_20-48-55.png" width="800"/>

## 阶乘

```java
public static int factorial(int num) {
    if (num == 0) {
        return 1;
    }else{
        return num * factorial(--num);
    }
}
```

## 斐波那契数列

- 求斐波那契的公式为：`F[n]=F[n-1]+F[n-2](n>=3,F[1]=1,F[2]=1)`

```java
public static int fibonacci(int num) {
    if (num <= 2) {
        return -1;
    } else {
        return fibonacci(num - 1) + factorial(num - 2);
    }
}
```

## 兔子产仔

- 如果一对两个月大的兔子以后每一个月都可以生一对小兔子，而一对新生的兔子出生两个月后才可以生小兔子。也就是说，1月份出生，3月份才可产仔。那么假定一年内没有发生兔子死亡事件，那么1年后共有多少对兔子呢？

1. 第一个月：1 1对小兔子
2. 第二个月：1 1对中兔子
3. 第三个月：2 1对大兔子 1对小兔子 
4. 第四个月：3 1对大兔子 1对中兔子 1对小兔子
5. 第五个月：5 2对大兔子 1对中兔子 2对小兔子
6. 第六个月：8 3对大兔子 2对中兔子 3对小兔子
7. 第六个月：13 5对大兔子 3对中兔子 5对小兔子
8. 。。。

- 函数关系为：F(n) = F(n-1) + F(n-2)

```java
package recursion;

public class RabbitBirth {
    public static void main(String[] args) {
        System.out.println(birth(12));
    }
    public static int birth(int n) { //n 月份
        if (n == 1 || n == 2) {
            return 1;
        }
        return birth(n - 1) + birth(n - 2);
    }
}
```

## 汉诺塔

[汉诺塔.](https://www.cnblogs.com/dmego/p/5965835.html#:~:text=汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。.%20大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。.%20大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。.%20并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。.%20二．抽象为数学问题：.%20如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数.%20解：（1）n%20%3D%3D,sum%20%3D%201%20次.%20%282%29%20n%20%3D%3D%202.)

<img src="../pictures/20190816222824744.gif" width="500"/>  

- 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
  - (1) 每次只能移动一个盘子;
  - (2) 盘子只能从柱子顶端滑出移到下一根柱子;
  - (3) 盘子只能叠在比它大的盘子上。
- 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子

**解**

- n = 1 时，直接把盘子从 A 移到 C；
- n > 1 时，
  - 先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；
  - 再将最大的盘子从 A 移到 C；
  - 再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        movePlate(A.size(), A, B, C);
    }

    private void movePlate(int size, List<Integer> a, List<Integer> b, List<Integer> c){
        if(size == 1){ //到达最后一个
            int val = a.remove(a.size() - 1);
            c.add(val);
            return;
        }

        movePlate(size - 1, a, c, b);  //子问题：
        c.add(a.remove(a.size() - 1)); //
        movePlate(size - 1 , b, a, c); //子问题：
    }
}
```

- 错解：违背小盘子只能在大盘子上

```java
public class FactorialTest {
    public static void main(String args[]) {
        List<Integer> A = new ArrayList<Integer>();
        List<Integer> B = new ArrayList<Integer>();
        List<Integer> C = new ArrayList<Integer>();
        for (int i = 0; i < 10; i++) {
            A.add(i);
        }
        System.out.println(A);
        hannotTower(A, B, C, 1);
        System.out.println(B);
        System.out.println(C.toString());
    }

    public static void hannotTower(List<Integer> A, List<Integer> B, List<Integer> C, int key) {
        //当A的长度为1时，即停止
        if (A.size() == 0) {
            return;
        }
        //初始化C
        if (key-- > 0) {
            C.add(A.remove(A.size() - 1));
        }
        //当C的底盘大于A的顶时，直接将A的顶放入C，
        //否则将C的全部放入B，再将A的放入C，然后将B的再放入C
        move(A, B, C);
        hannotTower(A, B, C, key);
    }

    public static void move(List<Integer> A, List<Integer> B, List<Integer> C) {
        if (C.get(0) > A.get(A.size() - 1)) {
            C.add(A.remove(A.size() - 1));
        } else {
            while (C.size() > 0) {
                B.add(C.remove(C.size() - 1));
            }
            C.add(A.remove(A.size() - 1));
            while (B.size() > 0) {
                C.add(B.remove(B.size() - 1));
            }
        }
    }
}
```

# 查找算法

## 平均查找长度

$$
ALG=\sum^n_{i=1}P_iC_i
$$

> 二分查找的平均查找长度：长度为12的有序表采用顺序存储结构，在等概率的条件下：
>
> <img src="../pictures/平均查找长度.png" width="600"/> 
>
> - 查找成功：
>
> $$
> (1*2 + 2*2 + 3 * 4 + 4*5) \div 12 = \frac{37}{12}
> $$
>
> - 查找失败：
>
> $$
> (3 * 3 + 4 * 10) \div 13  = \frac{49}{13}
> $$

## 顺序查找

```java
public static int search(int arr[],int data){
    for(int i = 0;i < arr.length;i++){
        if(arr[i] == data){
            return i;
        }
    }
    return -1;
}
```

## 二分查找

- 要求有序的线性结构，需要先排序

```java
package search;

import java.util.Arrays;

public class halfSearchDemo {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 2, 24, 34, 23, 12, 5, 45, 23, 13, 34, 12, 34, 78, 567, 23, 4, 5, 23};
        System.out.println(arr[search(arr, 78, 0, arr.length - 1)]);
    }

    public static int search(int[] arr, int data, int start, int end) {
        //先进行排序
        Arrays.sort(arr);
        int mid;
        while (start <= end) {
            mid = (start + end) / 2;
            if(arr[mid]==data){
                return mid;
            }else if (arr[mid] > data){
                end = mid -1;
            } else {
                start = mid +1;
            }
        }
        return -1;
    }
}
```

```java
package search;

import java.util.Arrays;

public class halfSearchDemo {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 2, 24,34,23,12,5,45,23,13,34,12,34,78,567,23, 4, 5, 23};
        System.out.println(arr[search(arr, 78, 0, arr.length - 1)]);
    }

    public static int search(int[] arr, int data, int start, int end) {
        if(start >= end && arr[start] != data){
            return -1;
        }

        //先进行排序
        Arrays.sort(arr);
        int mid = (start + end) / 2;
        if (arr[mid] == data) {
            return mid;
        } else {
            if (arr[mid] >data) {
                return search(arr, data, start, mid);
            } else {
                return search(arr, data, mid + 1, end);
            }
        }
    }
}
```

# 排序算法

<img src="../pictures/Snipaste_2023-02-18_12-07-52.png" width="700"/>  

| 排序算法 | 平均时间复杂度 | 最好           | 最坏           | 空间复杂度   | 稳定性 |
| -------- | -------------- | -------------- | -------------- | ------------ | ------ |
| 冒泡排序 | $O(n^2)$       | $O(n)$         | $O(n^2)$       | $O(1)$       | 稳定   |
| 快速排序 | $O(n\log_2^n)$ | $O(n\log_2^n)$ | $O(n^2)$       | $O(log_2^n)$ | 不稳定 |
| 插入排序 | $O(n^2)$       | $O(n)$         | $O(n^2)$       | $O(1)$       | 稳定   |
| 希尔排序 | $O(n^{1.3})$   | $O(n)$         | $O(n\log_2^n)$ | $O(1)$       | 不稳定 |
| 选择排序 | $O(n^2)$       | $O(n^2)$       | $O(n^2)$       | $O(1)$       | 不稳定 |
| 堆排序   | $O(n\log_2^n)$ | $O(n\log_2^n)$ | $O(n\log_2^n)$ | $O(1)$       | 不稳定 |
| 归并排序 | $O(n\log_2^n)$ | $O(n\log_2^n)$ | $O(n\log_2^n)$ | $O(n)$       | 稳定   |
| 桶排序   | $O(n+k)$       | $O(n+k)$       | $O(n+k)$       | $O(n+k)$     | 稳定   |
| 计数排序 | $O(n+k)$       | $O(n+k)$       | $O(n+k)$       | $O(k)$       | 稳定   |
| 基数排序 | $O(nk)$        | $O(nk)$        | $O(nk)$        | $O(n+k)$     | 稳定   |

## 交换类

### 冒泡排序

- 冒泡排序：从前往后把大元素往后调（或 从后向前把小元素往前调）。
- 时间复杂度：$T(n)=O(n^2)$。

<img src="../pictures/20200104104719116.gif" width="500"/>  

- 缺点：一般最后一个数只能换一次位置。

```java
package sort;

public class BubblingDemo {
    public static void main(String[] args) {
        double[] arr = {2, 3, 1};
        BubblingDemo bubblingDemo = new BubblingDemo();
        bubblingDemo.bubblingSort(arr); //2,1,3
    }

    public void bubblingSort(double[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    double temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
```

### 快速排序

#### 基本快排

1. 将序列变成两个部分：序列左边全部小于一个数，序列右面全部大于一个数。这个数在这个序列中是可以随机取的，通常取最左边的那个数。
2. 然后，利用递归的思想再将左序列当成一个完整的序列再进行排序，同样把序列的右侧也当成一个完整的序列进行排序。

<img src="../pictures/Snipaste_2023-02-17_20-52-05.png" width="900"/>  
<img src="../pictures/Snipaste_2023-02-17_20-53-25.png" width="800"/>  
<img src="../pictures/Snipaste_2023-02-17_20-54-02.png" width="800"/>  

```java
package sort;

public class QuickSortDemo {
    public static void main(String[] args) {
        int[] arr = {2, 9, 2, 3, 7, 11, 4};
        quick(arr, 0, arr.length - 1);
        for (int i : arr) {
            System.out.println(i);
        }
    }

    public static void quick(int[] arr, int left, int right) {
        //选择排序的范围 下标
        int low = left;
        int high = right;

        //判断是否到达停止条件，是否越界
        if (low > high) {
            return;
        }

        int point = arr[low]; //额外空间，要求左边都小于他，同时右边都大于

        //完成一轮大小互换：将小于point的都放在左边，大于的放在右边
        while (low < high) {
            //找到的第一个小于point的则退出循环，并将该数覆盖arr[low]，即目前point所在的位置。
            //否则继续查找。
            while (low < high && arr[high] >= point) {
                high--;
            }
            arr[low] = arr[high];
            //找到的第一个大于point的则退出循环，并将该数覆盖arr[high]（此时的arr[high]在被覆盖前已经覆盖了之前的arr[low]）。
            //否则继续查找。
            while (low < high && arr[low] <= point) {
                low++;
            }
            arr[high] = arr[low];
        }

        //重置
        arr[low] = point;

        //将一轮大小互换之后的，继续按point分段再次排序，直到达到停止条件。 
        quick(arr, left, low - 1);
        quick(arr, low + 1, right);
    }
}
```

#### 双轴快排

- 单轴很多时候可能会遇到较差的情况就是当前元素可能是最大的或者最小的，这样子元素就没有被划分区间，快排的递推T(n)=T(n-1)+O(n)从而为O(n^2).
- 双轴就是选取两个主元素理想将区间划为3部分，这样不仅每次能够确定元素个数增多为2个，划分的区间由原来的两个变成三个，最坏最坏的情况就是左右同大小并且都是最大或者最小，但这样的概率相比一个最大或者最小还是低很多，所以双轴快排的优化力度还是挺大的。

**比privot1小的在privot1左侧，比privot2大的在privot2右侧，在privot1和privot2之间的在中间。**

<img src="../pictures/Snipaste_2023-02-17_22-05-27.png" width="800"/>  

**k交换过程**

<img src="../pictures/Snipaste_2023-02-17_22-10-37.png" width="800"/>  
<img src="../pictures/Snipaste_2023-02-17_22-11-12.png" width="800"/>  

**收尾工作**

<img src="../pictures/Snipaste_2023-02-17_22-12-20.png" width="800"/>  

```java
package sort;

public class DoubleQuickSortDemo {
    public static void main(String[] args) {
        int[] arr = {2, 3, 4, 56, 72, 1, 2, 4, 3, 21};
        doubleQuick(arr, 0, arr.length - 1);
        for (int i : arr) {
            System.out.println(i);
        }
    }

    public static void doubleQuick(int arr[], int start, int end) {
        //非法参数直接停止
        if (start > end) {
            return;
        }

        //使picot1储存最左边的值，pivot2储存最右边的值，同时保证pivot1<pivot2。
        if (arr[start] > arr[end]) {
            swap(arr, start, end);
        }
        int pivot1 = arr[start];
        int pivot2 = arr[end];

        int left = start;
        int right = end;
        int k = left + 1;
        while (k < right) {
            if (arr[k] <= pivot1) {//左侧交换
                swap(arr, ++left, k++);
            } else if (arr[k] <= pivot2) { //中间值则跳过
                k++;
            } else { //右侧交换
                // 如果大于pivot2则继续查找，直到k
                while (arr[right] >= pivot2) {
                    if (right-- == k) {
                        break;
                    }
                }
                //如果超限，则停止
                if (k >= right) {
                    break;
                }
                //小于pivot2的与k位置互换
                swap(arr, k, right);
            }

            //
            swap(arr, start, left);
            swap(arr, end, right);

            //分段排序
            doubleQuick(arr, start, left - 1);
            doubleQuick(arr, left + 1, right - 1);
            doubleQuick(arr, right + 1, end);
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 插入类

### 直接插入排序

- 时间复杂度$T(n) = O(n^2)$：遍历比较每次$O(n)$，交换每次$O(n)$。

<img src="../pictures/Snipaste_2023-02-18_12-11-44.png" width="800"/>  

```java
package sort;

public class DirectSortDemo {
    public static void main(String[] args) {
        int[] arr = {1, 6, 3, 2, 3, 4};
        directInsert(arr);
        for (int i : arr) {
            System.out.println(i);
        }
    }

    public static void directInsert(int[] arr) {
        int temp = 0;
        for (int i = 0; i < arr.length; i++) { //排序的位置
            temp = arr[i];
            for (int j = i - 1; j >= 0; j--) { //一轮排序
                if (arr[j] > temp) {
                    arr[j + 1] = arr[i];
                    arr[j] = temp;
                } else {
                    break;
                }
            }
        }
    }
}
```

### 希尔排序

- 数据量和有序性：使得序列前后之间小的尽量在前面，大的尽量在后面，进行若干次的分组别计算，最后一组即是一趟完整的直接插入排序。
- 希尔排序：首先将序列分割(非线性分割)，按照某个数取模，各组分别进行直接插入排序。每次插入都会使得序列变得更加有序，代价越来越小。
- 最坏情况下：时间复杂度：$T(n)=O(n\log_2^n)$。 

<img src="../pictures/Snipaste_2023-02-18_12-42-30.png" width="800"/>  

```java
public class HillTest {
    public static void hill(int[] arr) {
        for (int i = arr.length; i >= 1; i /= 2) { //分组排序
            for (int j = i; j < arr.length; j++) { 
                for (int k = j - i; k >= 0; k -= i) { //k和i之间保证始终相差i的倍数
                    if (arr[k] > arr[i]) {
                        int temp = arr[i];
                        arr[i] = arr[k];
                        arr[k] = temp;
                    }
                }
            }
        }
    }
}
```

## 选择类

### 简单选择排序

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。
3. 以此类推，直到所有元素均排序完毕。

- 时间复杂度为：$T(n)=O(n^2)$。

```java
public static void selectSort(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        int minIndex = i; //最小值相应的索引
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }
}
```

### 堆排序

<img src="../pictures/Snipaste_2023-02-19_10-33-12.png" width="800"/>  

<img src="../pictures/Snipaste_2023-02-19_10-35-51.png" width="800"/>  
<img src="../pictures/Snipaste_2023-02-19_10-36-29.png" width="800"/>  

```java
package sort;

import java.util.Arrays;

public class HeadSortDemo {
    public static void main(String[] args) {
        heapSort(new int[]{1, 2, 9, 5, 7, 2, 34, 24, 0, 5, 3, 2});
    }

    public static void shiftDown(int[] arr, int curIndex, int length) {
        //获取子结点的坐标
        int leftIndex = curIndex * 2 + 1;
        int rightIndex = curIndex * 2 + 2;
        //比较结点大小并交换：使得右子结点>左子结点>当前结点 小根堆
        //因为是使用数组储存，所以下标为0~length-1
        if (leftIndex >= length) {//判断是否超过范围，即当前结点是否为叶子结点
            return;
        } else if (rightIndex < length && arr[rightIndex] < arr[curIndex] && arr[rightIndex] < arr[leftIndex]) { //判断是否存在右子结点，以及比较结点大小
            int temp = arr[rightIndex];
            arr[rightIndex] = arr[curIndex];
            arr[curIndex] = temp;
            shiftDown(arr, rightIndex, length);
        } else if (arr[leftIndex] < arr[curIndex]) {
            int temp = arr[leftIndex];
            arr[leftIndex] = arr[curIndex];
            arr[curIndex] = temp;
            shiftDown(arr, leftIndex, length);
        }
    }

    public static void createHeap(int[] arr) {
        //排序为小根堆
        for (int i = arr.length / 2; i >= 0; i--) {
            //arr.length / 2 堆的非叶子结点数 = 堆的总长度 / 2
            shiftDown(arr, i, arr.length);
        }
    }

    public static void heapSort(int arr[]) {
        int[] tempArr = new int[arr.length]; //临时存放结果的空数组
        createHeap(arr);
        //将（小根堆）堆顶元素放入tempArr，依次将末尾元素置为堆顶
        for (int i = 0; i < arr.length; i++) {
            tempArr[i] = arr[0];
            arr[0] = arr[arr.length - 1 - i];
            shiftDown(arr, 0, arr.length - i);
        }
        //将排序好的结果放入arr中
        for (int i = 0; i < arr.length; i++) {
            arr[i] = tempArr[i];
        }
        System.out.println("堆排序：" + Arrays.toString(arr));
    }
}
```

## 归并排序 Meger

### 基本实现

- 时间复杂度$T(n)=O(n\log_2^n)$。
- 归并排序：基于分治进行归并：二路归并、多路归并。
   - 非递归：局部—>整体。
   - 递归：整体—>局部—>整体。 
- 求序列中的逆序数个数：归并排序、树状数组。


<img src="../pictures/Snipaste_2023-02-19_17-31-05.png" width="800"/>  

```java
public static void mergeSort(int[] arr, int left, int right) {
    int mid = (left + right) / 2; //分为左右两个区间进行分治
    if (left < right) {
        mergeSort(arr, left, mid); //处理左区间
        mergeSort(arr, mid + 1, right); //处理右区间
        merge(arr, left, mid, right); //合并
    }
}

public static void merge(int[] arr, int left, int mid, int right) {
    int leftIndex = left, rightIndex = mid + 1; //分别对mid左边和右边进行处理
    int[] tempArr = new int[right - left + 1]; //临时存放的空数组
    int tempIndex = 0;
    //进行排序，从小到大
    while (leftIndex <= mid && rightIndex <= right) {
        if (arr[leftIndex] <= arr[rightIndex]) {
            tempArr[tempIndex++] = arr[leftIndex++];
        } else {
            tempArr[tempIndex++] = arr[rightIndex++];
        }
    }
    //对剩下越界的分别进行赋值，加入到tempArr的末尾
    while (leftIndex <= mid) {
        tempArr[tempIndex++] = arr[leftIndex++];
    }
    while (rightIndex <= right) {
        tempArr[tempIndex++] = arr[rightIndex++];
    }
    //将排序好的tempArr重新赋值给arr相应下标范围
    for (int i = 0; i < tempIndex; i++) {
        arr[left + i] = tempArr[i];
    }
}
```

### 逆序数

- 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对
   - 比如`3 2 1`.看3 ，有2 1在后面，看2 有1在后面有`3`个逆序数 
- 变化过程只需要注意一些相对变化即可也就是把每个归并的过程逆序数发生变化进行累加，那么最终有序的那个序列为止得到的就是整个序列的逆序数
   - 可以发现每次归并过程中，当且仅当右侧的数提前放到左侧，而左侧还未放置的个数就是该元素减少的逆序个数
   
```java
package sort;

import java.util.Arrays;

public class InversionNumberDemo {
    public static void main(String[] args) {
        int[] arr = {2,8,1,3,7,4,5,0};
        InversionNumberDemo inversionNumberDemo = new InversionNumberDemo();
        System.out.println(inversionNumberDemo.getInversionNumber(arr, 0, arr.length - 1));
        System.out.println(Arrays.toString(arr));
    }

    public int getInversionNumber(int[] arr, int left, int right) {
        if (left > right && right < 2) {
            return 0;
        }

        int mid = (left + right) / 2;
        int countAll = 0, countLeft = 0, countRight = 0;

        if (left < right) {
            countLeft += getInversionNumber(arr, left, mid);
            countRight += getInversionNumber(arr, mid + 1, right);
            countAll += merge(arr, left, mid, right);
        }
        return countAll + countLeft + countRight;
    }

    public int merge(int[] arr, int left, int mid, int right) {
        int count = 0;
        int leftIndex = left, rightIndex = mid + 1;
        int[] tempArr = new int[right - left + 1];
        int tempIndex = 0;

        while (leftIndex <= mid && rightIndex <= right) {
            if (arr[leftIndex] < arr[rightIndex]) {
                tempArr[tempIndex++] = arr[leftIndex++];
            } else if (arr[leftIndex] == arr[rightIndex]) {
                tempArr[tempIndex] = arr[rightIndex++];
                count += mid - leftIndex;
            } else {
                tempArr[tempIndex++] = arr[rightIndex++];
                count += mid - leftIndex + 1;
            }
        }

        while (leftIndex <= mid) {
            tempArr[tempIndex++] = arr[leftIndex++];
        }
        while (rightIndex <= right) {
            tempArr[tempIndex++] = arr[rightIndex++];
        }

        for (int i = 0; i < tempArr.length; i++) {
            arr[left + i] = tempArr[i];
        }
        return count;
    }
}
```

## 桶类

### 桶排序

- 桶排序：用空间换取时间，将待排序的序列分到若干个桶中，每个桶内的元素再进行个别排序。 

1. 对排序元素进行整除，放入相应的桶中，选择的除数应尽量使各个桶内的元素数量均匀。

2. 对各个桶内部选择排序算法进行排序。

3. 按桶的顺序将各个排序之后的桶合并。

<img src="../pictures/Snipaste_2023-05-28_17-17-55.png" width="600"/>   

> 假设每个桶内部使用的排序算法为快速排序：
>
> - 每个桶内的时间复杂度：$T(n)=\frac{n}{m} \log_2^{\frac{n}{m}}$。
>
> - m个桶的总时间复杂度为`m * (n/m)log(n/m)`=`n (log n-log m)`.
> - 最终桶排序的时间复杂度为：`O(n)+O(n*(log n- log m))`=`O(n+n*(log n -log m))` 其中m为桶的个数。我们有时也会写成O(n+c),其中c=n*(log n -log m);

```java
public static void bucketSort(int[] arr) {
    List[] bukects = new ArrayList[5]; //使用5个桶 List
    //初始化桶
    for (int i = 0; i < bukects.length; i++) {
        bukects[i] = new ArrayList<Integer>();
    }
    //将待排序序列放入桶中
    for (int i = 0; i < arr.length; i++) {
        int index = arr[i] / 10; // 入桶的规则
        bukects[index].add(arr[i]);
    }
    //每个桶内部排序
    for (int i = 0; i < bukects.length; i++) {
        bukects[i].sort(null); //快排
        for (int j = 0; j < bukects[i].size(); j++) {
            System.out.println(bukects[i].get(j) + " ");
        }
    }
}
```

#### 计数排序

- 计数排序：牺牲空间换取时间，对一定范围内的整数排序时，时间复杂度为$T(n)=Ο(n+k)$，（k是整数的范围）。当$O(k)>O(n\log_2^n)$的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是$T(n)=O(n\log_2^n)$）。
- 当数据范围波动不是很大，数据相对比较集中，即最大值和最小值相差不大的。

<img src="../pictures/20200808091520863.gif" width="800"/>  

```java
public static void count(int[] arr) {
    //存放最小值和最大值
    int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
        if (arr[i] > max) {
            max = arr[i];
        }

    }
    //桶内计数：count[] 内存放的是该数存在的次数
    int count[] = new int[max - min + 1]; //计算出桶的数量为：max - min + 1；对每个数放一个桶
    for (int i = 0; i < arr.length; i++) {
        count[arr[i] - min]++; //相应下标的数的个数增加
    }
    //将计数排序的放入arr原数组
    int index = 0; //放入arr时的下标
    for (int i = 0; i < count.length; i++) {
        while (count[i]-- > 0) { //存在1个以上的该数，则依次取出放入原数组arr
            arr[index++] = i + min; //
        }
    }
}
```

### 基数排序

- 基数排序（卡片排序）：多次利用计数排序，基数排序并不是将一个整体分配到一个桶中，而是将自身拆分成一个个组成的元素，每个元素分别顺序分配放入桶中、顺序收集。从前往后（或从后往前）对每个位置都进行过分配、收集后。
- MSD：最高位优先(Most Significant Digit first)，从左往右。
- LSD：最低位优先(Least Significant Digit first)，从右往左。
- 要保证和相同位进行比较:
  - 如果是int等数字类型需要保证从右往左(从低位到高位)保证对齐
  - 如果是字符类型的话需要从左往右(从高位到低位)保证对齐。

<img src="../pictures/Snipaste_2023-02-20_00-38-08.png" width="600"/>  

- 一方面基数排序可能很多时候处理的是字符型的数据，不方便放入某个桶中，另一方面如果数字很大，不方便直接放入桶中。并且基数排序并不需要交换，也不需要比较，就是多次分配、收集得到结果。

<img src="../pictures/Snipaste_2023-02-20_10-17-57.png" width="800"/>  
<img src="../pictures/Snipaste_2023-02-20_10-19-03.png" width="700"/>  

#### 数字类型

- 无论是最高位优先法还是最低位优先法进行遍历需要保证数字各位、十位、百位等对齐，这里我使用最低位优先法从个位开始向上。
- 数字类型的基数排序需要十个桶(0-9)，如果使用二维数组，第一维度长度为10表示十个数字，第二个维度为数组长度，用来存储数字(因为最坏情况可能当前位数字一样)，浪费内存空间极其严重。可以使用List或者Queue替代，这里就用List了。
- 具体实现要先找到最大值确定最高多少位，用来进行遍历时候确认。
- 收集的时候借助一个自增参数遍历收集。
- 每次收集完毕十个桶(bucket)需要清空待下次收集。

```java
package sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CardinalSortDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,34,342,3423,34,23,34,12,4445,234};
        cardinal(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void cardinal(int[] arr) {
        //桶
        List<Integer>[] bukects = new ArrayList[10]; //0~9
        for (int i = 0; i < bukects.length; i++) {
            bukects[i] = new ArrayList<Integer>();
        }

        int max = Integer.MIN_VALUE; //最大值 用于确定while循环的最大次数
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        int divideNum = 1; //分割对应位的数字 1、10、100、...
        while (max > 0) {
            for (int i = 0; i < arr.length; i++) {
                bukects[(arr[i] / divideNum) % 10].add(arr[i]);
            }
            divideNum *= 10; //计算位数
            max /= 10; //计算循环次数
            int index = 0;
            for (int i = 0; i < bukects.length; i++) {
                for (int j = 0; j < bukects[i].size(); j++) {
                    arr[index++] = bukects[i].get(j);
                }
                bukects[i].clear(); //清空，等待下个位的数字使用
            }
        }
    }
}
```

#### 等长字符串

```java
package sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CardinalSortEqualStringDemo {
    public static void main(String[] args) {
        String[] arr = {"asda", "hscs", "1122", "+12s", "aacs"};
        cardinal(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void cardinal(String[] arr) {
        List<String>[] buckets = new ArrayList[128]; //ASCII码对应
        for (int i = 0; i < buckets.length; i++) {
            buckets[i] = new ArrayList<>();
        }
        int length = arr[0].length(); //等长字符串
        int temp = length;
        while (length > 0) {
            for (int i = 0; i < arr.length; i++) {
                buckets[arr[i].charAt(temp - length)].add(arr[i]);
            }
            int index = 0;
            for (int i = 0; i < buckets.length; i++) {
                for (int j = 0; j < buckets[i].size(); j++) {
                    arr[index++] = buckets[i].get(j);
                }
                buckets[i].clear();
            }
            length--;
        }
    }
}
```

##### 空间优化

#### 非等长字符串

<img src="../pictures/Snipaste_2023-02-20_13-09-48.png" width="1000"/>  
<img src="../pictures/Snipaste_2023-02-20_13-10-37.png" width="1000"/>  

```java
package sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CardinalSortStringDemo {
    public static void main(String[] args) {
        String[] arr = {"asda", "23wad", "asxcs", "sad", "dvea", "=d", "bs"};
        cardinal(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void cardinal(String[] arr) {
        int maxLength = -1; //最长的字符串
        for (String str : arr) {
            if (maxLength < str.length())
                maxLength = str.length();
        }
        //先进行一次按长度的基数排序
        List<String>[] lengthBuckets = new ArrayList[maxLength + 1]; //由长度分桶
        for (int i = 0; i < lengthBuckets.length; i++) {
            lengthBuckets[i] = new ArrayList<String>();
        }
        for (String str : arr) {
            lengthBuckets[str.length()].add(str);
        }
        int index = 0;
        for (List<String> lengthBucket : lengthBuckets) {
            for (String str : lengthBucket) {
                arr[index++] = str;
            }
        }
        //重新利用字符来装桶 此时的arr已经按照长度从短到长排序
        List<String>[] wordBuckets = new ArrayList[128]; //由字符来分桶
        for (int i = 0; i < wordBuckets.length; i++) {
            wordBuckets[i] = new ArrayList<String>();
        }
        int startIndex = arr.length;
        for (int i = maxLength; i > 0; i--) {//按照长度进行相应的等长字符基数排序
            startIndex -= lengthBuckets[i].size(); //确定循环的次数
            for (int j = startIndex; j < arr.length; j++) {
                wordBuckets[arr[j].charAt(i - 1)].add(arr[j]);
            }
            index = startIndex;
            for (List<String> wordBucket : wordBuckets) {
                for (String str : wordBucket) {
                    arr[index++] = str;
                }
                wordBucket.clear();
            }
        }
    }
}
```

# 概率算法

1. 将问题转化为相应的几何图形，其面积S，计算其占面积S的部分面积S1
2. 向几何图形中随机散点，统计S和S1中的点数，从而得到结果
3. 若未达到所需的精度，则继续执行步骤2的操作；到达则输出。

**常见**

1. 数值概率算法
2. 蒙特卡罗算法
3. 拉斯维加斯算法
4. 舍伍德算法

## 蒙特卡罗Π算法思想

1. 均匀撒点：使用Math.random()获取0~1的伪随机数坐标[x,y]
2. 区域判断：距离坐标原点的距离小于等于1，`x*x + y*y<=1`

```java
public static double getPI(int n) {
    double x, y; //坐标
    int sum = 0; //在区域内的次数
    for (int i = 0; i < n; i++) {
        x = Math.random();
        y = Math.random();
        //圆形公式：x^2 + y^2 = 1
        if (x * x + y * y <= 1) {
            sum++;
        }
    }
    //因为是1/4的扇形区域[0~1]，需要乘以4
    return 4.0 * sum / n;
}
```

# 动态规划

# 分治界限

- 分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。
- 将父问题分解为子问题同等方式求解，这和递归的概念很吻合，所以在分治算法通常以递归的方式实现(当然也有非递归的实现方式)。分治算法的描述从字面上也很容易理解，分、治其实还有个合并的过程：
  - 分(Divide)：递归解决子问题(到终止层或者可以解决的时候停下)
  - 治(Conquer)：递归求解，如果问题够小直接求解。 即：if条件
  - 合并(Combine)：将子问题的解构建父类问题    
- 一般分治算法在正文中分解为两个即以上的递归调用，并且子类问题一般是不想交的(互不影响)。当求解一个问题规模很大很难直接求解，但是规模较小的时候问题很容易求解并且这个问题并且问题满足分治算法的适用条件，那么就可以使用分治算法。

**使用时应满足的条件(特征)**

1. 原问题规模通常比较大，不易直接解决，但问题缩小到一定程度就能较容易的解决。
2. 问题可以分解为若干规模较小、求解方式相同(似)的子问题。且子问题之间求解是独立的互不影响。
3. 合并问题分解的子问题可以得到问题的解。

**具体应用**

1. 二分搜索
2. 快速排序
3. 归并排序（逆序数）
4. 最大子序列求和
5. 最近点对

## 寻找假币

- 从30个硬币中找到1个假币，假币的重量不同。

```java
package divide;

import java.util.Scanner;

public class CounterfeitCoin {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] arr = new int[30];
        int counteritCoin = Integer.parseInt(scanner.next());
        for (int i = 0; i < arr.length; i++) {
            if (i == counteritCoin) {
                arr[i] = 2;
            } else {
                arr[i] = 1;
            }
        }
        int index = find(arr, 0, arr.length - 1);
        System.out.println("假币(" + arr[index] + ")的位置：" + index);
    }

    public static int find(int[] coins, int start, int end) {
        if (start + 1 == end) { //终止条件
            return coins[start] > coins[end] ? start : end;
        }
        int startSum = 0, endSum = 0; //两段硬币的质量
        //计算两边重量
        //判断当前硬币数量的奇偶
        int mid = (start + end) / 2; //中间下标，若奇数：此时前半段比后半段多1个。
        if ((start - end + 1) % 2 == 0) { //偶数
            for (int i = start; i <= mid; i++) {
                startSum += coins[i];
            }
            for (int i = mid + 1; i <= end; i++) {
                endSum += coins[i];
            }

            if (startSum > endSum) {
                return find(coins, start, mid);
            } else {
                return find(coins, mid + 1, end);
            }
        } else { //奇数
            for (int i = start; i <= mid; i++) {
                startSum += coins[i];
            }
            for (int i = mid + 1; i <= end; i++) {
                endSum += coins[i];
            }
            //奇数0~4时：对于前半段：0~2 可能 3或4
            //对于后半段：3~4 可能 2或3 补充1 3或4 4或5
            endSum += coins[end]; //补充前半段多的。
            if (startSum > endSum) {
                return find(coins, start, mid);
            } else {
                return find(coins, mid + 1, end);
            }
        }
    }
}
```

# 数论

## 基本数学问题

### 多项式计算

#### 一元多项式求值

- 使用递归：将多项式转化为(...(nx + nx)x + n)x+..+n

```java
/**
    * @param arr 存放系数
    * @param x   对应的x值
    * @return 计算结果
    * @Description 只能计算排好顺序的多项式 从x^0到x^n 那么
    */
public static double getResultOne(double[] arr, double x) {
    int index = arr.length - 1; //当前计算的项
    double result = arr[index--]; //先获取最高项的系数
    for (; index >= 0; index--) {
        result = result * x + arr[index]; //计算 逐步直到x^0即：arr[0]
    }
    return result;
}
```

#### 二元多项式求值

- 二维数组存放二元多项式，以此类推：n元使用n维数组

|      | x^0  | x^1  | ...  | x^n  |
| :--: | :--: | :--: | :--: | :--: |
| y^0  |      |      |      |      |
| y^1  |      |      |      |      |
| ...  |      |      |      |      |
| y^n  |      |      |      |      |

```java
public static double getResultTwo(double arr[][], double x, double y) {
    double result = 0; //总的结果 x
    double tempResult = 0;//内部暂时结果 y
    boolean isHaveResult = false; //表示result还没有初始值
    boolean isHaveTemp = false; //表示tempResult还没有初始值
    for (int i = arr.length - 1; i >= 0; i--) { //x
        for (int j = arr[i].length - 1; j >= 0; j--) { //y
            if (arr[i][j] != 0) { //先计算x内部的系数y
                if (!isHaveTemp) {
                    tempResult = arr[i][j];
                    isHaveTemp = true;
                } else {
                    tempResult = tempResult * y + arr[i][j];
                }
            }
        }
        if (isHaveTemp) {
            if (!isHaveResult) {
                result = tempResult;
            } else {
                result = result * x + tempResult;
                isHaveTemp = false; //重置
            }
        }
    }
    return result;
}
```

#### 一元多项式乘法

```java
public static double[] getResultMul(double[] A, double[] B) {
    double[] result = new double[A.length + B.length - 1]; //相乘最高项的幂为A和B的最高项幂的和

    for (int i = A.length - 1; i >= 0; i--) {
        for (int j = B.length - 1; j >= 0; j--) {
            result[i + j] += A[i] * B[j]; //注意是+=
        }
    }

    return result;
}
```

#### 一元多项式除法

```java

```

### 随机数

- Math.random() 返回0~1之间的随机数

### 复数运算

### 割圆术

- 假设一个圆的半径为1，在其内部内接一个正六边形，边长为y：
- 由几何可知y=1，则圆周长近似于L=6*y=6；
- 则Π=L/2=n*y/2=3。

```java

```

## 数论

### 完全数

**完全数概念：** 完全数等于其所有因子的和。即：所有可以整除该数的数，而不包括该数本身。

```java
/**
* @param n 寻找的范围
* @description 找出所有符合条件的完全数，同时输出其因子
*/
public void perfectNumber(int n) {
    if (n <= 2) {
        throw new RuntimeException("不符合正确的范围(>=3)");
    }
    List<Integer> perfectNumbers = new ArrayList<>();
    List<Integer>[] factors = new List[n];
    //从第一个完全数6开始，对每个数进行操作
    for (int i = 6; i <= n; i++) {
        Queue<Integer> queue = new LinkedList<>();
        //被整除的因数不包括其本身，但必然包括1
        int facSum = 1; //统计因子的和
        queue.add(1);
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                queue.add(j);
                facSum += j;
            }
        }
        if (facSum == i) {
            perfectNumbers.add(facSum);
            factors[i] = new ArrayList<>(queue);
        }
    }
    for (int num : perfectNumbers) {
        System.out.print(num + "\t：");
        for (int fac : factors[num]) {
            System.out.print(fac + " ");
        }
        System.out.println();
    }
}
```

### 亲密数

- 如果整数a的因子和大于整数b，整数b的因子和等于整数a，因子不包括本身，且a不等于b，则称a和b为亲密数。
- 因子：一般可以确定为包括1，且最大的因子最多为：n/2+1

```java
/**
* @param n 要找其亲密数的数
* @return -1 找不到，其他找到
* @descritption 找到对应的亲密数
*/
public int findIntimacy(int n) {
    //计算n的因子和
    int facSumA = 0;
    for (int i = 1; i < n; i++) {
        if (n % i == 0)
            facSumA += i;
    }
    //查看n的因子和的因子和是否等于n
    int facSumB = 0;
    for (int i = 1; i < facSumA; i++) {
        if (facSumA % i == 0)
            facSumB += i;
    }
    if (facSumB == n) {
        return facSumA;
    } else {
        return -1;
    }
}
```

```java
/**
* @param n 寻找范围
* @description 亲密数
*/
public void intimacyNumber(int n) {
    int[] numbers = new int[n]; //存放亲密数
    int index = 0; //下标
    //对于整数a
    for (int i = 1; i <= n; i++) {
        index = 0; //重置
        //算出a的因子和
        int aSum = 1;
        for (int j = 2; j < i / 2 + 1; j++) {
            if (i % j == 0) {
                aSum += j;
            }
        }
        //整数b
        for (int j = 1; j < i; j++) {
            //算出b的因子和
            int bSum = 1;
            for (int k = 2; k < j / 2 + 1; k++) {
                if (j % k == 0) {
                    bSum += k;
                }
            }
            if (aSum == j && bSum == i) {
                //将当前符合条件的亲密数放入numbers
                numbers[index++] = j;
            }
        }
        //如果没有找到对应的亲密数
        if (index == 0) {
            continue;
        }
        System.out.print(i + "：");
        //输出亲密数，index的值比应有的下标多1
        for (int j = 0; j < index; j++) {
            System.out.print(numbers[j] + " ");
        }
        System.out.println();
    }
}
```

### 水仙花数

- 水仙花数是n位正整数（n>=3），他的每个位上的数字的n次幂之和等于其本身。

```java
/**
* @param n 水仙花数的位数
* @description 查找相应位数的水仙花数
*/
public void daffodils(int n) {
    if (n < 3) {
        throw new RuntimeException("输入的位数不符合规范");
    }
    //确定起始和结束
    int start = (int) Math.pow(10, n - 1);
    int end = (int) Math.pow(10, n);
    //开始查找
    int number;//每位数
    int sum;//总和
    int temp;
    for (int i = start; i < end; i++) {
        sum = 0;
        //对每位数进行n次幂
        for (int j = 0; j < n; j++) {
            number = i / (int) Math.pow(10, j) % 10;
            sum += Math.pow(number, n);
        }
        if (sum == i) {
            System.out.println(i);
        }
    }
}
```

### 自守数

1. 以自守数为后几位的两个数相乘的相应后几位仍然是该自守数。如：1**76** `*` 5**76** = 1013**76**
2. n+1位自守数出自n位的自守数
3. 两个n位自守数的和等于10^n+1

- 自守数：5、6、25、76、635、376 ...

```java
/**
* @param n 要判断的数
* @return true 是，false 不是
* @description 判断该数是否为自守数
*/
public boolean isSelfGuarding(int n) {
    int count = 1;//判断是几位的自守数
    while (n / (int) Math.pow(10, count) != 0) {
        count++;
    }
    //判断10^n+1 - 该数的是否为自守数 。。跳不出去
//    if (!isSelfGuarding((int) Math.pow(10, count) + 1 - n)) {
//        return false;
//    }
    //判断第n-1位是否是自守数
    if (count != 1) {
        if (!isSelfGuarding(Integer.parseInt(("" + n).substring(1)))) {
            return false;
        }
    }
    //若以该数为后几位的两个数相乘的后几位为自守数
    int num1 = Integer.parseInt((int) (Math.random() * 10) + "" + n);
    int num2 = Integer.parseInt((int) (Math.random() * 10) + "" + n);
    String result = (num1 * num2) + "";
    String number = result.substring(result.length() - count);
    if (Integer.parseInt(number) == n) {
        return true;
    } else {
        return false;
    }
}
```

**对n位自守数的后面n位数的计算优化**

- 对于个位数与被乘数相乘的积中，用被乘数的后n位与乘数的个位相乘
- 对于十位数与被乘数相乘的积中，用被乘数的后n-1位与乘数的个位相乘
- 以此类推，直到后1位；

```java
/**
 * @param num 要判断的数
 * @return true 是，false 不是
 * @description 判断该数是否为自守数
 */
public boolean isSelfGuarding2(long num) {
    long maxMod = 1; //自守数的位数
    //计算自守数位数，给maxMod赋值
    long temp = num;
    do {
        maxMod *= 10;
        temp /= 10;
    } while (temp > 0);
    //按位数从大到小，直到个位，依次放入faciend中
    long resultFix = 0; //重置用于存放计算的后n位数
    long curMod = maxMod; //当前的位
    long nextMod = 10; //下一位
    long t, n;
    while (curMod > 0) {
        t = num % (curMod * 10);
        n = num % nextMod - num % (nextMod / 10);
        resultFix = (resultFix + t * n) % maxMod;
        curMod /= 10;
        nextMod *= 10;
    }
    //判断是否与相乘之后的后n位数相等。
    if (num == resultFix) {
        return true;
    } else {
        return false;
    }
}
```

### 最大公约数

#### 欧几里得算法

**辗转相除法**

- **两个整数的最大公约数等于其中较小的数和两数的相除余数的最大公约数**

1. 对于两自然数m、n, m >n
2. r = m % n 
3. if ( r == 0 ) 则n为最大公约数
4. else{m = n , n = r}，重复2.3.步骤

**原理：**

- a可以表示成a = kb + r（a，b，k，r皆为正整数，且r不为0）
- 假设d是a,b的一个公约数，记作d/a,d/b，即a和b都可以被d整除。
- 而r = a - kb，两边同时除以d，r/d=a/d-kb/d，由等式右边可知m=r/d为整数，因此d|r
- 因此d也是b,a mod b的公约数。
- **因(a,b)和(b,a mod b)的公约数相等**，则其最大公约数也相等，得证。

```java
public int gcd(int a,int b){
    if( a % b == 0)
        return b;
    return gcd(b,a % b);
}
```

```java
/**
* @param a
* @param b
* @return result 最大公约数
* @description 计算最大公约数
*/
public int euclidean(int a, int b) {
    int big, small, result;
    //确定较大数
    if (a > b) {
        big = a;
        small = b;
    } else {
        big = b;
        small = a;
    }
    while ((result = big % small) != 0) {
        big = small;
        small = result;
    }
    return small;
}
```

#### stein算法 更相减损术

- **可半者半之，不可半者，副置分母子之数，以少减多，更相减损，求其等也，以等数约之**。
- 即如果两个整数a、b都能被c整除,那么a与b的差也能被C整除。
- 如果两个整数都是偶数，就使用2约简，直到两个整数不再都是偶数，然后执行第2步。如果两个整数不都是偶数，则直接执行第2步。用较大的数减去较小的数，如果得到的差恰好等于较小的数，则停止。否则，对较小的数和差值重复这个过程。第1步中约掉的若干个2和第2步中得到的差的乘积为原来两个整数的最大公约数。

1. 设置$An=|A|、Bn=|B|、Cn=1和n=1$
2. 如果$An=Bn,那么An(或Bn)*Cn$是最大公约数,算法结束
3. 如果An=0，Bn是最大公约数，算法结束
4. 如果Bn=0，An是最大公约数，算法结束
5. 如果An和Bn都是偶数，则$A(n+1)=A(n)/2，B(n+1)=B(n)/2，C(n+1)=C(n)*2$(注意，乘2只要把整数左移一位即可，除2只要把整数右移一位即可)
6. 如果An是偶数，Bn不是偶数，则$A(n+1)=An/2，B(n+1)=Bn，C(n+1)=Cn$
7. 如果Bn是偶数，An不是偶数，则$B(n+1)=Bn/2，A(n+1)=An，C(n+1)=Cn$
8. 如果An和Bn都不是偶数，则$A(n+1)=|An-Bn|/2，B(n+1)=min(An,Bn)，C(n+1)=Cn$
9. n=n+1，转2

```java
public int stein(int a, int b) {
    //判断较大数
    int big, small;
    if (a > b) {
        big = a;
        small = b;
    } else {
        big = b;
        small = a;
    }
    //如果small为0，则big为最大公约数
    if (small == 0) {
        return big;
    }
    //判断奇偶数
    if (big % 2 == 0 && small % 2 == 0) {
        return 2 * gcd(big >> 1, small >> 1);
    } else if (big % 2 == 0) {
        return gcd(big >> 1, small);
    } else if (small % 2 == 0) {
        return gcd(big, small >> 1);
    } else {
        return gcd((big + small) >> 1, (big - small) >> 1);
    }
}
```

```java
public int stein(int a, int b) {
    //判断较大数
    int big, small;
    if (a > b) {
        big = a;
        small = b;
    } else {
        big = b;
        small = a;
    }
    //判断结束
    if(small == 0 || small == big){
        return big;
    }
    
    //判断奇偶
    if (big % 2 == 0 && small % 2 == 0) {
        return 2 * stein(big / 2, small / 2);
    } else {
        return stein(big - small, small);
    }
}
```

### 最小公倍数

- 两数相乘的积除以最大公约数即可得到最小公倍数。

```java
public int lcm(int a, int b) {
    return (a * b) / gcd(a,b);
}
```

### 素数

- 除了1和本身之外没有其他因数。

```java
public boolean isPrime(int num){
    for(int i = 2; i < num; i++){
        if(num % i == 0){
            return false;
        }
    }
    return true;
}
```

### 回文素数

- 回文数：从左到右和从右到左读完全一样的数。如： 101、34343

```java
public boolean palindromicPrimes(int num) {
    //位数
    int length = 0; //位数
    int temp = num;
    while (temp != 0) {
        length++;
        temp /= 10;
    }
    //判断回文数
    int right = 0;
    int left = length - 1;
    while (left > right) {
        if (num / (int) Math.pow(10, left) % 10 != num / (int) Math.pow(10, right) % 10)
            return false;
        left--;
        right++;
    }
    //判断素数
    for (int k = 2; k < num; k++) {
        if (num % k == 0) {
            return false;
        }
    }
    return true;
}
```

### 平方回文数

- 该回文数可以是其他自然数的平方。

```java
/**
* 输入一个数，判断其平方是否为平方回文数
*/
public boolean palindromicFac(int n) {
    int num = n * n;
    //位数
    int length = 0; //位数
    int temp = num;
    while (temp != 0) {
        length++;
        temp /= 10;
    }
    //判断回文数
    int right = 0;
    int left = length - 1;
    while (left > right) {
        if (num / (int) Math.pow(10, left) % 10 != num / (int) Math.pow(10, right) % 10)
            return false;
        left--;
        right++;
    }
    return true;
}
```

### 分解质因数

- 任何一个合数都可以写成几个质数相乘的形式，这几个质数都叫做合数的质因数。分解质因数就是把一个合数写成几个质数相乘的形式。

```java
public void decompositionPrimFactor(int num) {
    List<Integer> list = new ArrayList<>();
    int temp = num;
    for (int i = 2; i < num; i++) {
        outer:
        //获取num的质因数
        for (int j = 2; j < i; j++) {
            if (temp % j == 0) {
                //判断j是否为质数
                for (int k = 2; k < j; k++) {
                    if (j % k == 0) { //j不是质数
                        continue outer;
                    }
                }
                list.add(j);
                temp /= j;
            }
        }
        if (temp == 0) {
            break;
        }
    }
    System.out.print(num + "[");
    for (int n : list) {
        System.out.print(n +" ");
    }
    System.out.print("]\n");
}
```
