# 树的概念

## 树的逻辑结构

- 树是n个结点的有限集合。

### 结点

1. 有且只有一个根结点（一个结点也可以是树）。
2. 每个结点只有一个父结点。
3. 一个结点可以有多个子结点（子树）。
3. 任意一棵树，若结点数量为n，则边的数量为n-1。

### 基本术语

**度 degree**

- 结点的度：某结点拥有子树的个数。
- 树的度：各结点度的最大值。

**叶子结点、分支结点**

- 叶子结点（终端结点）：度为0的结点。
- 分支结点：度不为0的结点。

**孩子结点、双亲结点、兄弟结点**

- 孩子结点：某结点的子树的根结点。
- 双亲结点。
- 兄弟结点：具有同一个双亲的孩子结点。

**路径**

- 路径。
- 路径长度：路径上经过的边数。

**祖先、子孙**

- 从结点x到结点y存在一条路径，则结点x是结点y的祖先；结点y是结点x的子孙。

**结点的层数、树的深度、树的宽度**

- 结点的层数：根结点的层数为1。
- 树的深度：树中所有结点的最大层数。
- 树的宽度：树中每一层结点个数的最大值。

### 性质

1. 树中的结点数等于所有结点的度数加1。
2. 度为m的树中第i层上至多有$m^{(i − 1)}$个结点（i >= 1）。
3. 高度为h的m叉树至多有$ \frac{(m^h-1)}{(m-1)}$个结点。
4. 具有n个结点的m叉树的最小高度为$\log^{n(m−1)+1}_m$。

## 存储结构

### 双亲表示法

- 双亲表示法：假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。

| 结构            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| Node[] nodeList | 存储的连续空间，存放树的结点                                 |
| Node node       | 树结点<br />data：数据域<br />parent：指针域，指向该结点的双亲在nodeList中的下标 |

<img src="../../../pictures/Snipaste_2023-05-28_11-01-13.png" width="500"/> 

### 孩子表示法

- 孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

| 结构                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 表头数组 Head[] childList | 存放表头结点                                                 |
| 表头结点 Head             | data：数据域，存放孩子结点的数据信息 <br />firstChild：头指针域，指向存储该结点的孩子结点的头指针 |
| 孩子结点 Child            | child：孩子链表的孩子结点（表头数组中的索引）<br />next：指向该结点的下一个孩子结点的指针 |

<img src="../../../pictures/Snipaste_2023-05-28_11-11-12.png" width="1000"/>  

### 孩子兄弟表示法

<img src="../../../pictures/Snipaste_2023-05-28_11-28-59.png" width="1000"/> 

# 二叉树

## 逻辑结构

- 二叉树是有序树，有左右子树之分，一个结点最多有两个子结点。

### 特殊二叉树

#### 斜树

| 斜树   | 说明                         |
| ------ | ---------------------------- |
| 左斜树 | 所有结点都只有左子树的二叉树 |
| 右斜树 | 所有结点都只有右子树的二叉树 |

<img src="../../../pictures/Snipaste_2023-05-28_12-44-04.png" width="400"/> 

#### 满二叉树

- 满二叉树：所有分支结点都存在左子树和右子树，且所有的叶子节点都处于一层。
- 满二叉树中的每层都含有最多的结点：高度为h，则有$2^h-1$个结点。

<img src="../../../pictures/Snipaste_2023-05-28_12-48-37.png" width="250"/> 

1.  叶子结点都集中在满二叉树的最下一层。
1.  除叶子结点之外的每个结点度数均为2：只有度为0和2的结点。

- 对满二叉树按层序编号：约定编号从根结点(根结点编号为1)起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为i的结点：
  - 若有双亲，则其双亲编号：$\frac{i}{2}$。
  - 若有左孩子，则左孩子编号：$2i$。
  - 若有右孩子，则右孩子编号：$2i+1$。

#### 完全二叉树

- 完全二叉树：对一棵具有n个结点的二叉树按层序编号，编号为i的结点与（该二叉树同样深度的）满二叉树中编号为i的结点在二叉树中的位置完全相同。
  - $满二叉树 \subseteq 完全二叉树$


<img src="../../../pictures/Snipaste_2023-05-28_14-21-25.png" width="600"/> 

1. 深度为k的完全二叉树在第k-1层是满二叉树。
2. 叶子结点只可能在层次最大的两层上出现，且最大层次中的叶子结点都集中在该层左侧连续的位置。
3. 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子。
4. 按层序编号后，如果编号为i的结点为叶子结点或其只有左孩子，则编号大于i的结点均为叶子结点。
5. 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大（$\frac{n}{2}$）的分支结点只有左孩子，没有右孩子。

### 基本性质

1. 非空二叉树上的叶子结点（度为0）数等于度为2的结点数加1：$n_0 = n_2 + 1$。

> 设n为树的总结点数，$n_0$为度为0的结点数，$n_1$为度为1的结点数，$n_2$为度为2的结点数
> $$
> \begin{matrix}
> 结点：& n = n_0 + n_1 + n_2 \\
> 分支：& n - 1 = n_1 + 2 \times n_2
> \end{matrix}
> $$
> 分支：
>
> - 从进入的角度：只有根结点没有入边，故分支数为 n - 1。
> - 从出发的角度：度为2的结点发出2条分支，故$2n_2$；度为1的结点发出1条分支，故$n_1$。

2. 非空二叉树上第k层上至多有 $2^{k-1}，( k \ge 1 )$ 个结点。
3. 深度为k的二叉树至多有$2^k - 1，( k \ge 1 )$个结点。 

>- 至多：假设该树为满二叉树。
>
>- 二叉树第1层：只有一个根结点。

4. 具有n( n > 0 )个结点的完全二叉树的深度为$\lfloor \log_{2}^{n} \rfloor + 1$。

> 设具有n个结点的完全二叉树的深度为k：
> $$
> \begin{matrix}
> & 2^{k-1} \le n \lt 2^k \\
> 取对数：& k-1 \le \log_2^n \lt k \\
> 即：& \log_2^n \lt k \le \log_2^n + 1
> &
> \end{matrix}
> $$

5. 对完全二叉树按层序编号，对结点i则有以下关系:
   1. i > 1：结点i的双亲的编号为$\lfloor \frac{i}{2} \rfloor$，否则该结点为根结点。
      - i为偶数：双亲的左孩子。
      - i为奇数：双亲的右孩子。
   2. $2i \le n$：结点i 的左孩子编号为$2i$,，否则无左孩子。
   3. $2i+1 \le n$：结点i的右孩子编号为$2i + 1$，否则无右孩子。

## 存储结构和实现

### 顺序存储结构

### 二叉链表

<img src="../../../pictures/Snipaste_2022-12-31_22-00-13.png" width="600"/> 

```java
package tree;

import java.util.Scanner;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int menusel;

        //树的初始化
        Init tree = new Init();
        BinarySortTreeNode root = tree.InitTree();
        do {
            System.out.println("---------菜单-------");
            System.out.println("0.退出\t1.添加结点");
            menusel = scanner.nextInt();
            switch (menusel) {
                case 1:
                    tree.AddTreeNode(root);
                    break;
                case 0:
                    break;
                default:
                    ;
            }
        } while (menusel != 0);

        //遍历
        do {
            System.out.println("选择遍历的方式：1.DLR、2.LDR、3.LRD、4.Level");
            menusel = scanner.nextInt();
            switch (menusel) {
                case 1:
                    System.out.println("先序遍历DLR：");
                    tree.DLRTree(root);
                    break;
                case 2:
                    System.out.println("中序遍历LDR：");
                    tree.LDRTree(root);
                    break;
                case 3:
                    System.out.println("后序遍历：");
                    tree.LRDTree(root);
                    break;
                case 4:
                    System.out.println("按层遍历：");
                    tree.levelTree(root);
                    break;
                default:
                    ;
            }
        } while (menusel != 0);

        System.out.printf("该二叉树的深度：%d\n", tree.treeDepth(root));

        //清空树，释放资源
        tree.clearTree(root);
        root = null;
    }
}

/*二叉树结点类*/
class BinarySortTreeNode {
    public int data;
    public BinarySortTreeNode left;
    public BinarySortTreeNode right;
}

/*树*/
class Init {
    static final int MAXLEN = 20;//最大结点数
    static Scanner scanner = new Scanner(System.in);

    //构造初始结点root
    public BinarySortTreeNode InitTree() {
        BinarySortTreeNode node;
        if ((node = new BinarySortTreeNode()) != null) {
            System.out.println("输入根结点的值：");
            node.data = scanner.nextInt();
            node.left = null;
            node.right = null;
            if (node != null) {
                return node;
            } else {
                return null;
            }
        }
        return null;
    }

    //添加 为结点添加子树
    public void AddTreeNode(BinarySortTreeNode node) {
        BinarySortTreeNode pnode, parent; //当前结点/父结点
        int data; //值
        int menusel; //选择左/右子树

        if ((pnode = new BinarySortTreeNode()) != null) {
            System.out.println("输入结点数据：");
            pnode.data = scanner.nextInt();
            pnode.left = null;
            pnode.right = null;

            //判断父结点是否存在
            System.out.println("输入父结点数据：");
            data = scanner.nextInt();
            parent = treeFindNode(node, data); //父结点
            if (parent == null) { //如果父结点不存在
                System.out.println("未找到父结点，请重新输入");
                pnode = null; //重置
                return;
            }

            //选择添加的位置
            System.out.println("添加该结点至：1.左子树、2.右子树");
            do {
                menusel = scanner.nextInt();
                if (menusel == 1 || menusel == 2) {
                    if (parent == null) {
                        System.out.println("不存在父结点");
                    } else {
                        switch (menusel) {
                            case 1:
                                if (parent.left != null) { //判断子树是否为空
                                    System.out.println("左子树结点不为空");
                                } else {
                                    parent.left = pnode;
                                }
                                break;
                            case 2:
                                if (parent.right != null) {
                                    System.out.println("右子树结点不为空");
                                } else {
                                    parent.right = pnode;
                                }
                                break;
                            default:
                                System.out.println("该选项无效");
                                break;
                        }
                    }
                }
            } while (menusel != 1 && menusel != 2);
        }
    }

    //查找结点 如果结点node的值和data匹配则返回该结点
    BinarySortTreeNode treeFindNode(BinarySortTreeNode node, int data) {
        BinarySortTreeNode ptr;
        if (node == null) {
            return null;
        } else {
            if (node.data == data) {
                return node;
            } else {
                if ((ptr = treeFindNode(node.left, data)) != null) {
                    return ptr;
                } else {
                    return null;
                }
            }
        }
    }

    //返回左子树
    BinarySortTreeNode treeLeftNode(BinarySortTreeNode node) {
        if (node != null) {
            return node.left;
        } else {
            return null;
        }
    }

    //返回右子树
    BinarySortTreeNode treeRightNode(BinarySortTreeNode node) {
        if (node != null) {
            return node.right;
        } else {
            return null;
        }
    }

    //该树是否为空
    int treeIsEmpty(BinarySortTreeNode node) {
        if (node != null) {
            return 0;
        } else {
            return 1;
        }
    }

    //树的深度
    int treeDepth(BinarySortTreeNode node) {
        int depLeft, depRight;
        if (node == null) {
            return 0;
        } else {
            depLeft = treeDepth(node.left);
            depRight = treeDepth(node.right);
            if (depLeft > depRight) {
                return depLeft + 1;
            } else {
                return depRight + 1;
            }
        }
    }

    //清空树
    void clearTree(BinarySortTreeNode node) {
        if (node != null) {
            clearTree(node.left);
            clearTree(node.right);
            node = null;
        }
    }

    //返回结点的数据
    void treeNodeData(BinarySortTreeNode node) {
        System.out.print("[" + node.data + "]");
    }

    //按层遍历 上至下，左至右的顺序
    public void levelTree(BinarySortTreeNode node) {
        //需要使用队列辅助
        BinarySortTreeNode curNode;
        BinarySortTreeNode[] nodeQuery = new BinarySortTreeNode[MAXLEN];
        int head = 0, tail = 0;

        //先判断树是否为空
        if (node != null) {
            tail = (tail + 1) % MAXLEN;
            nodeQuery[tail] = node;
        }
        while (head != tail) {
            head = (head + 1) % MAXLEN;
            curNode = nodeQuery[head];

            treeNodeData(curNode);//输出

            //如果当前结点存在子树
            if (curNode.left != null) {
                tail = (tail + 1) % MAXLEN;
                nodeQuery[tail] = curNode.left;
            }
            if (curNode.right != null) {
                tail = (tail + 1) % MAXLEN;
                nodeQuery[tail] = curNode.right;
            }
        }
    }

    //先序遍历 DLR
    void DLRTree(BinarySortTreeNode node) {
        if (node != null) {
            treeNodeData(node);//输出
            DLRTree(node.left);
            DLRTree(node.right);
        }
    }

    //中序遍历 LDR
    void LDRTree(BinarySortTreeNode node) {
        if (node != null) {
            LDRTree(node.left);
            treeNodeData(node);//输出
            LDRTree(node.right);
        }
    }

    //后序遍历 LRD
    void LRDTree(BinarySortTreeNode node) {
        if (node != null) {
            LRDTree(node.left);
            LRDTree(node.right);
            treeNodeData(node);//输出
        }
    }
}
```

### 三叉链表

- 三叉链表：二叉链表在查找双亲结点时，最坏情况下需要遍历整个二叉链表。

<img src="../../../pictures/Snipaste_2023-05-28_16-10-33.png" width="600"/> 

## 遍历二叉链表

### 实现方式

#### 先序遍历 DLR

<img src="../../../pictures/Snipaste_2023-03-27_23-20-56.png" width="200"/> 

- 递归

```java
void DLRTree(BinarySortTreeNode node) {
    if (node != null) {
        treeNodeData(node);//输出
        DLRTree(node.left);
        DLRTree(node.right);
    }
}
```

- 非递归

```java
public List DLR() {
    //判断空树
    if (root == null) {
        return null;
    }
    List<Node> result = new ArrayList(); //遍历的结果
    Stack<Node> stack = new Stack<>(); //临时存放遍历的结点
    Node curNode = root; //当前遍历到的结点
    //当前结点为null并且临时结点栈内为空时遍历结束
    while (curNode != null || !stack.empty()) {
        if (curNode != null) { //如果当前结点不为空
            result.add(curNode); //将当前结点加入结果
            stack.push(curNode.right); //压入当前结点的右子树
            curNode = curNode.left; //指向当前结点的左子树
        } else {
            curNode = stack.pop(); //弹出该子树的父结点的右子树
        }
    }
    return result;
}
```



#### 中序遍历 LDR

<img src="../../../pictures/Snipaste_2023-03-27_23-21-47.png" width="250"/> 

- 递归

```java
void LDRTree(BinarySortTreeNode node) {
    if (node != null) {
        LDRTree(node.left);
        treeNodeData(node);//输出
        LDRTree(node.right);
    }
}
```

- 非递归

```java
//伪代码：
while(当前结点为空 || 临时栈为空){
    if(curNode != null){
       1. 向stack压入经过的结点和其右子树 先压右子树，在压该结点
       2. 指向下一个左子树 curNode = curNode.left 
    }else{
        当左子树为null curNode == null

        1. stack弹出该左子树的父结点并加入到结果 stack.pop()
        2. stack弹出该左子树对应的右子树:curNode = stack.pop()
    }
}
```

```java
public List LDR() {
    //判断空树
    if (root == null) {
        return null;
    }

    List<Node> result = new ArrayList(); //遍历的结果
    Stack<Node> stack = new Stack<>(); //临时存放遍历的结点
    Node curNode = root; //当前遍历到的结点

    //当前结点为null并且临时结点栈内为空时遍历结束
    while (curNode != null || !stack.empty()) {
        if (curNode != null) {
            //1. 向stack压入经过的结点和其右子树 先压右子树，在压该结点
            stack.push(curNode.right);
            stack.push(curNode);
            //2. 指向下一个左子树 curNode = curNode.left
            curNode = curNode.left;
        } else {//当左子树为null curNode == null
            //1. stack弹出该左子树的父结点并加入到结果 stack.pop()
            result.add(stack.pop());
            //2. stack弹出该左子树对应的右子树:curNode = stack.pop()
            curNode = stack.pop();
        }
    }

    return result;
}
```

#### 后序遍历 LRD

<img src="../../../pictures/Snipaste_2023-03-27_23-22-35.png" width="230"/> 

```java
void LRDTree(BinarySortTreeNode node) {
    if (node != null) {
        LRDTree(node.left);
        LRDTree(node.right);
        treeNodeData(node);//输出
    }
}
```

```java
while(curNode != null || !stack.empty()){
    if(curNode != null){
        直到curNode为空 即压入到stack的最后一个curNode的左子树为空
        1. 向stack依次压入 curNode curNode.right
        2. curNode = curNode.left;
    }else{
        1. 弹出右子树 curNode = stack.pop
        if(curNode == null){ 如果右子树为空
            1. 将该左子树的父结点弹出并加入到结果集 result.add(stack.pop()); 
        }else{
            如果右子树不为空 修正
            1. 判断其左右子树是否为空
                如果都空：将其加入到结果集，并将该右子树的父结点也加入结果集
            2. 判断当前是否为root，如果是，说明已经结束，应该停止 
                将当前的结点加入到结果，并返回结果
        }
    }
    返回结果
}
```

```java
    public List LRD() {
        //判断空树
        if (root == null) {
            return null;
        }

        List<Node> result = new ArrayList(); //遍历的结果
        Stack<Node> stack = new Stack<>(); //临时存放遍历的结点
        Node curNode = root; //当前遍历到的结点

        //当前结点为null并且临时结点栈内为空时遍历结束
        while (curNode != null || !stack.empty()) {
            if (curNode != null) {
                //1. 向stack压入经过的结点和其右子树 先压该结点，再压右子树
                stack.push(curNode);
                stack.push(curNode.right);
                //2. 指向下一个左子树 curNode = curNode.left
                curNode = curNode.left;
            } else {//当左子树为null curNode == null
                //弹出右子树
                curNode = stack.pop();
                if (curNode == null) {
                    result.add(stack.pop());
                } else {
                    if (curNode.left == null && curNode.right == null) {
                        result.add(curNode);
                        result.add(stack.pop());
                        curNode = null;
                    }
                    //结束
                    if(curNode == root){
                        result.add(curNode);
                        return result;
                    }
                }
            }
        }

        return result;
    }
}
```

#### 层次遍历

<img src="../../../pictures/Snipaste_2023-03-27_23-23-31.png" width="260"/> 

```java
public void levelTree(BinarySortTreeNode node) {
    //需要使用队列辅助
    BinarySortTreeNode curNode;
    BinarySortTreeNode[] nodeQuery = new BinarySortTreeNode[MAXLEN];
    int head = 0, tail = 0;

    //先判断树是否为空
    if (node != null) {
        tail = (tail + 1) % MAXLEN;
        nodeQuery[tail] = node;
    }
    while (head != tail) {
        head = (head + 1) % MAXLEN;
        curNode = nodeQuery[head];

        treeNodeData(curNode);//输出

        //如果当前结点存在子树
        if (curNode.left != null) {
            tail = (tail + 1) % MAXLEN;
            nodeQuery[tail] = curNode.left;
        }
        if (curNode.right != null) {
            tail = (tail + 1) % MAXLEN;
            nodeQuery[tail] = curNode.right;
        }
    }
}
```

```java
public List<Node> level() {
    //当树为空时
    if (root == null) {
        return null;
    }

    List<Node> result = new ArrayList<>(); //结果集
    Queue<Node> queue = new LinkedList<>(); //临时存放当前结点的子树  只存放非空的子树
    int curLevel = 1; //当前层级的未放入结果集的结点数量
    int nextLevel = 0; //下一层级的非空结点数量
    Node cur = root; //指向当前结点

    while (cur != null && !queue.isEmpty()) {
        1. 对每一层操作 判断该层的结点是否都放入结果集
        if (cur == null && curLevel) {
            进入下一层
            1. 将cur指向下一层的结点 cur = queue.poll()
            2. 将curLevel指向当前层的结点数量并重置nextLevel的结点数量 curLevel = nextLevel;
            nextLevel = 0;

        } else {
            1. 将cur放入结果集且curLevel--;
            2. 依次判断cur的左右子树，如果非空，则依次放入queue并nextLevel++;
            3. 判断是否该层都放入结果
                    如果curLevel不为0, cur = queue.poll();
            否则cur = null;
        }
    }
    return result;
}
```

```java
public List<Node> level() {
    //当树为空时
    if (root == null) {
        return null;
    }

    List<Node> result = new ArrayList<>(); //结果集
    Queue<Node> queue = new LinkedList<>(); //临时存放当前结点的子树  只存放非空的子树
    int curLevel = 1; //当前层级的未放入结果集的结点数量
    int nextLevel = 0; //下一层级的非空结点数量
    Node cur = root; //指向当前结点

    while (cur != null || !queue.isEmpty()) {
        //1. 对每一层操作 判断该层的结点是否都放入结果集
        if (cur == null && curLevel == 0) {
            //进入下一层
            //1. 将cur指向下一层的结点
            cur = queue.poll();
            //2. 将curLevel指向当前层的结点数量并重置nextLevel的结点数量
            curLevel = nextLevel;
            nextLevel = 0;

        } else {
            //1. 将cur放入结果集且curLevel--;
            result.add(cur);
            curLevel--;
            //2. 依次判断cur的左右子树，如果非空，则依次放入queue并nextLevel++;
            if (cur.left != null) {
                queue.add(cur.left);
                nextLevel++;
            }
            if (cur.right != null) {
                queue.add(cur.right);
                nextLevel++;
            }
            //3. 判断是否该层都放入结果
            //如果curLevel不为0, cur = queue.poll();
            //否则cur = null;
            if (curLevel != 0) {
                cur = queue.poll();
            } else {
                cur = null;
            }
        }
    }
    return result;
}
```

### 确定二叉树

- 先序排列（DLR）、后序排列（LRD）：确定各层级的根结点。
- 中序排列（LDR）：确定结点的左右子树之分。

> 求先序序列( ABCDEFGHI)和中序序列( BCAEDGHFI）所确定的二叉树：
>
> 1. 图a：
>
>    1. 由先序遍历：确定第一层的根结点为A；
>
>    2. 在1.1的基础上，由中序遍历确定BC为A的左子树一侧，而EDGHFI为A的右子树一侧。
>
>    <img src="../../../pictures/Snipaste_2023-05-28_15-38-07.png" width="400"/> 
>
> 2. 图b：
>
>    1. 在图a的基础上，由先序遍历确定：
>       - B是A的左子树、即C的双亲结点。
>       - D是A的右子树、即EFGHI的双亲/祖先结点。
>    2. 在2.1的基础上，由中序遍历确定：
>       - C是B的右子树。
>       - E是D的左子树，GHFI在D的右子树一侧。
>
>    <img src="../../../pictures/Snipaste_2023-05-28_15-42-27.png" width="400"/> 
>
> 3. 图c：
>
>    1. 在图b的基础上，由先序遍历确定：
>       - F是D的右子树、即GHI的双亲/祖先结点。
>    2. 在3.1的基础上，由中序遍历确定：
>       - GH在F的左子树一侧。
>       - I是F的右子树。
>
>    <img src="../../../pictures/Snipaste_2023-05-28_15-47-24.png" width="400"/> 
>
>    3. 最后确定H是G的右子树。
>
> <img src="../../../pictures/Snipaste_2023-03-28_18-48-08.png" width="500"/> 

# 森林

- 森林是m棵互不相交的树的集合

## 树转为二叉树

1. 为树中的所有相邻的兄弟结点之间加线。
2. 保留根结点和第一个子结点的连线，去除根结点与其他子结点的连线。
3. 层次调整：
   - 树的前序遍历等于二叉树的前序遍历
   - 树的后序遍历等于二叉树的中序遍历

## 森林转二叉树

1. 将森林的每棵树转为二叉树。
2. 第一棵二叉树保持不变，从第二棵二叉树开始，移除将后一棵二叉树的根结点作为前一棵二叉树的根结点的右子树。
3. 层次调整：
   - 森林的前序遍历等于二叉树的前序遍历
   - 森林的后序遍历等于二叉树的中序遍历

- 森林中树的兄弟结点--->二叉树中父结点的左孩子的右孩子结点、或左孩子的孩子的孩子结点。

## 二叉树转树/森林

1. 若该结点是其父结点的左结点，则将其右结点、右结点的子右结点……与其父结点相连。
2. 删除二叉树中所有的父结点与右结点的连线。
3. 层次调整。

# 二叉排序树

- 从任意结点开始，左子树结点值总比右子树值要小。**左子树结点值<根结点值<右子树**
- 进行中序遍历：LDR，可以得到一组有序的数值。从小到大。

 # 平衡二叉树

- 树上任一结点的左子树和右子树的深度之差不超过1。
- **平衡因子BF** 将二叉树上结点的左子树深度减去右子树深度的值。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的

## 最小不平衡子树

- 在平衡二叉树的构造过程中以距离插入结点最近的且平衡因子绝对值大于1的结点为根的子树。

## 平衡调整

### LL型 扁担原理

- 新插入的结点在结点A的左子树的左子树上。

<img src="../../../pictures/Snipaste_2023-03-28_19-08-27.png" width="600"/> 

- 扁担原理：将根结点（支撑点）从A改为B。

```java
Node temp = root; //暂存A结点
root = root.left; //将B结点（A结点的左子树）设为根结点
temp.left = root.right; //将A结点的左子树设为B结点的右子树
root.right = temp; //将A结点设为B结点的右子树
```

### RR型

- 与LL型相反

<img src="../../../pictures/Snipaste_2023-03-28_19-14-49.png" width="600"/> 

### LR型

- 由于在A的左孩子(L)的右子树上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置（即进行一次**RR平衡旋转(左单旋转)**），然后再把该C结点向右上旋转提升到A结点的位置（即进行一次**LL平衡旋转(右单旋转)**）。

<img src="../../../pictures/Snipaste_2023-03-28_19-23-14.png" width="500"/> 

### RL型

- **RL平衡旋转(先右后左双旋转)**。由于在A的右孩子®的左子树(L)上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置（即进行一次**LL平衡旋转(右单旋转)**），然后再把该C结点向左上旋转提升到A结点的位置（即进行一次**RR平衡旋转(左单旋转)**）。

<img src="../../../pictures/Snipaste_2023-03-28_19-24-53.png" width="550"/> 

# 最优二叉树（哈夫曼树）

## 概念实现

- 二叉树的带权路径长度WPL：从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和：

$$
WPL = \sum_{i=1}^nw_il_i
$$

- 哈夫曼树：带权路径长度最小的二叉树。
   - 使权值越大的叶子结点越靠近根结点，且不存在度为1的结点。 

1. 由给定的n个权值的{$w_1,w_2,_w_3,...,w_n$}，构成n棵只有根结点的二叉树集合F={$T_1,T_2,..,T_n$}，其中每棵二叉树$T_i$中只有一个带权为$w_i$的根结点，其左右子树均为空。
2. 在二叉树集合F中选取两棵根结点的值最小的树，作为左右子树以构造一棵新的二叉树，新二叉树的根结点的权值为这两棵二叉树的权值之和。
3. 在二叉树集合F中删除这两棵二叉树，并将新得到的二叉树加入到集合F中。
4. 重复2、3步，直至集合F中只剩下一棵二叉树，即为哈夫曼树。

```java
public class HuffmanTree {
    private HuffmanTreeNode root;
    List<HuffmanTreeNode> nodes;

    public HuffmanTree() {
        this.nodes = null;
    }

    public HuffmanTree(List<HuffmanTreeNode> nodes) {
        this.nodes = nodes;
    }

    public void createTree() {
        Queue<HuffmanTreeNode> queue = new PriorityQueue<>(new Comparator<HuffmanTreeNode>() {
            @Override
            public int compare(HuffmanTreeNode o1, HuffmanTreeNode o2) {
                return o1.value - o2.value;
            }
        });
        queue.addAll(nodes);

        while (!queue.isEmpty()) {
            HuffmanTreeNode n1 = queue.poll();
            HuffmanTreeNode n2 = queue.poll();
            HuffmanTreeNode parent = new HuffmanTreeNode(n1.value + n2.value, n1, n2);
            if (queue.isEmpty()) {
                root = parent;
                return;
            }
            queue.add(parent);
        }
    }

    public int getWeight() {
        Queue<HuffmanTreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        int weight = 0;
        while (!queue.isEmpty()) {
            HuffmanTreeNode curNode = queue.poll();
            if (curNode.left != null) {
                curNode.left.deep = curNode.deep + 1;
                curNode.right.deep = curNode.deep + 1;
                queue.add(curNode.left);
                queue.add(curNode.right);
            } else {
                weight += curNode.deep * curNode.value;
            }
        }
        return weight;
    }
}

class HuffmanTreeNode {
    int value;
    HuffmanTreeNode left;
    HuffmanTreeNode right;
    int deep;

    public HuffmanTreeNode(int value) {
        this.value = value;
        this.deep = 0;
    }

    public HuffmanTreeNode(int value, HuffmanTreeNode left, HuffmanTreeNode right) {
        this.value = value;
        this.left = left;
        this.right = right;
    }
}
```

## 哈夫曼编码

- 哈夫曼编码：通过数据出现的频率来分配权重，并由该权重来构建哈夫曼树。
  - 0和1究竟是表示左子树还是右子树没有明确规定。左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且是最优的。


>有一段文字内容为“ BADCADFEED”要网络传输给别人：
>
>1. 如果使用二进制数据表示：
>
><img src="../../../pictures/Snipaste_2023-03-28_19-44-41.png" width="450"/> 
>
>- 这样按照固定长度编码编码后就是“001000011010000011101100100011“，按每3位来译码。
>
>2. 使用哈夫曼树时：
>
>- 假设六个字母的频率为A 27,B 8,C 15,D 15,E 30,F 5；按权值百分比来分配，并重新按照赫夫曼树来规划它们。
>- 左图为构造赫夫曼树的过程的权值显示。右图为将权值左分支改为0，右分支改为1后的赫夫曼树
>
><img src="../../../pictures/Snipaste_2023-03-28_19-42-11.png" width="600"/> 
>
>- 原编码二进制串: 000011000011101100100011 (共 30个字符)
>- 新编码二进制串: 10100101010111100(共25个字符)
>- 数据被压缩，节省了空间。

- 前缀编码：不等长编码必须满足任一个字符的编码都不是另一个字符的编码的前缀。
  - 可以得出一个小结论：哈夫曼编码的字符在哈夫曼树中的位置只能是叶子结点、叶子结点一定代表哈夫曼编码的字符。即：$n_0 = 哈夫曼编码的字符数$。

> 非法的哈夫曼编码：不满足前缀编码的：{ 0, 00, 01, 10, 11}。
>
> <img src="../../../pictures/数据结构-哈夫曼编码-前缀编码.drawio.svg" width="400"/> 
>
> - 其中：0代表的字符是00、01的字符编码的前缀，故不满足前缀编码。

```java
package tree;

import java.util.PriorityQueue;

public class HuffmanCode {

    public static void main(String[] args) {
        HuffmanCode huffmanCode = new HuffmanCode();
        PriorityQueue<Node> queue = new PriorityQueue<>();
        queue.add(new Node(15, 'D'));
        queue.add(new Node(27, 'A'));
        queue.add(new Node(5, 'F'));
        queue.add(new Node(8, 'B'));
        queue.add(new Node(15, 'C'));
        queue.add(new Node(30, 'E'));
        huffmanCode.init(queue);
        huffmanCode.DLR(huffmanCode.root);

    }

    Node root;

    /**
     * 依据传入PriorityQueue的Data的weight值来创建哈夫曼树
     *
     * @param queue 创建哈夫曼树的结点
     */
    public void init(PriorityQueue<Node> queue) {
        //只要queue非空就继续添加
        while (!queue.isEmpty()) {
            Node left = queue.poll();
            Node right = queue.poll();
            //父结点
            Node parent = new Node(left, right, left.weight + right.weight);
            //如果队列中没有结点
            if (queue.isEmpty()) {
                root = parent;
                return;
            }
            //将当前的父结点加入到Queue中重新排序
            queue.add(parent);
        }
    }

    public void DLR(Node node) {
        if (node != null) {
            System.out.print(node.characteristic);
            DLR(node.left);
            DLR(node.right);
        }
    }

    //将哈夫曼树变为二进制串
//    public String unCoding() {
        //1.获得编码的顺序
        //2.
//    }
}

class Node implements Comparable {
    Node left;
    Node right;
    int weight; //频率百分比 权值
    char characteristic;

    public Node() {
    }

    public Node(Node left, Node right, int weight) {
        this.left = left;
        this.right = right;
        this.weight = weight;
    }

    public Node(int weight, char characteristic) {
        this.weight = weight;
        this.characteristic = characteristic;
    }

    @Override
    public int compareTo(Object o) {
        if (!(o instanceof Node))
            throw new RuntimeException("不是同一个类型");

        Node node = (Node) o;
        return this.weight - node.weight;
    }
}
```

# 字典树

- 字典树，是一种**空间换时间**的数据结构，又称Trie树、前缀树，是一种树形结构(字典树是一种数据结构)，典型用于统计、排序、和保存大量字符串。所以经常被搜索引擎系统用于文本词频统计。
- 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。
- 首先看单词的第一个字母是不是在字典的第一层,如果不在,说明字典树里没有该单词,如果在就在该字母的孩子结点里找是不是有单词的第二个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来储存字母,也可以储存数字等其它数据。

**重要性质：**

1. 根结点不包含字符，除了根结点每个结点都只包含一个字符。root结点不含字符这样做的目的是为了能够包括所有字符串。
2. 从根结点到某一个结点，路过字符串起来就是该结点对应的字符串。
3. 每个结点的子结点字符不同，也就是找到对应单词、字符是唯一的。

<img src="../../../pictures/Snipaste_2023-02-14_20-24-27.png" width="500"/> 


```java
package tree;

import java.util.HashMap;
import java.util.Map;

public class TrieTreeDemo {
    public static void main(String[] args) {
        Trie trie = new Trie();
        trie.insert("test");
        trie.insert("try");
        trie.insert("find");
        System.out.println(trie.starWith("i"));
        System.out.println(trie.search("try"));
    }
}

class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
        root.worldEnd = false;
    }

    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++) {
            Character character = word.charAt(i);
            //如果当前结点没有包含相关的后缀，则设置并获取该字符
            if (!node.childdren.containsKey(character)) {
                node.childdren.put(character, new TrieNode());
            }
            node = node.childdren.get(character);
        }
        node.worldEnd = true;
    }

    //全词匹配
    public boolean search(String word) {
        TrieNode node = root;
        boolean found = true;
        for (int i = 0; i < word.length(); i++) {
            Character character = word.charAt(i);
            if (!node.childdren.containsKey(character)) {
                return false;
            }
            node = node.childdren.get(character);
        }
        return found && node.worldEnd;
    }

    //前缀匹配
    public boolean starWith(String prefix) {
        TrieNode node = root;
        boolean found = true;
        for (int i = 0; i < prefix.length(); i++) {
            Character character = prefix.charAt(i);
            if (!node.childdren.containsKey(character)) {
                return false;
            }
            node = node.childdren.get(character);
        }
        return found;
    }
}

class TrieNode {
    Map<Character, TrieNode> childdren;
    boolean worldEnd;

    public TrieNode() {
        childdren = new HashMap<>();
        worldEnd = false;
    }
}
```

# 线索二叉树

# B树

## B-tree

### 基本概念

#### 定义

- B树属于多叉树、平衡多路查找树

**m阶的B树**：或者为空树，或者为满足以下特性的m叉树

1. 每个结点至多有m棵子树。
2. 根结点至少有两颗子树；除根结点外，其他结点至少有m/2棵子树。
3. 所有的非终端结点都包含以下数据（n，A0，K1，A1，K2，...，Kn，An）；B树的每个结点是多关键码的有序表：
   - **关键码**：Ki(1 =< i <= n) 
   - 关键码的数量限制：n：即(m/2 -1 <= n <= m-1)
   - 拥有子树根结点的**引用变量**：Ki<K(i+1) (1<=i<=n-1)，Ai (0<=i<=n)
   - 且Ai所引用子树中所有结点的关键码均小于K(i+1)大于Ki
4. 所有叶子结点（终端结点）都出现在同一层，即树高平衡。使用相同的终端结点（失败结点）来表示查找失败。
5. 平衡多路查找树：所有结点关键字是按递增次序排列，并遵循左小右大原则

#### 查找

- B树通常存储在磁盘：在磁盘中进行顺引用查找结点，在内存中进行在结点中查找关键码；即：先在磁盘中找到某结点，将该结点的信息读入内存，再在内存中查找等于k的关键码。
- **关键码**：一个关键码对应一个引用变量（子树）。关键码的作用类似定位器，存储在内存。
- **引用变量**：可以看作文件系统中的文件，存储在外存，由关键码来定位。因此，使用引用变量（在磁盘中查找文件）的次数决定了查找的消耗。

**B树的查找过程是顺引用查找结点和在结点中查找关键码交叉进行的过程**

- 在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，按照引用到相应的子树中查找，到达叶子结点（终端结点）时查找失败。

**最大深度**

- 根结点至少有两颗子树；除根结点外，其他结点至少有m/2棵子树：
  - 第1层至少有：2
  - 第2层至少有：m/2
  - 第3层至少有：2 * (m/2)^1
  - 第k+1层至少有：2* (m/2)^(k-1)

- 对于含有n个关键码的m阶B树的最大深度为：即从根结点到关键码所在结点的路径上涉及的结点数最多为： <img src="../../../pictures/Snipaste_2023-04-02_16-36-56.png" width="180"/> 

#### 插入

- 关键码的数量限制：n：即(m/2 -1 <= n <= m-1)

#### 1. 定位

- 返回key所属结点的引用p。
- 如果p中的关键码个数小于n，则直接插入。否则，分裂-提升。

#### 2. 分裂-提升

- 将p分裂成两个结点p1,p2，分别为p的左右子树；将p指向p的中间关键码引用。
- 如果仍然溢出，则继续上传分裂-提升。如果溢出到根结点，则产生一个新的根结点，并且树高加1.

#### 删除

- 关键码的数量限制：n：即(m/2 -1 <= n <= m-1)
- 如果当前关键码的数量大于m/2-1，则直接删除即可；否则，需要向外借。

##### 兄弟够借

- 如果兄弟结点的关键码数量多于（m/2 - 1），则从兄弟结点拿关键码。

1. 将借来的关键码和引用变量放在双亲结点。
2. 将双亲结点中较大的关键码和引用变量放在该结点。

- 所有结点关键字是按递增次序排列，并遵循左小右大原则；

##### 兄弟不够借

- 如果兄弟结点的关键码数量不多于（m/2 - 1），则执行合并。

1. 将其关键码都让给兄弟结点。（一般不会上溢）
2. 如果双亲结点产生下溢（关键码数量小于(m/2 -1)），则双亲结点也执行“借”的操作。

### 实现

```java

```

## B+tree

## B*tree

# 红黑树

3. 