# 分治简述

- 分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。
- 将父问题分解为子问题同等方式求解，这和递归的概念很吻合，所以在分治算法通常以递归的方式实现(当然也有非递归的实现方式)。分治算法的描述从字面上也很容易理解，分、治其实还有个合并的过程：
  - 分(Divide)：递归解决子问题(到终止层或者可以解决的时候停下)
  - 治(Conquer)：递归求解，如果问题够小直接求解。 即：if条件
  - 合并(Combine)：将子问题的解构建父类问题    
- 一般分治算法在正文中分解为两个即以上的递归调用，并且子类问题一般是不想交的(互不影响)。当求解一个问题规模很大很难直接求解，但是规模较小的时候问题很容易求解并且这个问题并且问题满足分治算法的适用条件，那么就可以使用分治算法。

**使用时应满足的条件(特征)**

1. 原问题规模通常比较大，不易直接解决，但问题缩小到一定程度就能较容易的解决。
2. 问题可以分解为若干规模较小、求解方式相同(似)的子问题。且子问题之间求解是独立的互不影响。
3. 合并问题分解的子问题可以得到问题的解。

**具体应用**

1. 二分搜索
2. 快速排序
3. 归并排序（逆序数）
4. 最大子序列求和
5. 最近点对

# 寻找假币

- 从30个硬币中找到1个假币，假币的重量不同。

```java
package divide;

import java.util.Scanner;

public class CounterfeitCoin {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] arr = new int[30];
        int counteritCoin = Integer.parseInt(scanner.next());
        for (int i = 0; i < arr.length; i++) {
            if (i == counteritCoin) {
                arr[i] = 2;
            } else {
                arr[i] = 1;
            }
        }
        int index = find(arr, 0, arr.length - 1);
        System.out.println("假币(" + arr[index] + ")的位置：" + index);
    }

    public static int find(int[] coins, int start, int end) {
        if (start + 1 == end) { //终止条件
            return coins[start] > coins[end] ? start : end;
        }
        int startSum = 0, endSum = 0; //两段硬币的质量
        //计算两边重量
        //判断当前硬币数量的奇偶
        int mid = (start + end) / 2; //中间下标，若奇数：此时前半段比后半段多1个。
        if ((start - end + 1) % 2 == 0) { //偶数
            for (int i = start; i <= mid; i++) {
                startSum += coins[i];
            }
            for (int i = mid + 1; i <= end; i++) {
                endSum += coins[i];
            }

            if (startSum > endSum) {
                return find(coins, start, mid);
            } else {
                return find(coins, mid + 1, end);
            }
        } else { //奇数
            for (int i = start; i <= mid; i++) {
                startSum += coins[i];
            }
            for (int i = mid + 1; i <= end; i++) {
                endSum += coins[i];
            }
            //奇数0~4时：对于前半段：0~2 可能 3或4
            //对于后半段：3~4 可能 2或3 补充1 3或4 4或5
            endSum += coins[end]; //补充前半段多的。
            if (startSum > endSum) {
                return find(coins, start, mid);
            } else {
                return find(coins, mid + 1, end);
            }
        }
    }
}
```

