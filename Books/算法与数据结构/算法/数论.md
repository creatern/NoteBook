## 基本数学问题

### 多项式计算

#### 一元多项式求值

- 使用递归：将多项式转化为(...(nx + nx)x + n)x+..+n

```java
/**
    * @param arr 存放系数
    * @param x   对应的x值
    * @return 计算结果
    * @Description 只能计算排好顺序的多项式 从x^0到x^n 那么
    */
public static double getResultOne(double[] arr, double x) {
    int index = arr.length - 1; //当前计算的项
    double result = arr[index--]; //先获取最高项的系数
    for (; index >= 0; index--) {
        result = result * x + arr[index]; //计算 逐步直到x^0即：arr[0]
    }
    return result;
}
```

#### 二元多项式求值

- 二维数组存放二元多项式，以此类推：n元使用n维数组

|      | x^0  | x^1  | ...  | x^n  |
| :--: | :--: | :--: | :--: | :--: |
| y^0  |      |      |      |      |
| y^1  |      |      |      |      |
| ...  |      |      |      |      |
| y^n  |      |      |      |      |

```java
public static double getResultTwo(double arr[][], double x, double y) {
    double result = 0; //总的结果 x
    double tempResult = 0;//内部暂时结果 y
    boolean isHaveResult = false; //表示result还没有初始值
    boolean isHaveTemp = false; //表示tempResult还没有初始值
    for (int i = arr.length - 1; i >= 0; i--) { //x
        for (int j = arr[i].length - 1; j >= 0; j--) { //y
            if (arr[i][j] != 0) { //先计算x内部的系数y
                if (!isHaveTemp) {
                    tempResult = arr[i][j];
                    isHaveTemp = true;
                } else {
                    tempResult = tempResult * y + arr[i][j];
                }
            }
        }
        if (isHaveTemp) {
            if (!isHaveResult) {
                result = tempResult;
            } else {
                result = result * x + tempResult;
                isHaveTemp = false; //重置
            }
        }
    }
    return result;
}
```

#### 一元多项式乘法

```java
public static double[] getResultMul(double[] A, double[] B) {
    double[] result = new double[A.length + B.length - 1]; //相乘最高项的幂为A和B的最高项幂的和

    for (int i = A.length - 1; i >= 0; i--) {
        for (int j = B.length - 1; j >= 0; j--) {
            result[i + j] += A[i] * B[j]; //注意是+=
        }
    }

    return result;
}
```

#### 一元多项式除法

```java

```

### 随机数

- Math.random() 返回0~1之间的随机数

### 复数运算

### 割圆术

- 假设一个圆的半径为1，在其内部内接一个正六边形，边长为y：
- 由几何可知y=1，则圆周长近似于L=6*y=6；
- 则Π=L/2=n*y/2=3。

```java

```

## 数论

### 完全数

**完全数概念：** 完全数等于其所有因子的和。即：所有可以整除该数的数，而不包括该数本身。

```java
/**
* @param n 寻找的范围
* @description 找出所有符合条件的完全数，同时输出其因子
*/
public void perfectNumber(int n) {
    if (n <= 2) {
        throw new RuntimeException("不符合正确的范围(>=3)");
    }
    List<Integer> perfectNumbers = new ArrayList<>();
    List<Integer>[] factors = new List[n];
    //从第一个完全数6开始，对每个数进行操作
    for (int i = 6; i <= n; i++) {
        Queue<Integer> queue = new LinkedList<>();
        //被整除的因数不包括其本身，但必然包括1
        int facSum = 1; //统计因子的和
        queue.add(1);
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                queue.add(j);
                facSum += j;
            }
        }
        if (facSum == i) {
            perfectNumbers.add(facSum);
            factors[i] = new ArrayList<>(queue);
        }
    }
    for (int num : perfectNumbers) {
        System.out.print(num + "\t：");
        for (int fac : factors[num]) {
            System.out.print(fac + " ");
        }
        System.out.println();
    }
}
```

### 亲密数

- 如果整数a的因子和大于整数b，整数b的因子和等于整数a，因子不包括本身，且a不等于b，则称a和b为亲密数。
- 因子：一般可以确定为包括1，且最大的因子最多为：n/2+1

```java
/**
* @param n 要找其亲密数的数
* @return -1 找不到，其他找到
* @descritption 找到对应的亲密数
*/
public int findIntimacy(int n) {
    //计算n的因子和
    int facSumA = 0;
    for (int i = 1; i < n; i++) {
        if (n % i == 0)
            facSumA += i;
    }
    //查看n的因子和的因子和是否等于n
    int facSumB = 0;
    for (int i = 1; i < facSumA; i++) {
        if (facSumA % i == 0)
            facSumB += i;
    }
    if (facSumB == n) {
        return facSumA;
    } else {
        return -1;
    }
}
```

```java
/**
* @param n 寻找范围
* @description 亲密数
*/
public void intimacyNumber(int n) {
    int[] numbers = new int[n]; //存放亲密数
    int index = 0; //下标
    //对于整数a
    for (int i = 1; i <= n; i++) {
        index = 0; //重置
        //算出a的因子和
        int aSum = 1;
        for (int j = 2; j < i / 2 + 1; j++) {
            if (i % j == 0) {
                aSum += j;
            }
        }
        //整数b
        for (int j = 1; j < i; j++) {
            //算出b的因子和
            int bSum = 1;
            for (int k = 2; k < j / 2 + 1; k++) {
                if (j % k == 0) {
                    bSum += k;
                }
            }
            if (aSum == j && bSum == i) {
                //将当前符合条件的亲密数放入numbers
                numbers[index++] = j;
            }
        }
        //如果没有找到对应的亲密数
        if (index == 0) {
            continue;
        }
        System.out.print(i + "：");
        //输出亲密数，index的值比应有的下标多1
        for (int j = 0; j < index; j++) {
            System.out.print(numbers[j] + " ");
        }
        System.out.println();
    }
}
```

### 水仙花数

- 水仙花数是n位正整数（n>=3），他的每个位上的数字的n次幂之和等于其本身。

```java
/**
* @param n 水仙花数的位数
* @description 查找相应位数的水仙花数
*/
public void daffodils(int n) {
    if (n < 3) {
        throw new RuntimeException("输入的位数不符合规范");
    }
    //确定起始和结束
    int start = (int) Math.pow(10, n - 1);
    int end = (int) Math.pow(10, n);
    //开始查找
    int number;//每位数
    int sum;//总和
    int temp;
    for (int i = start; i < end; i++) {
        sum = 0;
        //对每位数进行n次幂
        for (int j = 0; j < n; j++) {
            number = i / (int) Math.pow(10, j) % 10;
            sum += Math.pow(number, n);
        }
        if (sum == i) {
            System.out.println(i);
        }
    }
}
```

### 自守数

1. 以自守数为后几位的两个数相乘的相应后几位仍然是该自守数。如：1**76** `*` 5**76** = 1013**76**
2. n+1位自守数出自n位的自守数
3. 两个n位自守数的和等于10^n+1

- 自守数：5、6、25、76、635、376 ...

```java
/**
* @param n 要判断的数
* @return true 是，false 不是
* @description 判断该数是否为自守数
*/
public boolean isSelfGuarding(int n) {
    int count = 1;//判断是几位的自守数
    while (n / (int) Math.pow(10, count) != 0) {
        count++;
    }
    //判断10^n+1 - 该数的是否为自守数 。。跳不出去
//    if (!isSelfGuarding((int) Math.pow(10, count) + 1 - n)) {
//        return false;
//    }
    //判断第n-1位是否是自守数
    if (count != 1) {
        if (!isSelfGuarding(Integer.parseInt(("" + n).substring(1)))) {
            return false;
        }
    }
    //若以该数为后几位的两个数相乘的后几位为自守数
    int num1 = Integer.parseInt((int) (Math.random() * 10) + "" + n);
    int num2 = Integer.parseInt((int) (Math.random() * 10) + "" + n);
    String result = (num1 * num2) + "";
    String number = result.substring(result.length() - count);
    if (Integer.parseInt(number) == n) {
        return true;
    } else {
        return false;
    }
}
```

**对n位自守数的后面n位数的计算优化**

- 对于个位数与被乘数相乘的积中，用被乘数的后n位与乘数的个位相乘
- 对于十位数与被乘数相乘的积中，用被乘数的后n-1位与乘数的个位相乘
- 以此类推，直到后1位；

```java
/**
 * @param num 要判断的数
 * @return true 是，false 不是
 * @description 判断该数是否为自守数
 */
public boolean isSelfGuarding2(long num) {
    long maxMod = 1; //自守数的位数
    //计算自守数位数，给maxMod赋值
    long temp = num;
    do {
        maxMod *= 10;
        temp /= 10;
    } while (temp > 0);
    //按位数从大到小，直到个位，依次放入faciend中
    long resultFix = 0; //重置用于存放计算的后n位数
    long curMod = maxMod; //当前的位
    long nextMod = 10; //下一位
    long t, n;
    while (curMod > 0) {
        t = num % (curMod * 10);
        n = num % nextMod - num % (nextMod / 10);
        resultFix = (resultFix + t * n) % maxMod;
        curMod /= 10;
        nextMod *= 10;
    }
    //判断是否与相乘之后的后n位数相等。
    if (num == resultFix) {
        return true;
    } else {
        return false;
    }
}
```

### 最大公约数

#### 欧几里得算法

**辗转相除法**

- **两个整数的最大公约数等于其中较小的数和两数的相除余数的最大公约数**

1. 对于两自然数m、n, m >n
2. r = m % n 
3. if ( r == 0 ) 则n为最大公约数
4. else{m = n , n = r}，重复2.3.步骤

**原理：**

- a可以表示成a = kb + r（a，b，k，r皆为正整数，且r不为0）
- 假设d是a,b的一个公约数，记作d/a,d/b，即a和b都可以被d整除。
- 而r = a - kb，两边同时除以d，r/d=a/d-kb/d，由等式右边可知m=r/d为整数，因此d|r
- 因此d也是b,a mod b的公约数。
- **因(a,b)和(b,a mod b)的公约数相等**，则其最大公约数也相等，得证。

```java
public int gcd(int a,int b){
    if( a % b == 0)
        return b;
    return gcd(b,a % b);
}
```

```java
/**
* @param a
* @param b
* @return result 最大公约数
* @description 计算最大公约数
*/
public int euclidean(int a, int b) {
    int big, small, result;
    //确定较大数
    if (a > b) {
        big = a;
        small = b;
    } else {
        big = b;
        small = a;
    }
    while ((result = big % small) != 0) {
        big = small;
        small = result;
    }
    return small;
}
```

#### stein算法 更相减损术

- **可半者半之，不可半者，副置分母子之数，以少减多，更相减损，求其等也，以等数约之**。
- 即如果两个整数a、b都能被c整除,那么a与b的差也能被C整除。
- 如果两个整数都是偶数，就使用2约简，直到两个整数不再都是偶数，然后执行第2步。如果两个整数不都是偶数，则直接执行第2步。用较大的数减去较小的数，如果得到的差恰好等于较小的数，则停止。否则，对较小的数和差值重复这个过程。第1步中约掉的若干个2和第2步中得到的差的乘积为原来两个整数的最大公约数。

1. 设置$An=|A|、Bn=|B|、Cn=1和n=1$
2. 如果$An=Bn,那么An(或Bn)*Cn$是最大公约数,算法结束
3. 如果An=0，Bn是最大公约数，算法结束
4. 如果Bn=0，An是最大公约数，算法结束
5. 如果An和Bn都是偶数，则$A(n+1)=A(n)/2，B(n+1)=B(n)/2，C(n+1)=C(n)*2$(注意，乘2只要把整数左移一位即可，除2只要把整数右移一位即可)
6. 如果An是偶数，Bn不是偶数，则$A(n+1)=An/2，B(n+1)=Bn，C(n+1)=Cn$
7. 如果Bn是偶数，An不是偶数，则$B(n+1)=Bn/2，A(n+1)=An，C(n+1)=Cn$
8. 如果An和Bn都不是偶数，则$A(n+1)=|An-Bn|/2，B(n+1)=min(An,Bn)，C(n+1)=Cn$
9. n=n+1，转2

```java
public int stein(int a, int b) {
    //判断较大数
    int big, small;
    if (a > b) {
        big = a;
        small = b;
    } else {
        big = b;
        small = a;
    }
    //如果small为0，则big为最大公约数
    if (small == 0) {
        return big;
    }
    //判断奇偶数
    if (big % 2 == 0 && small % 2 == 0) {
        return 2 * gcd(big >> 1, small >> 1);
    } else if (big % 2 == 0) {
        return gcd(big >> 1, small);
    } else if (small % 2 == 0) {
        return gcd(big, small >> 1);
    } else {
        return gcd((big + small) >> 1, (big - small) >> 1);
    }
}
```

```java
public int stein(int a, int b) {
    //判断较大数
    int big, small;
    if (a > b) {
        big = a;
        small = b;
    } else {
        big = b;
        small = a;
    }
    //判断结束
    if(small == 0 || small == big){
        return big;
    }
    
    //判断奇偶
    if (big % 2 == 0 && small % 2 == 0) {
        return 2 * stein(big / 2, small / 2);
    } else {
        return stein(big - small, small);
    }
}
```

### 最小公倍数

- 两数相乘的积除以最大公约数即可得到最小公倍数。

```java
public int lcm(int a, int b) {
    return (a * b) / gcd(a,b);
}
```

### 素数

- 除了1和本身之外没有其他因数。

```java
public boolean isPrime(int num){
    for(int i = 2; i < num; i++){
        if(num % i == 0){
            return false;
        }
    }
    return true;
}
```

### 回文素数

- 回文数：从左到右和从右到左读完全一样的数。如： 101、34343

```java
public boolean palindromicPrimes(int num) {
    //位数
    int length = 0; //位数
    int temp = num;
    while (temp != 0) {
        length++;
        temp /= 10;
    }
    //判断回文数
    int right = 0;
    int left = length - 1;
    while (left > right) {
        if (num / (int) Math.pow(10, left) % 10 != num / (int) Math.pow(10, right) % 10)
            return false;
        left--;
        right++;
    }
    //判断素数
    for (int k = 2; k < num; k++) {
        if (num % k == 0) {
            return false;
        }
    }
    return true;
}
```

### 平方回文数

- 该回文数可以是其他自然数的平方。

```java
/**
* 输入一个数，判断其平方是否为平方回文数
*/
public boolean palindromicFac(int n) {
    int num = n * n;
    //位数
    int length = 0; //位数
    int temp = num;
    while (temp != 0) {
        length++;
        temp /= 10;
    }
    //判断回文数
    int right = 0;
    int left = length - 1;
    while (left > right) {
        if (num / (int) Math.pow(10, left) % 10 != num / (int) Math.pow(10, right) % 10)
            return false;
        left--;
        right++;
    }
    return true;
}
```

### 分解质因数

- 任何一个合数都可以写成几个质数相乘的形式，这几个质数都叫做合数的质因数。分解质因数就是把一个合数写成几个质数相乘的形式。

```java
public void decompositionPrimFactor(int num) {
    List<Integer> list = new ArrayList<>();
    int temp = num;
    for (int i = 2; i < num; i++) {
        outer:
        //获取num的质因数
        for (int j = 2; j < i; j++) {
            if (temp % j == 0) {
                //判断j是否为质数
                for (int k = 2; k < j; k++) {
                    if (j % k == 0) { //j不是质数
                        continue outer;
                    }
                }
                list.add(j);
                temp /= j;
            }
        }
        if (temp == 0) {
            break;
        }
    }
    System.out.print(num + "[");
    for (int n : list) {
        System.out.print(n +" ");
    }
    System.out.print("]\n");
}
```

## 