## 数学计算

### 综合计算器 中缀表达式

<img src="../../../pictures/Snipaste_2022-12-18_20-46-13.png" width="800"/> 

```java
package stack;

public class CalculatorTest {
    public static void main(String[] args) {
        String expression = "30+6*3-2";
        //创建数字栈和符号栈
        NumberStack numberStack = new NumberStack(10);
        OperatorStack operatorStack = new OperatorStack(10);
        //定义需要的相关变量
        int index = 0; // 用于扫描
        int num1 = 0;
        int num2 = 0;
        int operator = 0;
        int result = 0;
        char temp = ' '; //将每次扫描的char保存到temp
        String keepNumber = ""; //用于拼接多位数

        //while循环扫描expression
        while (true) {
            //依次得到expression中的每个字符
            temp = expression.substring(index, index + 1).charAt(0);
            //判断temp是数字还是符号,进行相应的处理
            if (operatorStack.isOperator(temp)) { //如果是符号
                //判断当前符号栈是否为空
                if (operatorStack.isEmpty()) { //空：直接入栈
                    operatorStack.push(temp);
                } else { //非空：如果当前符号栈中有符号，比较优先级
                    //如果当前的运算符的优先级<=当前栈中的运算符，则pop两个数字和一个运算符进行计算
                    if (operatorStack.priority(temp) <= operatorStack.priority(operatorStack.peek())) {
                        num1 = numberStack.pop();
                        num2 = numberStack.pop();
                        result = operatorStack.calculate(num1, num2, operatorStack.pop());
                        //将计算的结果入栈
                        numberStack.push(result);
                        //将当前的运算符入栈
                        operatorStack.push(temp);
                    } else {//如果当前的运算符的优先级>当前栈中的运算符,则将当前的压入栈
                        operatorStack.push(temp);
                    }
                }
            } else { //如果是数，直接入数栈
                keepNumber += temp;
                //判断是否为表达式最后一位，最后一位则直接入栈
                if (index == expression.length() - 1) {
                    numberStack.push(temp - 48); //注意ASCII码的对应
                } else {
                    //判断下一个字符是否为数字，如果是数字则继续扫描，如果是运算符则入栈。
                    if (operatorStack.isOperator(expression.substring(index + 1, index + 2).charAt(0))) {
                        //如果后一位是运算符，则入栈
                        numberStack.push(Integer.parseInt(keepNumber));
                        //清空keepNumer
                        keepNumber ="";
                    }
                }
            }
            //让index+1，并判断是否扫描到expression最后
            index++;
            if (index >= expression.length()) {
                break;
            }
        }
        //当表达式扫描完毕，顺序的从数栈和符号栈中pop出相应的数和符号
        while (true) {
            //如果符号栈为空，则为计算到最后结果，此时数字栈中只有一个数（结果）
            if (operatorStack.isEmpty()) {
                break;
            }
            num1 = numberStack.pop();
            num2 = numberStack.pop();
            //
            result = operatorStack.calculate(num1, num2, operatorStack.pop());
            numberStack.push(result);
        }
        System.out.println(numberStack.pop());
    }
}

class NumberStack {
    private int maxSize; //栈的大小
    private int[] stack; //数组 模拟栈，存放数据
    private int top = -1; //栈顶 初始化-1

    public NumberStack(int maXSize) {
        this.maxSize = maXSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //压栈push
    public void push(int value) {
        //判断是否栈满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }

        stack[++top] = value;
    }

    //弹栈pop
    public int pop() {
        //判断栈是否空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }

        return stack[top--];
    }

    //遍历栈，从top栈顶开始
    public void show() {
        //判断栈是否空
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }

        for (int i = top; i >= 0; i--) {
            System.out.println("stack[" + i + "] = " + stack[i]);
        }
    }
}

class OperatorStack {
    private int maxSize; //栈的大小
    private int[] stack; //数组 模拟栈，存放数据
    private int top = -1; //栈顶 初始化-1

    public OperatorStack(int maXSize) {
        this.maxSize = maXSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //压栈push
    public void push(int value) {
        //判断是否栈满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }

        stack[++top] = value;
    }

    //弹栈pop
    public int pop() {
        //判断栈是否空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }

        return stack[top--];
    }

    //遍历栈，从top栈顶开始
    public void show() {
        //判断栈是否空
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }

        for (int i = top; i >= 0; i--) {
            System.out.println("stack[" + i + "] = " + stack[i]);
        }
    }

    //返回运算符的优先级 使用数字表示，数字越大，优先级越高
    public int priority(int operator) {
        //假定只有+-*/
        if (operator == '*' || operator == '/') {
            return 1;
        } else if (operator == '+' || operator == '-') {
            return 0;
        } else {
            return -1;
        }
    }

    //判断是否为运算符
    public boolean isOperator(char operator) {
        return operator == '+' || operator == '-' || operator == '*' || operator == '/';
    }

    //计算方法
    public int calculate(int num1, int num2, int operator) {
        int result = 0; //存放计算的结果
        switch (operator) {
            case '+':
                result = num1 + num2;
                break;
            case '-': //注意这里的顺序,因为是后进先出
                result = num2 - num1;
                break;
            case '*':
                result = num1 * num2;
                break;
            case '/': //注意这里的顺序,因为是后进先出
                result = num2 / num1;
                break;
            default:
                break;
        }
        return result;
    }

    //返回当前栈顶的值，但并非pop
    public int peek() {
        return stack[top];
    }
}
```

### 中缀、前缀、后缀表达式

#### 中缀表达式

- 一般转后缀

#### 前缀表达式 波兰表达式

- 前缀表达式的运算符位于操作数之前

**前缀表达式的计算机求值**

- 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

<img src="../../../pictures/Snipaste_2022-12-19_21-30-18.png" width="700"/> 

#### 后缀表达式 逆波兰表达式

- 后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

<img src="../../../pictures/Snipaste_2022-12-19_21-31-53.png" width="400"/> 

#### 逆波兰计算器 后缀表达式

<img src="../../../pictures/Snipaste_2022-12-19_21-37-16.png" width="700"/> 

```java
package stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        //先定义一个逆波兰表达式
        //4+(5+6)*2 --> 5 6 + 2 * 4 +
        String suffixExpression = "5 6 + 2 * 4 + ";
        //1.先放入ArrayList中
        //2.将ArrayList传递给方法，遍历ArrayList配合栈完成计算
        List<String> rpnList = getListString(suffixExpression);
        System.out.println(calculate(rpnList));
    }

    //将一个逆波兰表达式，依次将数字和运算符放入ArrayList
    public static List<String> getListString(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String str : split) {
            list.add(str);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    public static int calculate(List<String> list) {
        //创建栈,一个栈即可
        Stack<String> stack = new Stack<>();
        //遍历list
        for (String str : list) {
            //使用正则表达式，取出数
            if (str.matches("\\d+")) { //可以匹配多位数
                //入栈
                stack.push(str);
            } else { //如果是运算符
                //pop两个数，并运算，再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int result = 0;
                if (str.equals("+")) {
                    result = num1 + num2;
                } else if (str.equals("-")) {
                    result = num1 - num2;
                } else if (str.equals("*")) {
                    result = num1 * num2;
                } else if (str.equals("/")) {
                    result = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                //把计算结果入栈
                stack.push("" + result);
            }
        }
        //最后pop运算结果
        return Integer.parseInt(stack.pop());
    }
}
```

### 中缀转后缀

<img src="../../../pictures/Snipaste_2022-12-19_22-11-36.png" width="800"/> 
<img src="../../../pictures/Snipaste_2022-12-19_22-28-57.png" width="600"/> 

```java
//将中缀表达式转为对应的List
public static List<String> toInfixExpression(String infixExpression) {
    //定义List存放中缀表达式对应的内容
    List<String> list = new ArrayList<>();
    int index = 0; //指针，用于遍历中缀表达式
    String keepNumber; //多位数的拼接
    char temp; //遍历到的每个字符
    do {
        //如果非数字，则加入list //ASCII码 0~9对应68~57
        if ((temp = infixExpression.charAt(index)) < 48 || (temp = infixExpression.charAt(index)) > 57) {
            list.add("" + temp);
            index++;
        } else { //如果是数字，则拼接
            keepNumber = "";
            while (index < infixExpression.length() && (temp = infixExpression.charAt(index)) >= 48 && (temp = infixExpression.charAt(index)) <= 57) {
                keepNumber += temp;
                index++;
            }
            list.add(keepNumber);
        }
    } while (index < infixExpression.length());
    return list;
}

//将一个中缀表达式对应的List转换成后缀表达式, 放入到List中
public static List<String> parseSuffixExpressionList(List<String> infixList) {
    //定义两个栈 符号栈和中间结果的存储栈
    Stack<String> operatorStack = new Stack<>();
    //直接使用List<String> 替换中间结果的存储栈
//        Stack<String> numberStack = new Stack<>();
    List<String> resultList = new ArrayList<>();

    //遍历infixList
    for (String str : infixList) {
        //如果是数字，加入resultList
        if (str.matches("\\d+")) {
            resultList.add(str);
        } else if (str.equals("(")) { //左括号"("直接压入operatorStack
            operatorStack.push(str);
        } else if (str.equals(")")) {
            //如果是右括号")"，则依次pop出operatorStack中的运算符，并压入resultList,直到遇到左括号"("为止
            while (!operatorStack.peek().equals("(")) {
                resultList.add(operatorStack.pop());
            }
            operatorStack.pop(); //将 "(" 弹出，消除小括号
        } else {
            //当str的优先级<=operator栈顶的运算符的优先级，弹出operator中的运算符并加入到resultList中，再次转到与operatorStack新的运算符比较
            while (operatorStack.size() != 0 && Operation.getValue(operatorStack.peek()) >= Operation.getValue(str)) {
                resultList.add(operatorStack.pop());
            }
            //将str压入栈
            operatorStack.push(str);
        }
    }

    //将operatorStack中剩余的运算符依次弹出，并加入resultList
    while (operatorStack.size() != 0) {
        resultList.add(operatorStack.pop());
    }
    return resultList;
}


class Operation {
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //返回运算符的优先级
    public static int getValue(String operation) {
        int result;
        switch (operation) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
//                throw new RuntimeException("不存在该运算符");
                result = 0;
        }

        return result;
    }
}
```

# 
