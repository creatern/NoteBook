## 执行计划

### 概念

SQL执行计划的概念主要包括ROWID(伪列)、Recursive SQL(递归SOL)、RomSource And Predicate(行源和谓词)、Driving Table(驱动表)、Probed Table(被查表)、Concatenated Index(组合索引)、Selectivity(可选择性)、物理读(Physical Reads)、逻辑读(Logical Reads)、一致性读(Consistant Get)、读一致性、当前读(Db Block Gets)等

**ROWID(伪列)**

- ROWID是一个伪列，既然是伪列，那么这个列就不是用户定义，而是系统给加上的。

- 对每个表都有一个ROWID的伪列，但是表中并不物理存储ROWID列的值。
- 不过可以像使用其他列那样使用它，但是不能删除此列，也不能对此列的值进行修改、插入。
   - 一旦一行数据插入数据库，则ROWID在该行的生命周期内是唯一的，即使该行产生行迁移，但其行的ROWID值不会改变。
   

**Recursive SQL(递归SQL)**

- 有时为了执行用户发出的一个SQL语句，Oracle必须执行一些额外的操作或者语句，将它们称为“Reeursive Calls”或“Recursive SQL Statements”,
  - 当一个DDL语句发出后，Oracle总是隐含地发出一些Recursive SQL语句，来修改数据字典信息，以便用户可以成功地执行该DDL语句。
  - 当需要的数据字典信息没有在共享内存中时，经常会发生Recursive Calls,这些Recursive Calls会将数据字典信息从硬盘读入内存中。
  - 用户不必关心这些Recursive SQL语句的执行情况，在需要时，Oracle会自动在内部执行这些语句。
- DML语句引起RecursiveSQL的可能性最大。
  - 简单地说，可将触发器视为Recursive SQL.

**Row Source And Predicate(行源和谓词)**

- Row Source(行源)：
   - 用于查询中，由上一操作返回的符合条件的行的集合，
      - 既可以是表的全部行，也可以是表的部分行；
      - 还可以是对以上2个Row Source(行源)进行连接操作（如join连接）后得到的行。
- Predicate(谓词)：一个查询中的WHERE限制条件。

**Driving Table(驱动表)**

- 驱动表又称外层表(Outer Table)。
- 此表用来嵌套于Hash连接中。
- 如果此Row Source返回较多的行数据，则对所有的后续操作有负面影响。
- 注意，与其说驱动表，不如说驱动行源(Driving Row Source)更为确切。
   - 一般来说，在应用查询的限制条件后，返回较少行源的表作为驱动表，
   - 如果一个大表的WHERE条件有限制条件（如等值限制），则该大表作为驱动表也是合适的，
      - 所以并不是只有较小的表可以作为驱动表。
   - 在执行计划中，应为最右最上的那个Row Source,后面会给出具体说明。

**Probed Table(被探查表)**

- Probed Table(被探查表)：该表又称内层表(Inner Table)。
- 在从驱动表中得到具体行的数据后，再在该表中寻找符合连接条件的行。
- 所以该表应当为大表（实际上应为返回较大Row Source的表)且相应的列上应该有索引。

**Concatenated Index(组合索引)**

- 由多个列构成的索引，
   - 如`CREATE index sy_idx_emp on emp(coll,col2,col3,)`,则称idx_emp索引为组合索引。
- 在组合索引中有一个重要的概念：引导列(leading column
    - 在上面的例子中，col1列为引导列。
    - 当进行查询时可以使用“where col1=?”,也可以使用“where col1=? and col2=?”,这样的限制条件会使用索引，
    - 但是“where col2=?”查询不会使用该索引。
    - 所以，限制条件中包含先导列时，该限制条件才会使用该组合索引。

**Selectivity(可选择性)**

- 比较列中唯一键值的数量和表中的行数，就可以判断该列的可选择性。
   - 如果该列的“唯一健的数量表中的行数”的比值越接近1，则该列的可选择性越高，
   - 即重复度越小，该列就越适合创建索引，其索引的可选择性也越高。
- 在可选择性高的列上进行查询时，返回的数据就较少，比较适合使用索引查询。

**物理读(Physical Reads)**

- 从做盘读取数据块到内存的操作称为物理读，当SGA的高速缓存(Cache Buffer)中不存在这些数据块时，就会产生物理读。
- 另外，像全表扫指、磁盘样序等操作也可能产生物理读，
   - 原因是Orle数据库需要访问的数据块较多，而有些数据块不在内存当中，需要从磁盘读取。

**逻辑读(Logical Reads)**

- 概念1:
   - 逻辑读是指Oracle从内存读到的数据块数量。
   - 一般来说，Logical Reads=Db Block Gets(当前读)+Consistent Gets(一致性读)。
- 概念2：
   - 逻辑读是指从Buffer Cache中读取数据块。
   - 按照访问数据块的模式不同，可分为当前模式读(Current Read)和一致性读(Consistent Read)。
      - 这两个概念本质相同，只是措辞不同。
      

**一致性读(Consistent Gets)**

- 一致性读是面向多个会话的，即所有当前会话都要进行一致性读。
- Oracle是一个多用户系统，当一个会话开始读取数据还未结束读取之前，可能会有其他会话修改了它将要读取的数据。如果会话读取到修改后的数据，就会造成数据的不一致。一致性读就是为了保证数据的一致性。
   - 在Buffer Cache中的数据块上都会有最后一次修改数据块时的SCN(System Change Number:系统改变号)。
   - 如果一个事务需要修改数据块中的数据，会先在回滚段中保存一份修改前的数据和SCN编码的数据块，然后更新Buffer Cache中数据块的数据及其SCN，并标识其为“脏”数据。当其他进程读取数据块时，会先比较数据块上的SCN和进程自己的SCN。
        - 如果数据块上的SCN小于等于进程本身的SCN，则直接读取数据块上的数据；
        - 如果数据块上的SCN大于进程本身的SCN,则会从回滚段中找出修改前的数据块读取数据。
- 通常，普通查询都是一致性读。

**读一致性(Read Consistency)**

- 读一致性是针对众多会话中的一个会话而言的，是一个会话的查询所获得的数据必须来自同一时间点。
- Oracle针对这个会话，在必要时会使用Undo数据来构造CR(Consistant Read)块，从而提供非阻塞的查询。

**当前读(Db Block Gets)**

- 通常情况下，当前读(Db Block Gets)可以理解为DML操作产生的.
- 当前读(Db Block Gets)即读取数据块是当前的最新数据。任何时候在Buffer Cache中只有一份当前数据块。
- 当前读通常发生在对数据进行修改、删除操作时。这时，进程会给数据加上行级锁，并且标识数据为“脏”数据。
- Current Mode产生Db Block Gets，一般在DML操作时产生，Query Mode产生Consisten Gts(一致性读)，一般在查询时产生。它们两个总和一般称为逻辑读(Logical Read).

### `SQL*PLUS` 执行计划的设置

#### TIMING参数（SQL运行时间）

- SET TIMING ON
  - 显示运行时间
- SET TIMING OFF
  - 屏蔽运行时间  默认   

#### AUTOTRACE参数（自动跟踪参数）

- `SET AUTOTRACE OFF`
   -  默认，关闭自动跟踪
- `SET AUTOTRACE ON`
   - 包含执行计划和统计信息 
- `SET AUTOTRACE ON EXPLAIN`  
   - 只显示优化器执行路径报告（执行计划）
- `SET AUTOTRACE ON STATISTICS` 
   - 只显示执行统计信息
- `SET AUTOTRACE TRACEONLY` 
   - 同set autotrace on，但是不显示查询输出
- `SET AUTOTRACE TRACEONLY EXPLAIN`
- `SET AUTOTRACE TRACEONLY STATISTICS`

**注：**

1. 需要权限`GRANT select any dictionary TO user_name`; 
2. 只能在sql plus下执行 

#### 在`SQL*PLUS`中显示SQL执行计划

**查看预估的执行计划（可能与实际不符）**

```sql
EXPLAIN PLAN FRO SQL语句;

SELECT plan_table_output
FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE'));
```

**查看实际的执行计划**

```sql
SET AUTOTRACE ON;
SET AUTOTRACE TRACEONLY;
```

#### 执行计划信息

##### 执行计划

```sql
执行计划
----------------------------------------------------------
Plan hash value: 1139150879

---------------------------------------------------------------------------------------------
| Id  | Operation                     | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   1 |  HASH GROUP BY                |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   2 |   MERGE JOIN                  |             |   106 |  3286 |     6  (17)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID| DEPARTMENTS |    27 |   432 |     2   (0)| 00:00:01 |
|   4 |     INDEX FULL SCAN           | DEPT_ID_PK  |    27 |       |     1   (0)| 00:00:01 |
|*  5 |    SORT JOIN                  |             |   107 |  1605 |     4  (25)| 00:00:01 |
|   6 |     TABLE ACCESS FULL         | EMPLOYEES   |   107 |  1605 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------
```

**Id** 

- 序号，不是执行的先后顺序
  - 执行的先后顺序根据缩进来判断。
- Id列中`*`的含义
   - `*`对应步骤有驱动或过滤条件。

**Operation**

- 当前操作的内容
    - 该列反映SQL语句在每个步骤上都具体做了什么操作，如全表扫描、索引扫描、分区扫描、哈希连接、合并连接、嵌套循环等，是重点关注的信息。
    - 一般来讲，如果表上存在索引而走了表扫描，说明该SQL语句存在问题或者执行计划采集到的统计信息过旧导致，要具体问题具体分析。
- 执行顺序判断 
    - 按“Operation(操作)”列的缩进长度来判断，缩进最大的最先执行，
    - 如果有n行缩进一样，那么就先执行上面的，即最右最上原则。
    

**Name**

**Rows** 

- 当前操作的rows，oracle估计当前操作的返回结果集
- Rows值表示CBO预期从一个行源(Row Source)返回的记录数，这个行源可能是一个表，一个索引，也可能是一个子查询。
- Rows值对于CBO做出正确的执行计划来说至关重要。
    - 如果CBO(Cost-Basd Optimization,基于成本的优化)获得的Rows值不够准确，通常是没有做分析或者分析数据过旧造成，在执行计划成本计算上就会出现偏差，从而导致CBO错误地制订出执行计划，
    - 在多表关联查询或者SQL中有子查询时，每个关联表或子查询的Rows值对主查询的影响非常大，甚至可以说，CBO就是依赖于各个关联表或者子查询Rows值计算出最后的执行计划。
        - 对于多表查询，CBO使用每个关联表返回的行数(Rows)决定用什么样的访问方式来做表关联，如NESTED(嵌套)LOOPS Join或HASH(哈希)Join或MERGE(合并)Join
        - HASH(哈希)Join
        - MERGE(合并)Join
        - NESTED(嵌套)LOOPS Join
   - 对于子查询，它的Rows将决定子查询是使用索引还是使用全表扫描的方式访问数据。
     

**Cost(%CPU)**

- Oracle计算出来一个数值（代价），用于说明SQL执行的代价

**Time** 

- Oracle估计当前操作的时间

##### 谓词说明

```
Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
```

**access**

- 表示谓词条件的值将会影响数据的访问路径（表还是索引）。
- 在谓词中主要注意access,要考虑谓词的条件，使用的访问路径是否正确。

**Filter**

- 表示谓词条件的值不会影响数据的访问路径，只起过滤的作用。

##### 统计信息

```
统计信息
----------------------------------------------------------
          0  recursive calls
          0  db block gets
          9  consistent gets
          0  physical reads
          0  redo size
       3721  bytes sent via SQL*Net to client
        589  bytes received via SQL*Net from client
          8  SQL*Net roundtrips to/from client
          1  sorts (memory)
          0  sorts (disk)
        104  rows processed
```

**recursive calls**

- 在用户和系统级别生成的递归调用数。
- Oracle数据库维护用于内部处理的表，当需要更改这些表时，Oracle数据库生成一个内部SQL语句，该语句又生成一个递归调用。简言之，递归调用是SQL中的SQL。因此，如果必须解析查询，则可能需要运行其他查询才能获得数据字典信息，这些导致递归调用。空间管理、安全检查、从SQL调用SQL等都会产生递归SQL调用。
- 此项指标，需重点关注。

**db block gets**

- 请求的数据块在Buffer能满足的个数即“当前读”。
- 从BUFFER CACHE的block数量中，当前请求的块数目，当前请求的块数目就是在操作中直接提取的块数目，而不是在一致性读的情况下产生的。
   - 正常情况下，一个查询提取的块是在查询开始的那个时间点上存在的数据块，当前块是在此刻这个时间点上存在的数据块，而不是这个时间点之前或者之后的的数据块数目。
- 当前模式块是在它们当前存在时检索的，而不是以一致性读取的方式检索的。
    - 通常，查询检索的块在查询开始时被检索为存在。当前模式块是在它们当前存在时检索的，而不是从以前的时间点检索的。在选择期间，可能会看到由于读取数据字典而导致当前模式检索，以便查找表进行完整扫描的范围信息（因为需要“立即”信息，而不是一致读取)。在修改期间(DML操作)，将访问当前模式中的块以便写入它们。

**consistent gets (逻辑读)**    

- 从Buffer Cache中读取的Undo数据的Block的数量。
- 数据请求总数就是在回滚段(Undo)Buffer中的数据一致性读所需的数据块，意思是在处理这个操作时需要在一致性读状态上处理多个块。
   - 这些块产生的主要原因是因为在查询过程中，由于其他会话对数据块进行操作（主要是DML操作），而对所要查询的块有了修改。但是，由于查询是在这些修改之前调用的，为了保证数据的一致性，需要对回滚段中数据块的前映像进行查询，这样就产生了一致性读。
- 需重点关注，<mark>一般来讲，逻辑读越多越好。</mark>

**physical reads (物理读)**

- 物理读就是从磁盘上读取数据块的数量。
- 其产生的主要原因是如下：
  1. 在数据库高速缓存中不存在这些块；
  2. 全表扫描
  3. 磁盘排序
- 关系: 逻辑读是指Oracle从内存读到的数据块数量。一般来说是Consistent Gets+Db BlockGets。当在内存中找不到所需的数据块就需要从磁盘中获取，于是就产生了Physical Reads.
- Physical Reads通常是最关心的，如果这个值很高，说明要从磁盘请求大量的数据到Buffer Cache中，通常意味着系统中存在大量全表扫描的SQL语句，这会影响数据库的性能，因此尽量避免语句做全表扫描，对于全表扫描的SQL语句，建议增加相关的索引，优化SQL语句来解决。
- 此指标需重点关注，<mark>一般来讲，物理读越少越好。</mark>
**关于Physical Reads、Db Block Gets和Consistent Gets这3个参数之间有一个换算公式：**

`数据缓冲区的使用命中率 = 1 - (Physical Reads / (Db Block Gets + Consistent Gets)`

- `查询出来的结果Buffer Cache的命中率应在90%以上，否则需要增加数据缓冲区的大小`。
- 用以下语句可以查看数据缓冲区的命中率：

```sql
SELECT name,value 
FROM V$SYSSTAT 
WHERE name IN ('db block gets','consistent gets','physical reads');
```


**redo size , sorts(memeory) , sorts(disk)**

- redo size 
   - DML生成的REDO(日志记录)的大小。
- sorts(memory):
   - 在内存执行的排序量。
- sorts(disk):
   - 在磁盘执行的排序量。
- 需要至少一个磁盘写入的排序操作数。需要磁盘I/O的排序是资源密集型的。
  - 试着增加初始化参数`SORT_AREA_SIZE`大小（通过`SELECT * FROM V$SYSSTAT WHERE name LIKE '%sot%'`)来查看当前的排序内存使用情况并确认是否需要调整，如果调整的话，
      - 在PGA自动管理的情况下，可以调大`PGA_AGGREGATE_TARGET`参数值；
      - 如果PGA为非自动，可以直接调整`SORT_AREA_SIZE`

**其余**

- `bytes sent via SQL*Net to client` 
   - 从`SQL*Net`向客户端发送了..字节的数据
- `bytes received via SQL*Net from client`
   - 客户端向`SQL*Net`发送了..字节的数据 
- `SQL*Net roundtrips to/from client`
   - 从客户端发送和接收的Oracle网络信息的总数  

```sql
SET AUTOTRACE ON;
SET AUTOTRACE TRACEONLY;
SET PAGESIZE 0;
SET LONG 200000;
SET FEEDBACK OFF;
SET ECHO OFF;
SET LINESIZE 160;

SELECT AVG(salary),last_name,department_name
FROM scott.employees e
 JOIN scott.departments d
 ON e.department_id = d.department_id
GROUP BY department_name,last_name;

执行计划
----------------------------------------------------------
Plan hash value: 1139150879

---------------------------------------------------------------------------------------------
| Id  | Operation                     | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   1 |  HASH GROUP BY                |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   2 |   MERGE JOIN                  |             |   106 |  3286 |     6  (17)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID| DEPARTMENTS |    27 |   432 |     2   (0)| 00:00:01 |
|   4 |     INDEX FULL SCAN           | DEPT_ID_PK  |    27 |       |     1   (0)| 00:00:01 |
|*  5 |    SORT JOIN                  |             |   107 |  1605 |     4  (25)| 00:00:01 |
|   6 |     TABLE ACCESS FULL         | EMPLOYEES   |   107 |  1605 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")


统计信息
----------------------------------------------------------
          0  recursive calls
          0  db block gets
          9  consistent gets
          0  physical reads
          0  redo size
       3721  bytes sent via SQL*Net to client
        589  bytes received via SQL*Net from client
          8  SQL*Net roundtrips to/from client
          1  sorts (memory)
          0  sorts (disk)
        104  rows processed
```

### SQL解析

#### 硬解析和软解析

**硬解析的概念**

- 硬解析，也称库缓存未命中。如果数据库不能重用现有SQL代码，则它必须生成一个新的可执行版本，本次操作称为一个硬解析。
   - 数据库对DDL语句始终执行硬解析。
- 在硬解析期间，数据库多次访问库缓存和数据字典缓存以检查数据字典。
    - 当数据库访问这些区域时，它在所需对象上使用一个叫作闩锁的串行化设备，以便控制这些对象不能被更改。
    - 闩锁的争用会增加语句的执行时间，并降低并发性。

**软解析的概念**

- 软解析，也称库缓存命中。任何跳过硬解析的解析都是软解析。
- 如果接收到的SQL语句与在共享池中某个可重用SQL语句相同，则数据库将重用该现有代码。
   - 重用代码也称库缓存命中。
- 如果数据库中软解析频率比硬解析频率高则是最好的
   - 因为数据库可以跳过优化和行源生成步骤，而直接进入执行阶段。

### SQL硬解析与软解析的发生过程。

当数据库接收到一条SQL语句，在执行和返回结果前Oracle对此SQL将进行几个步骤的处理过程：

**1. 语法检查(syntax check)**

- 检查此SQL的拼写是否正确。

**2. 语义检查(semantic check)**

- 例如，检查SQL语句中的访问对象是否存在及该用户是否具备相应的权限。

**3. 对SQL语句进行解析（prase)**

- 当数据库接收到一个SQL语句时，会发出一个解析调用，以准备执行该语句，解析调用会打开或创建一个游标，它是一个对特定于会话的私有SQL区的句柄，其中包含已分析的SQL语句和其他处理信息。
   - 游标和私有SQL区位于PGA中。
- 然后，利用内部算法对SQL进行解析，生成解析树(Parse Tree)及执行计划(Execution Plan)，这些信息被存放于私有SQL区。
   - 具体的处理过程——数据库执行共享池检查，以确定是否跳过耗费大量资源的语句处理过程
   - 为此，数据库使用一种哈希算法为每个接收到的SQL语句生成一个哈希值。
      - 语句的哈希值即是在V$SQL.SQL_ID中显示的(4个于SQL相关的字段)
      - hash_value
      - sql_hash_value
      - plan_hash_value
      - sql_id
- 当数据库再次接收到一个SQL语句时，搜索共享SQL区，以查看是否存在一个与现成的已分析过的语句具有相同的哈希值。
  - SQL语句的哈希值有别于该语句的内存地址值(`V$sql的address字段值`)和该语句执行计划的哈希值(`V$SQL_PLAN视图的plan_hash_value字段值`)。
  - 假设存在，则将此SQL与cache中的进行比较，假设“相同”，将利用已有的解析树与执行计划，而省略了优化器的相关工作。这个过程称为软解析。
  - 当然，如果前述的两个假设中任意有一个不成立，那么优化器都将进行创建解析树、生成执行计划的动作。这个过程称为硬解析。
      - 硬解析对于SQL的执行来说是消耗大量资源的动作，所以，应当极力避免硬解析，而使用软解析。

**4. 执行SQL,返回结果(execute and return)。**


#### 动态分析采样

如果在执行计划中有如下提示：

```
Note
-----------------------------------------------
-dynamic sampling used for the statement
```

- 这提示CBO(基于成本的优化方式)当前使用的技术，需要用户在分析计划时考虑到这些因素。
- 当出现这个提示时，说明当前表使用了动态采样，从而推断这个表可能没有做过分析。这里会出现以下两种情况：
   - 如果表没有做过分析，那么CBO可以通过动态采样的方式来获取分析数据，正确地执行计划。
   - 如果表做过分析，但是分析信息过旧，这时CBO就不会再使用动态采样，而是使用这些旧的分析数据，从而可能导致错误的执行计划。

### RBO与CBO

- RBO(Rule-Based Optimization)，是指基于规则的优化方式
- CBO(Cost-Based Optimization)，是指基于成本的优化方式。
- 它们是优化器在优化SQL语句时所遵循的原则，

#### 基于规则的优化方式(RBO)

- 优化器在分析SOL语句时，所遵循的是Oracle内部预定的一些规则，对数据不敏感。它只借助少量的信息来决定一个SQL语句的执行计划，包括：
   - SQL语句本身；
    - SQL中涉及的Table、View、Index等的基本信息；
    - 本地数据库中数据字典中的信息（远程数据库数据字典信息对RBO无效）。
   
#### 基于成本的优化方式(CBO)

CBO是根据语句的代价(Cost)，通过代价引擎来估计每个执行计划所需的代价，该代价将每个执行计划所耗费的资源进行量化，CBO根据这个代价选择出最优的执行计划。

**一个查询所耗费的资源可分为3部分：**

- I/O代价
   - I/O代价是指把数据从磁盘读入内存时所需的代价（该代价是查询所需最主要的，所以在优化时一个基本原则就是降低I/O总次数)。
- CPU代价
   - CPU代价是指处理内存中数据所需的代价，数据一旦读入内存，当识别出所要的数据后，会在这些数据上执行排序(Sort)或连接(Join)操作，这需要消耗CPU资源。
- Network代价。
   - 对于访问远程节点来说，Network代价的花费也是很大的。
   - 优化器在判断是否用哪种方式时，主要参照的是表及索引的统计信息。统计信息给出表的大小、有多少行、每行的长度等信息。
   - 这些统计信息起初在库内是没有的，是做Analyze（分析)后才出现的，很多时候过期统计信息会令优化器做出一个错误的执行计划，因此应及时更新这些信息 
      - `DBMS_STAT.ANALYZE`

#### 优化模式

| 优化模式---- | 描述                                                                                                                                                  |
| :----------- | :---------------------------------------------------------------------------------------------------------------------------------------------------- |
| Rule         | 基于规则的方式                                                                                                                                         |
| Choose       | 默认情况下Oracle用的是这种方式。是指的当一个表或索引有统计信息，则走CBO的方式，如果表或索引没统计信息，表又不是特别小，且相应的列有索引时，那么就走索引，走RBO方式 |
| First Rows   | 它与Choose方式类似，所不同的是当一个表有统计信息时，它将是以最快的方式返回查询最先的几行，从总体上减少了响应时间。                                              |
| All Rows     | 也就是所说的Cost方式，当一个表有统计信息时，它将以最快的方式返回表的所有行，从总体上提高查询的吞吐量。没有统计信息则走RBO方式                                    |


#### 设定选用哪种优化模式

**1. 在initSID.ora中设定**  控制文件

`OPTIMIZER_MODE=RULE|CHOOSE|FIRST_ROWS|ALL_ROWS`

- 默认是CHOOSE
- 选择方式：在`OPTIMIZER_MODE=CHOOSE`时，如果表有统计信息（分区表外），优化器将选择CBO，否则选RBO。

**2. Sessions级别修改**

在用户与Oracle数据库交互环境`(SQL*Plus`、SQL Developer、TOAD)中发出如下语句：

```sql
ALTER SESSION SET OPTIMIZER_MODE=RULE|CHOOSE|FIRST_ROWS|ALL_ROWS;
```

此修改只对当前会话有效。

**3. 语句级别用`Hint(/*+.*/)`来设定**

### 关于执行计划中的索引访问方法

**执行计划的索引方法**

- 索引唯一扫描 INDEX UNIQUE SCAN
- 索引范围扫描 INDEX RANGE SCAN
- 索引跳跃扫描 INDEX SKIP SCAN
- 索引快速全扫描 INDEX FAST FULL SCAN

### DBMS_XPLAN包查看以往的SQL执行计划

- `DBMS_XPLAN`包用来查看Explain Plan生成的执行计划。

**函数**

- `DISPLAY`:
   - 格式化和显示计划的内容；
- `DISPLAY_AWR`:
   - 在AWR中格式化和显示存储的SQL语句的执行计划的内容；
- `DISPLAY_CURSOR`:
   - 格式化和显示任何加载游标的执行计划的内容；
- `DISPLAY_SQL_PLAN_BASELINE`:
   - 为SQL句柄标识的SQL语句显示一个或多个执行计划
- `DISPLAY_SQLSET`:
   - 格式化和显示存储在SQL调谐集中语句的执行计划的内容。

#### DISPLAY_CURSOR函数

- 显示存储在库缓存(Library Cache)中的实际执行计划
  - 如果查询某个SQL语句的实际执行计划，前提是这个SQL的执行计划还在库缓存中，
  - 如果已经被刷出库缓存，就无法获取其实际执行计划。

**参数**

- SQL_ID
   - 指定位于库缓存执行计划中SQL语句的父游标。默认值为NULL。
   - 当使用默认值时，SQL_ID当前会话的最后一条SQL语句的执行计划将被返回。
   - 可通过查询`V$SQL`或`V$SQLAREA`的SQL_ID列来获得SQL语句的SQL_ID
- CURSOR_CHILD_NO
   - 指定父游标下子游标的序号。即指定被返回执行计划的SQL语句的子游标。默认值为0。
   - 如果为NULL，则SQL_ID所指父游标下所有子游标的执行计划都将被返回
- FORMAT
   - 控制SQL语句执行计划的输出部分，即哪些可以显示哪些不显示。
   - 与Display函数的Format参数及修饰符在这里同样适用

**此外**

- 当在开启`STATISTICS_LEVEL=ALL`时，或使用`GATHER_PLAN_STATISTICS`显示可以获得执行计划中实时的统计信息。

**具体使用**

1. 查找SQL语句的SQL_ID

查询V$SQL视图，查找SQL语句的SQL_ID，有可能SQL语句不在Share Pool中，表明SQL语句已经被踢出Share Pool。

```sql
SELECT SQL_ID,CHILD_NUMBER,SQL_TEXT 
FROM V$SQL 
WHERE SQL_TEXT LIKE '%UPDATE CHEPB a SET a.CHEPH=%';

SQL_ID        CHILD_NUMBER SQL_TEXT
------------- ------------ --------------------------------------------------------------------------------
avuy3ax7k40fh            0 SELECT SQL_ID,CHILD_NUMBER,SQL_TEXT FROM V$SQL WHERE SQL_TEXT LIKE '%UPDATE CHEP
5csj10mfqb1wz            0 SELECT SQL_ID,CHILD_NUMBER,SQL_TEXT FROM V$SQL WHERE SQL_TEXT LIKE '%UPDATE CHEP
```

2. 查看实际执行计划

```sql
SELECT *
FROM TABLE (DBMS_XPLAN.DISPLAY_CURSOR('avuy3ax7k40fh',0));

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
SQL_ID  avuy3ax7k40fh, child number 0
-------------------------------------
SELECT SQL_ID,CHILD_NUMBER,SQL_TEXT FROM V$SQL WHERE SQL_TEXT LIKE
'%UPDATE CHEPB a SET a.CHEPH=%'
Plan hash value: 903671040
---------------------------------------------------------------------------
| Id  | Operation        | Name              | Rows  | Bytes | Cost (%CPU)|
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT |                   |       |       |     1 (100)|
|*  1 |  FIXED TABLE FULL| X$KGLCURSOR_CHILD |     1 |   536 |     0   (0)|
---------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter(("KGLNAOBJ" IS NOT NULL AND "KGLNAOBJ" LIKE '%UPDATE
              CHEPB a SET a.CHEPH=%' AND "INST_ID"=USERENV('INSTANCE')))
20 rows selected
```

### 常用Hint （提示）

#### 与优化器相关的Hint

在查看分析SQL语句的执行计划前先要对操作表进行必要的分析，以确保SOL执行计划能够采集到最新信息，从而保证SQL执行计划最优。

对操作表进行分析的SQL语句

```sql
ANALYZE TABLE 表 COMPUTE STATISTICS FOR TABLE|{ALL INDEXES}|{ALL INDEXED COLUMNS};
SET AUTOTRACE TRACEONLY;
```

或

```plsql
EXEC DBMS.STATS.GATHER_SCHEMA_STATS (OWNNAME=>USER,OPTIONS=>'GATHER STALE');
```

```sql
ANALYZE TABLE scott.employees COMPUTE STATISTICS FOR TABLE;
ANALYZE TABLE scott.employees COMPUTE STATISTICS FOR ALL INDEXES;
ANALYZE TABLE scott.employees COMPUTE STATISTICS FOR ALL INDEXED COLUMNS;
SET AUTOTRACE TRACEONLY;
```

```plsql
EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'SCOTT',OPTIONS=>'GATHER STALE');
```

上面SQL语句执行后能确保优化器采集到最新信息或者参考，从而解析出或者制订出效率最优的SQL语句执行计划或者执行方案。

##### ALL_ROWS

- ALL_ROWS是针对整个目标SQL的Hint，它的含义是让优化器启用CBO，而且在得到目标SQL的执行计划时会选择那些吞吐量最佳的执行路径。
     - “吞吐量最佳”是指资源消耗量（对IVO、CPU等硬件资源的消耗量）最小，
     - 在ALL_ROWS Hint生效的情况下，优化器会启用CBO，而且会依据各个执行路径的资源消耗量来计算它们各自的成本。
- 如果目标SOL中除了ALL_ROWS之外，还使用了其他与执行路径、表连接相关的Hint,优化器会优先考虑ALL_ROWS。
- 默认的优化器模式

**查看优化器模式**

```sql
SHOW PARAMETER OPTIMIZER_MODE;
```

**格式：**

```sql
/*+ ALL_ROWS */
```

```sql
SQL> SET AUTOTRACE ON;
SQL> SET AUTOTRACE TRACEONLY;
SQL> SET PAGESIZE 0;
SQL> SET LONG 200000;
SQL> SET FEEDBACK OFF;
SQL> SET ECHO OFF;
SQL> SET LINESIZE 160;
SQL>
SQL> SELECT AVG(salary),last_name,department_name
  2  FROM scott.employees e
  3   JOIN scott.departments d
  4   ON e.department_id = d.department_id
  5  GROUP BY department_name,last_name;

执行计划
----------------------------------------------------------
Plan hash value: 1139150879

---------------------------------------------------------------------------------------------
| Id  | Operation                     | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   1 |  HASH GROUP BY                |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   2 |   MERGE JOIN                  |             |   106 |  3286 |     6  (17)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID| DEPARTMENTS |    27 |   432 |     2   (0)| 00:00:01 |
|   4 |     INDEX FULL SCAN           | DEPT_ID_PK  |    27 |       |     1   (0)| 00:00:01 |
|*  5 |    SORT JOIN                  |             |   107 |  1605 |     4  (25)| 00:00:01 |
|   6 |     TABLE ACCESS FULL         | EMPLOYEES   |   107 |  1605 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")


统计信息
----------------------------------------------------------
        889  recursive calls
          0  db block gets
        235  consistent gets
         16  physical reads
          0  redo size
       3721  bytes sent via SQL*Net to client
        589  bytes received via SQL*Net from client
          8  SQL*Net roundtrips to/from client
         17  sorts (memory)
          0  sorts (disk)
        104  rows processed

SQL> ED
已写入 file afiedt.buf

  1  SELECT /*+ ALL_ROWS*/ AVG(salary),last_name,department_name
  2  FROM scott.employees e
  3   JOIN scott.departments d
  4   ON e.department_id = d.department_id
  5* GROUP BY department_name,last_name
SQL> /

执行计划
----------------------------------------------------------
Plan hash value: 1139150879

---------------------------------------------------------------------------------------------
| Id  | Operation                     | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   1 |  HASH GROUP BY                |             |   106 |  3286 |     7  (29)| 00:00:01 |
|   2 |   MERGE JOIN                  |             |   106 |  3286 |     6  (17)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID| DEPARTMENTS |    27 |   432 |     2   (0)| 00:00:01 |
|   4 |     INDEX FULL SCAN           | DEPT_ID_PK  |    27 |       |     1   (0)| 00:00:01 |
|*  5 |    SORT JOIN                  |             |   107 |  1605 |     4  (25)| 00:00:01 |
|   6 |     TABLE ACCESS FULL         | EMPLOYEES   |   107 |  1605 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")


统计信息
----------------------------------------------------------
         15  recursive calls
          0  db block gets
         13  consistent gets
          0  physical reads
          0  redo size
       3721  bytes sent via SQL*Net to client
        589  bytes received via SQL*Net from client
          8  SQL*Net roundtrips to/from client
          1  sorts (memory)
          0  sorts (disk)
        104  rows processed
```

##### FIRST_ROWS(n)

- FIRST_ROWS(n)是针对整个目标SQL的Hint，
- 让优化器启用CBO模式，而且在得到目标SQL的执行计划时，会选择那些能以最快的响应时间返回头n条记录的执行路径。
- 在FIRST_ROWS(n) Hint生效的情况下，优化器会自用CBO，且会依据返回头n条记录的响应时间来决定目标SQL的执行计划。

**格式：**

```sql
/*+ FIRST_ROWS(n) */
```

**注意**

- Hint的`FIRST_ROWS(n)`的Hint和优化器模式`FIRST_ROWS_n`不是一一对应的。
   - 优化器模式FIRST_ROWS_n中的n只能是1、10、100、1000。
   - Hint的 FIRST_ROWS(n)中的n还可以是其他值。
- 如果在UPDATE、DELETE或者含如下内容的查询语句中使用了FIRST_ROWS(n)Hint，则该Hint会被忽略。
    - 优化器会忽略FIRST_ROWS(n) Hint,是因为对于这些类型的SQL，Oracle必须访问所有的行记录后才能返回满足条件的头n行记录，即在上述情况下，使用该Hint是没有意义的。 
    - 集合运算（如UNION,INTERSACT,MINUS,UNION ALL等）
    - GROUP BY
    - FOR UPDATE
    - 聚合函数（如SUM等）
    - DISTINCT
    - ORDER BY (对应的排序列上没有索引)

##### RULE

- RULE是针对整个目标SQL的Hint
- 表示对目标SQL启用RBO(基于规则的优化器，非Oracle默认)。

**格式：**

```sql
/*+ RULE */
```

**注**

- RULE不能与除`DRIVING_SITE`以外的Hint联用，当RULE与除`DRIVING_SITE`以外的Hint联用时，其他Hint可能会失效
   - 当RULE与DRIVING_SITE联用时，它自身可能会失效，所以RULE Hint最好单独使用。
- 一般情况下，并不推荐使用RULE Hint。
   - 一是因为Oracle早就不支持RBO了，
   - 二是启用RBO后优化器在执行目标SQL时可选择的执行路径将大大减少。
      - 很多执行路径RBO根本就不支持（如哈希连接），也就意味着启用RBO后目标SQL跑出正确执行计划的概率将大大降低。
      - 因为很多执行路径RBO根本就不支持，所以即使在目标SQL中使用了RULE Hint，如果出现了如下这些情况（包括但不限于），RULE Hint依然会被Oracle忽略。
          - 目标SQL除RULE之外还联合使用其他Hint(如DRIVING_SITE)。
          - 目标SQL使用并行执行
          - 目标SQL所涉及的对象有IOT
          - 目标SQL所涉及的对象有分区表
          
#### 与表访问相关的Hint

##### FULL

- 是针对单个目标表的Hint
- 让优化器对目标表执行全表扫描，而不考虑走目标表上的任何索引。

**格式**

```sql
/*+ FULL(目标表) */
```

#### ROWID

- 是针对单个目标表的Hint
- 让优化器对目标表执行ROWID扫描
- 只有目标SQL中使用含ROWID的WHERE条件时，该Hint才有意义

**格式**

```sql
/*+ ROWID(目标表) */
```

#### 与索引访问有关的Hint

##### INDEX

- 是针对单个目标表的Hint
- 让优化器对目标表的目标索引执行索引扫描操作
- 目标索引可以是Oracle数据库中的所有类型索引。

**格式1**

```sql
/*+ 
INDEX(目标表1 目标索引1)
INDEX(目标表2 目标索引2)
  ...
INDEX(目标表n 目标索引n)
*/
```

- 仅指定目标表上的一个目标索引
- 此时优化器只会考虑对这个目标索引执行索引扫描操作，而不会考虑全表扫描或者对该目标表上的其他索引执行索引扫描操作。

**格式2**

```sql
/*+ 
INDEX(目标表1 目标索引1 目标索引2 ... 目标索引n)
INDEX(目标表2 目标索引1 目标索引2 ... 目标索引n)
  ...
INDEX(目标表n 目标索引1 目标索引2 ... 目标索引n)
*/
```

- 指定目标表上的n个目标索引
- 此时优化器只会考虑对这n个目标索引执行索引扫描操作。
   - 可能是分别计算出单独扫描各个目标索引的成本后，选择成本值最低的索引。
   - 也可能是先分别扫描目标索引中的两个或多个索引，然后对扫描结果执行合并操作。
      - 这个可能的前提：优化器计算出来这样做的成本值最低 。即成本值最低原则。

**格式3**

```sql
/*+ 
INDEX(目标表1 (目标索引1的索引列名) (目标索引2的索引列名1 目标索引2的索引列名2...) ... (目标索引n的索引列名))
INDEX(目标表2 (目标索引1的索引列名) (目标索引2的索引列名1 目标索引2的索引列名2...) ... (目标索引n的索引列名))
  ...
INDEX(目标表n (目标索引1的索引列名) (目标索引2的索引列名1 目标索引2的索引列名2...) ... (目标索引n的索引列名))
*/

--如果目标索引2是复合索引，使用如上指定该目标索引的多个索引列，各个索引列之间用空格分隔。
```

- 同格式2

**格式4**

```sql
/*+ 
INDEX(目标表1)
INDEX(目标表2)
  ...
INDEX(目标表n)
*/
```

- 指定目标表上所有已存在的索引
- 此时优化器只会考虑对该目标表上所有已存在的索引执行索引扫描操作，而不会考虑全表扫描操作。
   - 成本最低原则

##### NO_INDEX

- 针对单个目标表的Hint
- 是INDEX的反义Hint，让优化器不对目标表上的目标索引执行扫描操作。
- 目标索引可以是Oracle数据库中的所有类型索引。

**格式1**

```sql
/*+ NO_INDEX(目标表 目标索引) */
```

- 仅指定目标表上的一个目标索引
- 此时优化器只是不会考虑对该目标表上的这个目标索引执行索引扫描操作，但还是会考虑全表扫描操作或对该目标表上的其他索引执行索引扫描操作。

**格式2**

```sql
/*+ NO_INDEX(目标表 目标索引1 目标索引2 ... 目标索引n) */
```

- 指定目标表上的n个目标索引
- 此时优化器只是不会考虑对该目标表上的这n个目标索引执行索引扫描操作。

**格式3**

```sql
/*+  NO_INDEX(目标表 (目标索引1的索引列名) (目标索引2的索引列名1 目标索引2的索引列名2...) ... (目标索引n的索引列名)) */

--如果目标索引2是复合索引，使用如上指定该目标索引的多个索引列，各个索引列之间用空格分隔。
```

- 同格式2

**格式4**

```sql
/*+ NO_INDEX(目标表) */
```

- 指定目标表上所有已存在的索引
- 相当于对目标表指定全表扫描操作，此时优化器不会考虑对该目标表上所有已存在的索引执行索引扫描操作。

##### INDEX_DESC

- 针对单个目标表的Hint
- 让优化器对目标表上的目标索引执行索引降序扫描操作。
    - 如果目标索引是升序的，则INDEX_DESC Hint使Oracle以降序的方式扫描该索引
    - 如果目标索引是降序的，则INDEX_DESC Hint使Oracle以升序的方式扫描该索引

**格式1**

```sql
/*+ INDEX_DESC(目标表 目标索引) */
```

**格式2**

```sql
/*+ INDEX_DESC(目标表 目标索引1 目标索引2 ... 目标索引n) */
```

**格式3**

```sql
/*+ INDEX_DESC(目标表 (目标索引1的索引列名) (目标索引2的索引列名1 目标索引2的索引列名2...) ... (目标索引n的索引列名)) */

--如果目标索引2是复合索引，使用如上指定该目标索引的多个索引列，各个索引列之间用空格分隔。
```

**格式4**

```sql
/*+ INDEX_DESC(目标表) */
```

##### INDEX_COMBINE

- 针对单个目标表的Hint
- 让优化器对目标表上的多个目标索引执行位图布尔运算。
- 作用对象可以是：位图索引 / B*tree索引 

**格式1**

```sql
/*+ INDEX_COMBINE(目标表 目标索引1 目标索引2 ... 目标索引n) */
```

- 指定目标表上的n个目标索引
- 此时优化器会考虑对这n个目标索引中的两个或多个执行位图布尔运算

**格式2**

```sql
/*+ INDEX_COMBINE(目标表) */
```

- 指定目标表上所有已存在的索引
- 此时优化器会考虑对改表上已存在的所有索引中的两个或多个执行位图布尔运算。

**BITMAP相关关键字的出现 P45**

##### INDEX_FFS

- 针对单个目标表的Hint
- 让优化器对目标表上的目标索引执行索引快速全扫描操作
- 索引快速全扫描操作成立前提：
  - SELECT语句中所有的查询列都存在于目标索引中

**格式1**

```sql
/*+ INDEX_FFS(目标表 目标索引) */
```

**格式2**

```sql
/*+ INDEX_FFS(目标表 目标索引1 目标索引2 ... 目标索引n) */
```

**格式3**

```sql
/*+ INDEX_FFS(目标表 (目标索引1的索引列名) (目标索引2的索引列名1 目标索引2的索引列名2...) ... (目标索引n的索引列名)) */

--如果目标索引2是复合索引，使用如上指定该目标索引的多个索引列，各个索引列之间用空格分隔。
```

**格式4**

```sql
/*+ INDEX_FFS(目标表) */
```

##### INDEX_JOIN 

- 针对单个目标表的Hint
- 让优化器对目标表上的多个目标索引执行INDEX JOIN操作
- INDEX JOIN成立前提：
   - SELECT语句中的所有查询列都存在于目标表的多个目标索引中

**格式1**

```sql
/*+ INDEX_JOIN(目标表 目标索引1 目标索引2 ... 目标索引n) */ 
```

**格式2**

```sql
/*+ INDEX_JOIN(目标表) */
```

##### AND_EQUAL 

- 针对单个目标表的Hint
- 让优化器对目标表上的多个目标索引执行INDEX MERGE操作
- INDEX MERGE成立前提：
   - 目标SQL的WHERE条件中出现了多个针对不同单列的等值条件，并且这些列上都有单键值的索引。
   - 在Oracle数据库中，能够做INDEX MERGE的索引数量最大值为5

**格式**

```sql
/*+ AND_EQUAL(目标表 目标索引1 目标索引2 ... 目标索引5)
```

#### 与表连接顺序有关的Hint

##### ORDERED

- 针对多个目标表的Hint
- 让优化器对多个目标表执行表连接操作时，依照他们在目标SQL的WHERE条件中出现的顺序从左到右依次进行连接。

**格式**

```sql
/*+ ORDERED(目标表1 目标表2 ... 目标表n) */
```

##### LEADING

- 针对多个目标表的Hint
- 让优化器将指定的多个表的连接结果作为目标表连接过程中的驱动结果集，并且将LEADING Hint中从左到右出现的第一个目标表作为整个表连接过程中的首个驱动表。
   - LEADING只是指定了首个驱动表。而ORDERED是要优化器依照给出的顺序来连接 
- 当LEADING Hint中指定的表并不能作为目标SQL的连接过程中的驱动表或者驱动结果集时，Oracle忽略该Hint。

**格式**

```sql
/*+ LEADING(目标表1 目标表2 ... 目标表n) */
```

## Oracle优化器

## 内外存优化

|     项目     | 内存 | 外存 |
| :---------: | :--: | :--: |
| 数据访问速度 | 很快 | 很慢 |
|  存储的数据  | 临时 | 永久 |

- 将尽可能多的磁盘（外存）操作变成内存操作，即尽可能减少IO。在一个数据库系统中，IO操作越少，系统的效率一定会越高。

### DBMS_SHARED_POOL软件包 将程序常驻内存 

#### V$DB_OBJECT_CACHE数据字典，查看内存使用情况

- 共享池中对象级的统计信息

```sql
SELECT name
      ,namespace
      ,sharable_mem
      ,executions
      ,kept
FROM V_$DB_OBJECT_CACHE
WHERE LOWER(OWNER) = 'scott';
```

#### 安装DBMS_SHARED_POOL软件包

- Oracle系统自带一个`dbmspool.sql`的脚本文件，保存在其他维护脚本文件相同的目录下。
   - 目录：`C:\app\zjk10\product\11.2.0\dbhome_1\RDBMS\ADMIN\dbmspool.sql` 
- 使用SYSDBA的权限安装
   - 11.2或12.1中默认SYSTEM用户权限也可以安装

```
@C:\app\zjk10\product\11.2.0\dbhome_1\RDBMS\ADMIN\dbmspool.sql
```

#### 使用DBMS_SHARED_POOL.KEEP()

- 将程序在 V_$DB_OBJECT_CACHE数据字典中标识为KEPT

```sql
EXECUTE DBMS_SHARED_POOL.KEEP('scott.show_name');
--可以是存储过程，存储函数，软件包，触发器，序列号等。
```

```sql
SQL> EXECUTE DBMS_SHARED_POOL.KEEP('SCOTT.SHOW_NAME');
PL/SQL procedure successfully completed
```
#### 清空共享池内存

```sql
ALTER SYSTEM FLUSH SHARED_POOL;
```

- V_$DB_OBJECT_CACHE数据字典中标识为KEPT的对象是不能被以上语句清除的

#### DBMS_SHARED_POOL.UPKEEP()

```sql
EXECUTE DBMS_SHARED_POOL.UNKEEP('用户.程序名');
--可以是存储过程，存储函数，软件包，触发器，序列号等。
```

```sql
SQL> EXECUTE DBMS_SHARED_POOL.UNKEEP('scott.show_name');
PL/SQL procedure successfully completed
```

### 缓存表

#### 获取所有表的相关信息

```sql
SELECT table_name
      ,tablespace_name
      ,cache  --是否缓存在内存中
FROM USER_TABLES;
```

```sql
TABLE_NAME                     TABLESPACE_NAME                CACHE
------------------------------ ------------------------------ --------------------
DEPT                           USERS                              N
EMP                            USERS                              N
BONUS                          USERS                              N
SALGRADE                       USERS                              N
LOG_TABLE                      USERS                              N
TEST                           USERS                              N
```

- 以上的CACHE属性都是N，表示：这些表没有缓存在内存中，
    - 即这些表在进行全表扫描操作时，其数据都放在数据库缓冲区的LRU队列的队尾。
- 而缓存表的数据是放在LRU队列的队头，但随着时间的推移有可能被淘汰出数据库缓冲区

#### 修改为缓存表

- 缓存的表应该要是经常使用的表，且这个表不能太大。
   - 防止浪费或占满数据库缓冲区。 

```sql
ALTER TABLE test CACHE;
```

```sql
TABLE_NAME                     TABLESPACE_NAME                CACHE
------------------------------ ------------------------------ --------------------
TEST                           USERS                              Y
```

#### 从缓存表改为非缓存表

```sql
ALTER TABLE test NOCACHE;
```

### 数据常驻内存

#### 查看相关信息

```sql
--为DBA数据字典收集信息
EXECUTE dbms_stats.gather_index_stats('SCOTT','EMP_EMP_ID_PK')
EXECUTE dbms_stats.gather_table_stats('SCOTT','EMPLOYEES')

SHOW PARAMETER BLOCK_SIZE;
--DBA 显示当前数据库的数据块大小
SELECT owner
      ,segment_type
      ,blocks
FROM DBA_SEGMENTS
WHERE OWNER = 'SCOTT%'
 AND segment_name IN ('EMPLOYEES',' EMP_EMP_ID_PK');
--将得到的 (blocks值相加)*8/1024;

--DBA 查看数据库内存缓冲区
方式1.
SHOW PARAMETER DB_KEEP_CACHE_SIZE;
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
db_keep_cache_size                   big integer 0
--未设置数据库缓冲区
方式2.
SELECT id
      ,name
      ,block_size
      ,buffers
FROM V$BUFFER_POOL;
        ID NAME                 BLOCK_SIZE    BUFFERS
---------- -------------------- ---------- ----------
         3 DEFAULT                    8192     354600
--未设置数据库缓冲区

--查看表使用的数据库缓冲区信息
SELECT table_name
      ,tablespace_name
      ,buffer_pool
FROM USER_TABLES
WHERE table_name = 'EMPLOYEES';
--查看索引使用的数据库缓冲区信息
SELECT index_name
      ,table_name
      ,tablespace_name
      ,buffer_pool
FROM USER_INDEXES
WHERE TABLE_NAME = 'EMPLOYEES';
```

#### 设置数据库缓冲区keep

```sql
ALTER SYSTEM 
SET DB_KEEP_CACHE_SIZE = 64 M;
```

#### 修改表/索引使用的缓冲区 ,即常驻内存

```sql
ALTER TABLE employees
STORAGE (BUFFER_POOL keep);

ALTER INDEX emp_emp_id_pk
STORAGE (BUFFER_POOL keep);
```

- 当用户使用这个表/索引的时候，Oracle服务器就将这个表/索引放入KEEP BUFFER POOL中并一直保留在其中，即常驻内存。

#### 将表/索引重新放回默认数据库缓冲区，即不再常驻内存

```sql
ALTER TABLE employees
STORAGE (BUFFER_POOL default);

ALTER INDEX emp_emp_id_pk
STORAGE (BUFFER_POOL default);
```

#### 释放KEEP BUFFER POOL所占的内存空间 即不再需要keep缓冲区

```sql
ALTER SYSTEM SET DB_KEEP_CACHE_SIZE = 0;
```

### 将查询的结果缓存在内存 

**共享查询的结果**

- Oracle11g和Oracle12c是使用共享池中的一个专用的内存缓冲区来存储这些缓存的SQL查询结果的。
- 只要这些缓存的查询结果是有效的，其他的语句和会话就可以共享它们。
    - 如果所查询的对象被修改了，则这些缓存的查询结果就变成无效的了。

- 尽管任何查询的结果都可以缓存在内存中，不过那些要访问大量的数据行而只返回少量数据的查询语句才是最好的候选者。

**Oracle系统如何处理缓存查询结果**

当第一个会话执行一个查询时，该查询语句将从数据库中获取数据，然后将这一查询的结果存储在SQL查询结果的内存缓冲区中。如果第二个会话（也包括之后的所有会话）执行相同的查询语句，其查询语句将从查询结果的内存缓冲区中直接提取结果而不需要访问硬盘了。

#### result_cache_mode参数

- 控制Oracle的优化器是否自动地将查询的结果存入查询结果缓冲区。

- result_cache_mode参数在系统/会话级设置，其可取的值为AUTO、MANUAL或FORCE

| 值      | 说明                                                         |
| :----- | :----------------------------------------------------------- |
| AUTO   | 优化器依据执行重复的次数决定哪些查询结果存入结果缓冲区。          |
| MANUAL | 默认，要使用`/*+ RESULT_CACHE */`说明将查询结果存入结果缓冲区中 |
| FORCE  | 所有的查询的结果都存入结果缓冲区中                              |


##### 查看result_cache_mode参数的设置

```sql
SHOW PARAMETER result_cache_mode;
```

#### 使用`SQL*Plus`的EXPLAIN PLAN FOR命令

- Oracle首先查看结果内存缓冲区以检查查询的结果是否已经在这个缓冲区中。
- 如果存在则直接从这个内存缓冲区中取出结果，
- 如果不存在就执行这一语句，并将返回的查询结果存入到结果内存缓冲区。

```sql
EXPLAIN PLAN FOR
SELECT /*+ RESULT_CACHE */ department_id
      ,AVG(salary)
      ,COUNT(salary)
      ,MIN(salary)
      ,MAX(salary)
FROM employees
GROUP BY department_id;

SQL> /
Explained
```

**获取所解释SQL语句的执行计划**

```
SELECT id
      ,operation
      ,options
      ,object_name
FROM plan_table;

  ID OPERATION        OPTIONS          OBJECT_NAME
--- ---------------- ---------------- ------------------------------
 0 SELECT STATEMENT                       
 1 RESULT CACHE                         bba140yxjhwj22rgcwwfgkdur3
 2 HASH                GROUP BY                                                                         
 3 TABLE ACCESS        FULL             EMPLOYEES
```

#### DBMS_RESULT_CACHE 软件包

**查看查询结果缓冲区的状态**

```sql
SELECT DBMS_RESULT_CACHE.STATUS 
FROM dual;
```

**将所有依赖于该表的缓存结果设置为无效**

```sql
EXEC DBMS_RESULT_CACHE.INVALIDATE('SCOTT','EMPLOYEES');
```

**将结果内存缓冲区清空**

```sql
EXEC DBMS_RESULT_CACHE.FLUSH;
```

**获取结果缓冲区使用的统计信息**

```sql
SET SERVEROUTPUT ON;

EXEC DBMS_RESULT_CACHE.MEMORY_REPORT;

--------------------------------------------------------
R e s u l t   C a c h e   M e m o r y   R e p o r t
[Parameters]
Block Size          = 1K bytes
Maximum Cache Size  = 16192K bytes (16192 blocks)
Maximum Result Size = 809K bytes (809 blocks)
[Memory]
Total Memory = 10704 bytes [0.001% of the Shared Pool]
... Fixed Memory = 10704 bytes [0.001% of the Shared Pool]
... Dynamic Memory = 0 bytes [0.000% of the Shared Pool]

PL/SQL 过程已成功完成。
```

##### 相关的数据字典

- V$RESULT_CACHE_STATISTICS:
   - 列出各种缓存的设置和内存使用的统计信息。
- V$RESULT_CACHE_MEMORY:
   - 列出所有内存块和对应的统计信息。
- V$RESULT_CACHE_OBJECTS:
   - 列出所有对象（缓存结果和依赖的）连同它们的属性。
- V$RESULT_CACHE_DEPENDENCY:
   - 列出所有缓存结果和依赖性之间的依赖性细节。

### 跨会话的PL/SQL函数结果缓存

函数结果缓存机制，这种缓存机制将PL/SQL函数的结果存储在共享池中并提供了语言的支持和系统管理方法，而运行的应用程序的每一个会话都可以访问这一缓存后的PL/SQL函数结果。这种缓存机制对于应用而言是既有效又简单，而且它也减轻了设计和开发自己的缓存和缓存管理应用的负担。

当每次使用不同的参数值调用一个结果缓存的PL/SQL函数时，这些参数和该函数的返回值都会被存储在内存缓冲区中。随后，当相同的函数以相同的参数值被调用时，Oracle服务器将从结果缓冲区中提取该函数的结果。如果被用来计算缓存结果的一个数据库对象被修改了，那么缓存的结果就变成了无效并且必须重新计算。

通常使用这一结果缓存特性的适用范围是：那些经常被调用并且所依赖的信息（对象）从来不变或很少变化的函数。

- 要开启一个PL/SQL函数的结果缓存功能，只需**在函数中加入RESULT_CACHE子句**。
- 当一个结果缓存函数被调用时，Oracle系统首先检查函数的结果缓存。
    - 如果缓冲区中包含了之前以相同参数值调用这一函数的结果，那么系统就直接将缓存的结果返回给调用者而并不执行函数体（即函数的PL/SQL程序代码)。
    - 如果缓冲区中没有包含该函数的结果，那么系统就执行这一函数体并在控制返回调用者之前将其结果（连同使用的参数值）添加到结果缓冲区中。
- 在这个结果缓冲区中可以存放许多结果一对于调用该函数的每一个唯一的参数值的组合都有一个结果。
- 如果系统需要更多的内存，那么一个或多个结果会被从结果缓冲区中清除。
- 如果函数在执行期间产生了一个无法处理的异常，这个异常的结果不会被存储在结果缓冲区中。

```sql
CREATE OR REPLACE FUNCTION select_hire_date
(
 v_id NUMBER
)
RETURN VARCHAR2
RESULT_CACHE RELIES_ON(copy_emp)
IS
 v_hire_date DATE;
BEGIN
 SELECT hire_date
 INTO v_hire_date
 FROM copy_emp
 WHERE employee_id = v_id;

 RETURN TO_CHAR(v_hire_date,'YYYY"年"MM"月"DD"日"');
END; 

EXEC DBMS_OUTPUT.PUT_LINE(select_hire_date(177));
```

**查看是否放入结果内存缓冲区**

- 使用sys用户

```sql
SELECT name
      ,status
FROM V$RESULT_CACHE_OBJECTS;

 NAME                                                                  STATUS
-------------------------------------------------------------------- -------------------
"SCOTT"."SELECT_HIRE_DATE"::8."SELECT_HIRE_DATE"#762ba075453b8b0d #1  Invalid
```

### DBMS_STATS 为数据字典收集相关的统计信息

- 以DBA_XXXX的数据字典都是静态数据字典，为了数据库的效率，Oracle并不实时更新。

```sql
EXECUTE dbms_stats.gather_index_stats('SCOTT','EMPLOYEES_INDEX')
```

```sql
EXECUTE dbms_stats.gather_table_stats('SCOTT','EMPLOYEES')
```

